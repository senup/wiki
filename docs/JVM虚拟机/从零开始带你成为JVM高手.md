---
title: 从零开始带你成为JVM高手
date: 2023-12-24 21:08:14
Tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

## 001、开篇词：JVM 优化实战，广大 Java 工程师心中永远的痛！

啥都没有。

## 002、一探究竟：我们写的 Java 代码到底是如何运行起来的？

逻辑就是我们写的 Java 代码会被 Java 虚拟机打包成为 jar 包，jar 包里面存放的是编译后的字节码。字节码能够在不同平台上实现统一的效果。

那么这些 class 文件怎么加载呢？就需要类加载器将其放到内存里面进行加载来执行代码。
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312242111589.png)

### 思考题：反编译后 jar 是不是就能获取源码？

可以使用代码混淆的技术，目前有些商业公司在做。同时还有访问控制呀，网络防火墙呀，敏感信息加密等等手段。

<!--more-->

## 003、面试官对于 JVM 类加载机制的猛烈炮火，你能顶住吗？

### JVM 在什么情况下会加载一个类？

当代码加载到类的时候，就会去将元空间的一个 class 对象加载到内存里面，类加载的过程：加载、验证、准备、解析、初始化、执行静态代码块、卸载。

### 从实用角度出发，来看看验证、准备和初始化的过程

验证：验证文件的准确性：符合规范、防止篡改；
准备：给类变量开辟内存空间并赋予了初始值；
解析：符号引用变为直接引用；

### 核心阶段：初始化

初始化：区别于准备阶段，这一阶段会给静态变量真正赋值；

### 类加载器和双亲委派机制

类加载器是用来加载 class 文件，后面进行实例化；
双亲委派机制：启动类（lib 包）、拓展类（lib/ext 包）、应用（classpath）、自定义（继承 classloader 接口）四种加载器。
定义的流程：先找父类加载器加载，不行再找子类加载器。
作用：为了确保执行的效果一致，比如当两个类处在不同的加载器里面，使用双亲委派就能实现统一的效果；同时保证底层的 jar 包优先加载。
为什么不直接从顶到底加载，而要迂回两程？因为当我们定义了一个类加载器的时候，我们只知道父子结构，所以需要递归向上去找到底层。
双亲委派能不能打破？能，Tomcat 就打破了。实现了系统三级找不到之后，就走自己的一个体系的类加载器。

## 004、大厂面试题：JVM 中有哪些内存区域，分别都是用来干嘛的

### 到底什么是 JVM 的内存区域划分？

为什么要划分？因为我们有各种各样的逻辑，其中的对象需要存放，所以根据不同的特性划分了四个区域。

### 存放类的方法区

方法区存放了加载进来的 class 类的静态变量、 还有常量等。

在 jdk 1.7 的时候方法区的常量放到了堆里，1.8 的时候方法区放到了对外的直接内存，并改名成为元空间。
为什么要这么改？因为方法区的大小不可调节，无法避免溢出；而元空间所在的直接内存有扩容的余地。

### 执行代码指令用的程序计数器

为什么不放在代码里？因为数据是数据，指令是指令，因此区分开。
作用：用于标识当前字节码文件执行到哪一行。

### Java 虚拟机栈

栈里面存放着栈帧，局部变量，操作数栈，动态链接、方法入口等。
还有一个本地方法栈，是 native 方法使用的。

### Java 堆内存

存放各种各样的对象。

### 核心内存区域的全流程串讲

这里要结合有嵌套方法的一个代码案例来讲。
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312242131632.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312242131071.png)

### 其他内存区域

设计了 io、nio、socket 等。

## 005、JVM 的垃圾回收机制是用来干嘛的？为什么要垃圾回收？

为什么呢？因为对象不断创建，而堆空间是有限的，所以需要对这些用不上的垃圾对象进行回收。

### 对象的分配与引用

对象怎么分配？他是首先在堆里会新建一个对象，然后呢栈中的局部变量会引用这个对象。

### 一个方法执行完毕后会怎样？

执行完成之后，会出栈，栈就在内存中被清理了，此时堆中的对象就没有任何引用了。

### 我们创建的 Java 对象其实都是占用内存资源的

确实，因为空间优先。

### 不再需要的那些对象应该怎么处理？

需要定期被垃圾回收线程清理掉，释放内存。

### 我们创建的那些对象，到底在 Java 堆内存里会占用多少内存空间呢？

可以这么说，对象本身的信息+对象的实例变量占用的空间。
对象头 4 字节，然后看他还带了什么类型的变量，再进行一个对其填充，满足某些内存对齐的需求。
对象头包含的内存：Markword、类的指针、对齐填充；
markword: hashcode，锁相关（分代年龄，偏向锁，偏向锁 id）

## 006、第 1 周作业：不借助任何资料，画出 JVM 整体运行原理图

代码-jar 包-类加载器-双亲委派-加载类加载器（加载、验证、准备、解析、初始化、执行静态代码、卸载）-对象实例化（在堆中开辟空间、复制元空间的类信息、初始化对象）。

对象的四种加载方式：new 、clone、反序列化、反射。

## 007、第 1 周答疑：本周问题统一答疑

Object Header（4 字节） + Class Pointer（4 字节）+ Fields（看存放类型），但是 jvm 内存占用是 8 的倍数，所以结果要向上取整到 8 的倍数；

-XX:+TraceClassLoading 可以看加载了哪些类，动手实验了一下，jre\lib\rt. Jar 下的类全部加载了，其他都是用到时候加载。

Tomcat 加载图：![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312242143463.png)

## 008、聊聊 JVM 分代模型：年轻代、老年代、永久代

### 大部分对象其实存活周期极短

毕竟大部分随着代码执行结束就失去引用，直接被回收。

### 少数对象是长期存活的

确实。

### JM 分代模型：年轻代和老年代

这里应该有个图。
比如嵌套调用一次的方法那么进入年轻代后很快就被回收了；但是对于死循环内给静态属性复制的那个对象，就会到达年龄后直接进入老年代；

### 为什么要分成年轻代和老年代？

因为对象的存活时间不同。年轻代朝生夕死，存活的对象很少；老年代存活时间长，而且老年代中对象很多。

### 什么是永久代？

永久代存放着 class 对象的静态属性、常量池。

永久代什么时候被回收？就是当类的 class 对象不被引用、没有类的对应实例对象、类的类加载器已经被回收，三个条件满足那么就会回收方法区；

永久代会不会溢出？会的，比如使用 cglib 的 enhance 不断重复创建动态对象那么 class 类会剧增。

### 每个线程都有 Java 虚拟机栈，里面也有方法的局部变量等数据，这个 Java 虚拟机栈需要进行垃圾回收吗？为什么？

不需要，因为栈帧结束，在内存中就被清理了。

## 009、大厂面试题：你的对象在 JVM 内存中如何分配？如何流转的

### 大部分正常对象都优先在新生代分配内存

先到新生代再到老年代。

### 到底什么情况下会触发新生代的垃圾回收？

新生代空间不足的时候，满了。

### 长期存活的对象会躲过多次垃圾回收

是的。默认是 15 次。每次 GC 都会给年龄加一。

### 老年代会垃圾回收吗？

会的，full GC。

### 关于新生代和老年代的对象分配，这就完了吗？

年轻代进入老年代：

- 年老十五岁
- 动态年龄：所有对象加起来，其中多个年龄超过了 survivor 的一半，那么这个年龄及其之上的对象就会被放到老年代里面，给新生代留空间。
- 超大的对象直接进入老年代；
- 空间担保机制：以外会判断新生代可能 GC 完一个都没回收，那么老年代的空间需要打印新生代的全部对象，如果没有，那么这个时候直接 full GC；有了这个担保机制的参数，handlePromotionFailure 就会再试一次：只需要确认历代的一个新生代进入老年代的平均对象小于老年代的剩余空间，那么就可以 young GC。

### 自己系统内，短生存周期的对象都有什么，长生存周期的对象都有什么？

短周期：自己写的一些代码；
长周期：比如 controller、Service 这些。

## 010、动手实验：亲自感受一下线上系统部署时如何设置 JVM 内存

### 跟 JVM 内存相关的几个核心参数图解

xms 和 xmx 设置堆空间的大小；
xmn: 设置新生代的大小，剩下的就是老年代的大小；
xss: 设置栈的大小；
metaSpaceSize 和 metaSpaceMaxSize 设置元空间的大小；

### 如何在启动系统的时候设置 JVM 参数？

idea 可以设置 VM arguement;

### 通过案例，学习参数优化设置的预告

列举一个支付案例，讲明需要怎么去配置 jvm 参数。

### 部署系统通过什么方式来设置 jvm 参数的？

我们是在容器内设置的。

## 011、案例实战：每日百万交易的支付系统，如何设置 JVM 堆内存

### 支付系统背景引入

项目-支付系统-用户三足鼎力。

### 支付的核心业务流程

高峰期创建 n 多的订单，那么这个时候 jvm 就会产生大量的一个对象在堆内。

### 每日百万交易的支付系统的压力在哪里？

如果设置不好的话那么会频繁 full GC。

### 支付系统每秒钟需要处理多少笔支付订单？

可以使用 82 法则。每天的所有订单的 80%，然后看下需要在几个小时内处理，平均一下就是每秒的订单量。

### 每个支付订单处理要耗时多久？

耗时多久，要咋看呢？

### 每个支付订单大概需要多大的内存空间？

可以粗略估算 20 个变量的一个对象就是 500 字节；
1 kb=1024byte；

### 每秒发起的支付请求对内存的占用

内存的占用我们可以翻个十倍去菇凉。

### 让支付系统运行起来分析一下

想一想每秒近年轻代有多少大小的订单对象，这些订单对象什么时候死亡。

### 对完整的支付系统内存占用需要进行预估支付系统的 JVM 堆内存应该怎么设置？

因为这些对象朝生夕死，所以可以考虑年轻代和老年代的比例为 2:1，这样的话尽量在年轻代中死去，不要进入老年代。

思考题：

> 你会去按照本文类似的思路估算系统压力吗？
> 你会去估算系统的 JVM 内存压力吗？
> 然后会去有针对性的合理设置 JVM 参数吗？
> 你们之前是这么做的吗？为什么？

## 012、案例实战：每日百万交易的支付系统，JVM 栈内存与永久代如何设置？

### 基于案例，说说不合理设置内存的反面示例

内存设置太小, 频繁 GC.

### 大促期间，瞬时访问量增加十倍

主要是讲大促要估算十倍。

### 少数请求需要几十秒处理，导致老年代内存占用变大

对象太久处理完，那么这个时候新生代的可用空间就会小，等他处理完很多对象都因为新生代空间小提前进入了老年代。

### 老年代对象越来越多导致频繁垃圾回收

不断进行 GC。

### 反面案例总结

内存不能设置过小。

### 如何合理设置永久代大小？

一般设置五百 M 够了。

### 如何合理设置栈内存大小

一般是 512kb 或者 1MB 就够了。

思考题：如果系统业务量暴涨十倍，会出现什么问题？

## 013、第 2 周作业：看看你们的线上系统是如何设置 JVM 内存大小

设置的是堆 4G, 方法区五百兆，然后采用 cms 的算法，年轻代是 2G, 栈的大小默认。

## 014、第 2 周答疑：本周问题答疑，上周作业点评

### 类的初始化时机？

- 类的新实例
- 调用类的静态方法
- 调用类的静态字段
- 反射的方法
- 初始化某个类的子类
- 被标为启动类的类

## 015、大厂面试题：什么情况下 JVM 内存中的一个对象会被垃圾回收

### 什么时候会触发垃圾回收？

堆。

### 被哪些变量引用的对象是不能回收的？

被 Gc root 引用的变量不能被回收。

什么是 GC root？就是我们栈中的局部变量、类的静态属性、本地方法栈引用的变量。

如果在这些变量的引用链上面，那就说明对象存活不能回收；反之对象没有引用，可以直接被回收。

### Java 中对象不同的引用类型

强引用：不会被回收，比如 new 的时候；
软引用：sofeReference 修饰，内存不足的时候会回收；
弱引用：weakReference 修饰，只要 Gc 就回收；
虚引用：一般用不上，主要是为了回收之后的一个通知。

### Finalize 方法的作用

如果没有引用，就会被回收。有一种方法可破，重新类对象的 finalize 方法，让其重新给自己的静态属性赋值。

## 016、大厂面试题：JVM 中有哪些垃圾回收算法，每个算法各自的优劣？

### 复制算法的背景引入

将空间一分为二，清理掉另一半；
优点是内存碎片少，缺点是空间利用率不高；

### 一种不太好的垃圾回收思路

就是直接标记垃圾对象后直接清理，直接导致内存碎片，后续对象很难创建连续内存较大的空间。

### 一个合理的垃圾回收思路

分成两块。

### 复制算法有什么缺点？

缺点是空间利用率不高。

### 复制算法的优化：Eden 区和 Survivor 区

垃圾回收的时候将 Eden 和 survivor 的存活的对象放到另一个 survivor 区里，提高了空间的利用率，毕竟新生代的存活对象很少很少。

### 新生代垃圾回收的各种“万一”怎么处理？

万一垃圾回收过后，存活下来的对象超过了 10%的内存空间，在另外一块 Survivor 区域中放不下咋整？回答：进入老年代；

万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？回答：进入老年代；

到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？回答：默认 15 次。

## 017、大厂面试题：年轻代和老年代分别适合什么样的垃圾回收算

### 躲过 15 次 GC 之后进入老年代

是这样的。

### 动态对象年龄判断

所有年龄加起来，按照年龄排序，同龄的对象占用超过 survivor 一半以上，将该年龄和年龄之上的对象统统放在老年代。

### 大对象直接进入老年代

因为年轻代的 survivor 放不了。

### Minor GC 后的对象太多，无法放入 Survivor 区怎么办？

进入老年代。

### 老年代空间分配担保规则

以前是需要判断新生代的对象总大小<老年代剩余空间。
现在是判断新生代进入老年代的平均大小<老年代的剩余空间。

### 老年代垃圾回收算法

- 标记清除：产生内存碎片
- 标记整理：执行较久，毕竟对象多，还需要移动空间

%% serial old：单线程，需要 stw，使用不多，适用于离线处理； %%

思考题：

### 到底什么时候会尝试触发 Minor GC？

- Eden 空间不足

### 触发 Minor GC 之前会如何检查老年代大小，涉及哪几个步骤和条件？

- 15 岁
- 动态年龄

### 什么时候在 Minor GC 之前就会提前触发一次 Full GC？

- 老年代空间不足
-

### Full GC 的算法是什么？

- 标记清楚+整理。

### Minor GC 过后可能对应哪几种情况？

- 进入老年代
- Oom
- 还在年轻代

### 哪些情况下 Minor GC 后的对象会进入老年代？

- 大对象
- 15 岁
- 动态年龄

## 018、大厂面试题：JVM 中都有哪些常见的垃圾回收器，各自的特点吗？

serial：单线程、stw, 离线处理，几乎不用；

parNew: 新生代+cms 老年代；

G 1：采用分代的思想，新生代用复制算法，老年代用标记整理算法。

## 019、“Stop the World”问题分析：JVM 最让人无奈的痛点！

阻塞所有的工作线程。

## 系统停顿时间

新生代可能几百毫秒；
老年代可能几秒，几十秒等。

思考题：到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？

多线程回收好。充分利用处理器多核的特性，加速垃圾回收。

## 020、第 3 周作业：自己动手画出各种垃圾回收算法和垃圾回收器

对象在新生代的分配
什么时候会触发 Minor GC
触发 Minor GC 之前会如何检查老年代可用内存大小和新生代对象大小
如何检查老年代可用内存大小和历次 Minor GC 之后升入老年代的平均对象大小
什么情况下 Minor GC 之前会提前触发 Full GC
什么情况下会直接触发 Minor GC
Minor GC 之后有哪几种情况对象会进入老年代

## 021、第 3 周答疑：本周问题答疑，上周作业点评

### 一个面试题：parnew+cms 的 gc，如何保证只做 ygc，jvm 参数如何配置？

- 分代年龄调大
- 新生代空间调大
- 设置老年代 cms 的回收比例，调大一点，
- 保证进入老年代的对象很少

## 022、一步一图：深入揭秘 JVM 的年轻代垃圾回收器 ParNew 是如何工作的

### 最常用的新生代垃圾回收器：ParNew

并行处理新生代的垃圾呗。

### 如何为线上系统指定使用 ParNew 垃圾回收器？

-XX:+UseParNewGC

### ParNew 垃圾回收器默认情况下的线程数量

调节 ParNew 的垃圾回收线程数量，也是可以的，使用“-XX: ParallelGCThreads”参数即可，通过他可以设置线程的数量。

## 023、一步一图：那 JVM 老年代垃圾回收器 CMS 工作时，内部又干啥了

### CMS 垃圾回收的基本原理

主要算法是标记清理，四个阶段：初始标记、并发标记、重新标记、并发清理。

第一和第三阶段会阻塞，但是标记的很快，重新标记只需要对少量改动过得对象标记即可。
耗时主要是第二阶段的并发标记，因为有了 GC root 之后，需要对老年代中大量存活的对象进行标记，因此比较耗时。

## 024、动手实验：线上部署系统时，如何设置垃圾回收相关参数？

### cms 并发线程计算

CMS 默认启动的垃圾回收线程的数量是（CPU 核数 + 3）/ 4。

### Concurrent Mode Failure 问题

这个问题是指垃圾回收的过程中，有其他的对象从新生代进入了老年代，导致老年代内存不足，就会提示这个错误。
同时，会采用 serial old 的一个垃圾回收器进行回收，缺点是阻塞所有的工作线程直到回收完成。

### 内存碎片

CMS 有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了；

还有一个参数是“-XX: CMSFullGCsBeforeCompaction”，这个意思是执行多少次 Full GC 之后再执行一次内存碎片整理的工作，默认是 0，意思就是每次 Full GC 之后都会进行一次内存整理。

### 为啥老年代的 Full GC 要比新生代的 Minor GC 慢很多倍，一般在 10 倍以上？

因为老年代对象很多。

### 老年代 GC 的时机

- 老年代空间不足
- 新生代的全部大小大于老年代剩余空间
- 新生代的平均大小大于老年代剩余空间
- Cms 有个参数是控制老年代空间到什么比例就开始进行 GC，默认是 92%

## 025、案例实战：每日上亿请求量的电商系统，年轻代垃圾回收参化？

### 新生代垃圾回收优化之一：Survivor 空间够不够

调大点。

## 026、案例实战：每日请求上亿的电商系统，老年代的垃圾回收参何优化呢？

## 027、第 4 周作业：看看你们的线上系统是怎么设置的 JVM 垃圾回置的合理吗？

## 028、第 4 周答疑：本周问题统一答疑

## 029、大厂面试题：最新的 G 1 垃圾回收器的工作原理，你能聊聊吗

### 1、ParNew + CMS 的组合让我们有哪些痛点？

Stop the World，这个是大家最痛的一个点！

### 2、G 1 垃圾回收器

这个回收器一个顶俩，可以同时回收新生代和老年代。
前三个阶段和 cms 一模一样，后一个阶段是筛选标记，然后混合回收，新老两代一起回收。

G 1 有一个参数，是“-XX: InitiatingHeapOccupancyPercent”，他的默认值是 45%

意思就是说，如果老年代占据了堆内存的 45%的 Region 的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。

### 3、G 1 是如何做到对垃圾回收导致的系统停顿可控的？

特点：除以 2048 得到一堆 region，然后每个 region 可以得知当前垃圾对象的大小和清理时间，就能达到在最短时间回收最多对象，也就是回收价值最大的对象来控制一个预期的 stw 的时间。

### 4、Region 可能属于新生代也可能属于老年代

同时都有。如果遇到大对象，那么大对象可以横跨几个连续的 region，同时呢也有 Eden 和 survivor 的说法。

## 030、G 1 分代回收原理深度图解：为什么回收性能比传统 GC 更好

其实新生代和老年代几乎和之前 cms 是一模一样的。

回收性能好是因为能够回收价值更大的对象。

## 031、动手实验：线上系统部署如果采用 G 1 垃圾回收器，应该如何设置参数

### 混合回收

G 1 有一个参数，是“-XX: InitiatingHeapOccupancyPercent”，他的默认值是 45%

意思就是说，如果老年代占据了堆内存的 45%的 Region 的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。

最后一个阶段，就是“混合回收“阶段，这个阶段会计算老年代中每个 Region 中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。

但是最后一个阶段混合回收的时候，其实会停止所有程序运行，所以说 G 1 是允许执行多次混合回收。

比如先停止工作，执行一次混合回收回收掉一些 Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些 Region。

有一些参数可以控制这个，比如“-XX: G 1 MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是 8 次

还有一个参数，就是“-XX: G 1 HeapWastePercent”，默认值是 5%

他的意思就是说，在混合回收的时候，对 Region 回收都是基于复制算法进行的，都是把要回收的 Region 里的存活对象放入其他 Region，然后这个 Region 中的垃圾对象全部清理掉。

还有一个参数，“-XX: G 1 MixedGCLiveThresholdPercent”，他的默认值是 85%，意思就是确定要回收的 Region 的时候，必须是存活对象低于 85%的 Region 才可以进行回收。

## 032、案例实战：百万级用户的在线教育平台，如何基于 G 1 垃圾回收器优化性能（上）？

计算产生的对象——高峰期大量的互动操作。

## 033、案例实战：百万级用户的在线教育平台，如何基于 G 1 垃圾回收器优化性能（下）？

### 新生代占用 region 的 5%

计算有多少 region，每个 region 的大小，得知新生代的大小。

“-XX: G 1 MaxNewSizePercent”参数限定了新生代最多就是占用堆内存 60%的空间。

其实 G 1 里是很动态灵活的，他会根据你设定的 gc 停顿时间给你的新生代不停分配更多 Region。

### 新生代 gc 如何优化？

其实，垃圾回收器是一代比一代先进，内部实现机制越来越复杂，但是对我们来说优化的时候越来越简单了。

比如对于 G 1 而言，我们首先应该给整个 JVM 的堆区域足够的内存，比如我们在这里就给了 JVM 超过 5 G 的内存，其中堆内存有 4G 的内存。

接着就应该合理设置“-XX: MaxGCPauseMills”参数

如果这个参数设置的小了，那么说明每次 gc 停顿时间可能特别短，此时 G 1 一旦发现你对几十个 Region 占满了就立即触发新生代 gc，然后 gc 频率特别频繁，虽然每次 gc 时间很短。

比如说 30 秒触发一次新生代 gc，每次就停顿 30 毫秒。

如果这个参数设置大了呢？

那么可能 G 1 会允许你不停的在新生代理分配新的对象，然后积累了很多对象了，再一次性回收几百个 Region

此时可能一次 GC 停顿时间就会达到几百毫秒，但是 GC 的频率很低。比如说 30 分钟才触发一次新生代 GC，但是每次停顿 500 毫秒。

### Mixed gc 如何优化？

说完了这个新生代 gc 之后，那接下来就是 mixed gc 的优化了

对于这个 mixed gc 的触发，大家都知道是老年代在堆内存里占比超过 45%就会触发。

大家之前都很清楚了年轻代的对象进入老年代的几个条件了，要不然是新生代 gc 过后存活对象太多没法放入 Survivor 区域，要不然是对象年龄太大，要不然是动态年龄判定规则。

其中尤其关键的，就是新生代 gc 过后存活对象过多无法放入 Survivor 区域，以及动态年龄判定规则

这两个条件尤其可能让很多对象快速进入老年代，一旦老年代频繁达到占用堆内存 45%的阈值，那么就会频繁触发 mixed gc。

所以 mixed gc 本身很复杂，很多参数可以优化，但是优化 mixed gc 的核心不是优化他的参数，而是跟我们之前分析的思路一样，尽量避免对象过快进入老年代，尽量避免频繁触发 mixed gc，就可以做到根本上优化 mixed gc 了。

那么 G 1 里面跟之前的 ParNew+CMS 的组合是不同的，我们到底应该如何来优化参数呢？

其实核心的点，还是“-XX: MaxGCPauseMills”这个参数。

大家可以想一下，假设你“-XX: MaxGCPauseMills”参数设置的值很大，导致系统运行很久，新生代可能都占用了堆内存的 60%了，此时才触发新生代 gc。

那么存活下来的对象可能就会很多，此时就会导致 Survivor 区域放不下那么多的对象，就会进入老年代中。

或者是你新生代 gc 过后，存活下来的对象过多，导致进入 Survivor 区域后触发了动态年龄判定规则，达到了 Survivor 区域的 50%，也会快速导致一些对象进入老年代中。

所以这里核心还是在于调节“-XX: MaxGCPauseMills”这个参数的值，在保证他的新生代 gc 别太频繁的同时，还得考虑每次 gc 过后的存活对象有多少，避免存活对象太多快速进入老年代，频繁触发 mixed gc。

### G 1 这种垃圾回收器到底在什么场景下适用呢？

G 1 非常适合超大内存的机器，因为内存太大，如果不用 G 1，会导致新生代每次 GC 回收垃圾太多，停顿时间太长，用了 G 1 可以指定每次 GC 停顿时间，他会每次回收一部分 Region。

### 有了 G 1 以后，是不是还有一些场景采用“ParNew+CMS”垃圾回收器也可以呢？

1、G 1 压缩内存空间会比较有优势，适合会产生大量碎片的应用；

2、G 1 能够可预期的 GC 停顿时间，对高并发应用更有优势

3、其他垃圾收集器对大内存回收耗时较长，G 1 对内存分成多块区域，能够根据预期停顿时间选择性的对垃圾多的区域进行回收，适用多核、jvm 内存占用大的应用

4、parNew+cms 回收器比较适用内存小，对象能够在新生代中存活周期短的应用

## 034、第一阶段复习：当你开发完一个系统准备部署上线时，如何配置参数？

## 035、第 5 周答疑：本周问题答疑，上周作业点评

## 036、糟糕！运行着的线上系统突然卡死无法访问，万恶的 JVM GC

一旦年轻代塞满之后，在进行垃圾回收的时候，这个期间都必须停止系统程序的运行！这个就是基于 JVM 运行的系统最害怕的问题：系统卡顿问题！

### 如何解决这种几十 G 的大内存机器的新生代 GC 过慢的问题呢？

针对 G 1 垃圾回收器，可以设置一个期望的每次 GC 的停顿时间，比如我们可以设置一个 20ms。

那么 G 1 基于他的 Region 内存划分原理，就可以在运行一段时间之后，比如就针对 2 G 内存的 Region 进行垃圾回收，此时就仅仅停顿 20 ms，然后回收掉 2 G 的内存空间，腾出来了部分内存，接着还可以继续让系统运行。

G 1 天生就适合这种大内存机器的 JVM 运行，可以完美解决大内存垃圾回收时间过长的问题。

## 037、大厂面试题：解释一下什么是 Young GC 和 Full GC？

## 038、大厂面试题：Young GC 和 Full GC 分别在什么情况下会发生

1. 新生代内存不足
2. 平均大小、老年代空间不足、老年代到达回收的比例
   %% %%

---

### 永久代满了之后怎么办？

full GC。

## 039、案例实战：每秒 10 万并发的 BI 系统是如何频繁发生 Young GC

问题原因：实时数据报表加载数据过多，用户打开过多。

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312242338846.png)

解决：

- 提升机器配置：运用大内存机器
- 用 G 1 来优化大内存机器的 Young GC 性能

## 040、案例实战：每日百亿数据量的实时分析引擎，为啥频繁发生 full GC

1 亿数据量级下的系统部署 4 核 8 G 的机器，Full GC 为何频繁发生，如何优化？10 亿量级下的系统部署在 4 核 8 G 的机器上，Full GC 会发生的有多么的恐怖，如何通过提升机器配置来优化？

这个系统就是会不停的从 MySQL 数据库以及其他数据源里提取大量的数据加载到自己的 JVM 内存里来进行计算处理，如下图所示。

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312242341997.png)

## 041、第 6 周作业：打开脑洞！如果你的线上系统压力增长 100 倍，会有 GC 问题吗？

## 042、第 6 周答疑：本周问题答疑汇总！

### Cms 的痛点？

假设你有 32 G 内存，如果用 ParNew+CMS，必须等待你的内存填满了才会触发 GC，此时一 GC 就会回收几十 G 的垃圾，那么速度会很慢，可能导致你的系统停顿时间多达几十秒都有可能。

## 043、动手实验：自己动手模拟出频繁 Young GC 的场景体验一下

比如我们用以下 JVM 参数来运行代码：

-XX:NewSize=5242880 -XX:MaxNewSize=5242880 -XX:InitialHeapSize=10485760 -XX:MaxHeapSize=10485760 XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC

### 如何打印出 JVM GC 日志

加入 GC 日志的打印选型，如下所示：

-XX:+PrintGCDetils：打印详细的 gc 日志

-XX:+PrintGCTimeStamps：这个参数可以打印出来每次 GC 发生的时间

-Xloggc: gc. Log：这个参数可以设置将 gc 日志写入一个磁盘文件

### 流程

就是设置在内存中放置多个数组，然后失去引用，最后再创建一个大的数组，触发 young GC。

## 044、高级工程师的硬核技能：JVM 的 Young GC 日志应该怎么看

## 045、动手实验：自己动手模拟出对象进入老年代的场景体验一下

上面的例子调大老年代，观察进入老年代。

## 046、动手实验：自己动手模拟出对象进入老年代的场景体验一下

### 流程

自动十五岁

## 047、高级工程师的硬核技能：JVM 的 Full GC 日志应该怎么看？

讲解了一个触发老年代 GC 的案例，就是年轻代存活的对象太多放不下老年代了，此时就会触发 CMS 的 Full GC，大家可以清晰的看到全过程。

## 048、第 7 周作业：自己尝试着分析一把你们线上系统的 JVM GC 日

## 049、第 7 周答疑：本周问题答疑汇总

## 050、动手实验：使用 jstat 摸清线上系统的 JVM 运行状况

### Jstat

他可以轻易的让你看到当前运行中的系统，他的 JVM 内的 Eden、Survivor、老年代的内存使用情况，还有 Young GC 和 Full gC 的执行次数以及耗时。

```shell
Jstat -gc PID
```

### jps

生产机器 linux 上，找出你们的 Java 进程的 PID，这个大家自行百度一下即可，用 jps 命令就可以看到。

### 思路

Jstat 工具使用的小技巧，先明确一下，我们分析线上的 JVM 进程，最想要知道的信息有哪些？

包括如下：新生代对象增长的速率，Young GC 的触发频率，Young GC 的耗时，每次 Young GC 后有多少对象是存活下来的，每次 Young GC 过后有多少对象进入了老年代，老年代对象增长的速率，Full GC 的触发频率，Full GC 的耗时。

### 新生代对象增长的速率

要分析这东西，你只要在线上 linux 机器上运行如下命令：

```shell
jstat -gc PID 1000 10
```

这行命令，他的意思就是每隔 1 秒钟更新出来最新的一行 jstat 统计信息，一共执行 10 次 jstat 统计

通过这个命令，你可以非常灵活的对线上机器通过固定频率输出统计信息，观察每隔一段时间的 jvm 中的 Eden 区对象占用变化。

### 思考题

今天交给大家一个练习题，就是在自己线上负责的系统使用 jstat 命令，按照上述我们介绍的思路，把以下 jvm 运行情况全部摸出来：

> 新生代对象增长的速率
> Young GC 的触发频率
> Young GC 的耗时每次
> Young GC 后有多少对象是存活下来的每次
> Young GC 过后有多少对象进入了老年代
> 老年代对象增长的速率
> Full GC 的触发频率
> Full GC 的耗时

## 051、动手实验：使用 jmap 和 jhat 摸清线上系统的对象分布

先看一个命令：jmap -heap PID

这个命令可以打印出来一系列的信息，我们就不长篇大论的粘贴出来具体的信息了，因为内容篇幅太大了，其实也没太大意义，因为里面的东西大家自己看字面意思都能看懂的。我们就简单给大家说一下这里会打印出来什么东西。

大致来说，这个信息会打印出来堆内存相关的一些参数设置，然后就是当前堆内存里的一些基本各个区域的情况

比如 Eden 区总容量、已经使用的容量、剩余的空间容量，两个 Survivor 区的总容量、已经使用的容量和剩余的空间容量，老年代的总容量、已经使用的容量和剩余的容量。

---

用 jmap 命令生成一个堆内存快照放到一个文件里去，用如下的命令即可：

Jmap -dump: live, format=b, file=dump. Hprof PID

这个命令会在当前目录下生成一个 dump. Hrpof 文件，这里是二进制的格式，你不能直接打开看的，他把这一时刻 JVM 堆内存里所有对象的快照放到文件里去了，供你后续去分析。

---

使用 jhat 去分析堆快照了，jhat 内置了 web 服务器，他会支持你通过浏览器来以图形化的方式分析堆转储快照

使用如下命令即可启动 jhat 服务器，还可以指定自己想要的 http 端口号，默认是 7000 端口号：

Jhat dump. Hprof -port 7000

接着你就在浏览器上访问当前这台机器的 7000 端口号，就可以通过图形化的方式去分析堆内存里的对象分布情况了。

---

## 052、从测试到上线：如何分析 JVM 运行状况及合理优化？

优化思路其实简单来说就一句话：

尽量让每次 Young GC 后的存活对象小于 Survivor 区域的 50%，都留存在年轻代里。

尽量别让对象进入老年代。

尽量减少 Full GC 的频率，避免频繁 Full GC 对 JVM 性能的影响。

## 053、案例实战：每秒 10 万并发的 BI 系统，如何定位和解决频繁 Young Gc 问题？

描述实时报表的排查过程。

## 054、案例实战：每日百亿数据量的实时分析引擎，如何定位和解决 GC 问题？

他最大的问题就是每次 Young GC 过后存活对象太多了，导致频繁进入老年代，频繁触发 Full GC。

只需要调大年轻代的内存空间，增加 Survivor 的内存即可。

## 055、第 8 周作业

思考题，结合你们系统的业务来分析，遇到频繁 GC 该怎么处理？

## 056、第 8 周答疑：本周问题答疑汇总

## 057、案例实战：每秒十万 QPS 的社交 APP 如何优化 GC 性能提升

QPS 是什么，其实英文全称就是“Query Per Second”，也就是每秒钟的查询数量，大致可以理解为是 APP 每秒钟的访问数量。

-XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=5

两个参数的含义，就是在 5 次 Full GC 之后会触发一次 Compaction 操作，也就是压缩操作

在降低了 Full GC 频率之后，务必设置如下参数“-XX:+UseCMSCompactAtFullCollection XX:CMSFullGCsBeforeCompaction=0”，每次 Full GC 后都整理一下内存碎片。

## 058、案例实战：垂直电商 APP 后台系统，如何对 Full GC 进行深度优化

所以当时这个垂直电商 APP 的各个系统通过 jstat 分析 JVM GC 之后发现，基本上高峰期的时候，Full GC 每小时都会发生好几次。

问题原因：新生代内存过小，会导致 Survivor 区域内存过小，同时 Eden 区域也很小。就是使用默认配置。

## 059、案例实战：新手工程师不合理设置 JVM 参数，是如何导致频繁 Full GC 的？

新手工程师不知道从哪里扒出来了 SoftRefLRUPolicyMSPerMB 这个 JVM 启动参数，他直接把这个参数设置为 0 了。

他想的是，一旦这个参数设置为 0，任何软引用对象就可以尽快释放掉，不用留存，尽量给内存释放空间出来，这样不就可以提高内存利用效率了么？

真是想的很傻很天真。

实际上一旦这个参数设置为 0 之后，直接导致 clock - timestamp <= freespace \* SoftRefLRUPolicyMSPerMB 这个公式的右半边是 0，就导致所有的软引用对象，比如 JVM 生成的那些奇怪的 Class 对象，刚创建出来就可能被一次 Young GC 给带着立马回收掉一些。

JVM 好不容易给你弄出来 100 个奇怪的类，结果因为你瞎设置软引用的参数，导致突然一次 GC 就给你回收掉几十个类

接着 JVM 在反射代码执行的过程中，就会继续创建这种奇怪的类，在 JVM 的机制之下，会导致这种奇怪类越来越多。

也许下一次 gc 又会回收掉一些奇怪的类，但是马上 JVM 还会继续生成这种类，最终就会导致 Metaspace 区域被放满了，一旦 Metaspace 区域被占满了，就会触发 Full GC，然后回收掉很多类，接着再次重复上述循环。

解决方案很简单。在有大量反射代码的场景下，大家只要把-XX:SoftRefLRUPolicyMSPerMB=0 这个参数设置大一些即可，千万别让一些新手同学设置为 0，可以设置个 1000，2000，3000，或者 5000 毫秒，都可以。

提高这个数值，就是让反射过程中 JVM 自动创建的软引用的一些类的 Class 对象不要被随便回收，当时我们优化这个参数之后，就可以看到系统稳定运行了。

## 060、案例实战：一次线上系统每天数十次 Full GC 导致频繁卡死的优化实战

而且这里有一个非常关键的参数，那就是“-XX: CMSInitiatingOccupancyFraction”参数设置为了 68。

那么老年代里到底为什么有那么多对象呢？

一定是系统运行的时候，每隔一段时间就会突然产生几百 MB 的大对象，直接进入老年代，不会走年轻代的 Eden 区域。

问题原因：没有 where 条件，就代表这个 SQL 可能会把表中几十万条数据直接全部查出来！

### 解决方法：

第一步，让开发同学解决代码中的 bug，避免一些极端情况下 SQL 语句里不拼接 where 条件，务必要拼接上 where 条件，不允许查询表中全部数据。彻底解决那个时不时有几百 MB 对象进入老年代的问题。

第二步，年轻代明显过小，Survivor 区域空间不够，因为每次 Young GC 后存活对象在几十 MB 左右，如果 Survivor 就 70 MB 很容易触发动态年龄判定，让对象进入老年代中。

## 061、案例实战：电商大促活动下，严重 Full GC 导致系统直接卡死的优化实战

为什么每秒都有一次 Full GC？

这个“System.Gc ()”可不能随便瞎写，他每次执行都会指挥 JVM 去尝试执行一次 Full GC，连带年轻代、老年代、永久代都会去回收。

他是这么考虑的，大家可以看看他当时的思路：他在代码里经常会一下子加载出来一大批数据，一旦请求处理完毕之后，他就觉得，一大批数据就废弃不用了，占据内存太多了，完全可以主动用“System.Gc ()”代码触发一次 GC，把他们回收掉！

结果呢，平时系统运行时，访问量很低，基本还不会出大乱子！但是在大促活动的时候，访问量一高，立马由“System.Gc ()”代码频繁触发了 Full GC，导致了这个系统直接被卡死了！

所以，针对这个问题，一方面大家平时写代码的时候，不要自己使用“System.Gc ()”去随便触发 GC，一方面可以在 JVM 参数中加入这个参数：-XX:+DisableExplicitGC。这个参数的意思就是禁止显式执行 GC，不允许你来通过代码触发 GC。

所以推荐大家将“-XX:+DisableExplicitGC”参数加入到自己的系统的 JVM 参数中，或者是加入到公司的 JVM 参数模板中去。避免有的开发工程师好心办坏事，代码中频繁触发 GC 就不好了。

## 062、第 9 周作业

## 063、第 9 周答疑以及学员思考题总结汇总

## 064、案例实战：一次线上大促营销活动导致的内存泄漏和 Full GC 优化

大促活动开始之后，直接导致线上一个系统的 CPU 使用率飙升，而且因为 CPU 使用率太高，导致系统几乎陷入卡死的状态，无法处理任何请求！在重启系统之后，会好一段时间，但是很快又立马发现机器的 CPU 使用率飙升，继续导致系统卡死！

### 初步排查 CPU 负载过高的原因

第一个场景，是你自己在系统里创建了大量的线程，这些线程同时并发运行，而且工作负载都很重，过多的线程同时并发运行就会导致你的机器 CPU 负载过高。

第二个场景，就是你的机器上运行的 JVM 在执行频繁的 Full GC，Full GC 是非常耗费 CPU 资源的，他是一个非常重负载的过程

### 考虑最后一个原因：老年代里是不是驻留了大量的对象给塞满了？

这个时候直接会看到某种自己系统创建的对象占用量过大，这种对象的实例多达数十万个，占用了老年代一大半的内存空间。

接着当然是找开发工程师去排查这个系统的代码问题了，为什么会创建那么多的对象，而且始终回收不掉？

这就是典型的内存泄漏！即系统创建了大量的对象占用了内存，其实很多对象是不需要使用的，而且还无法回收掉。

后来找到了一个原因，是在系统里做了一个 JVM 本地的缓存，把很多数据都加载到内存里去缓存起来，然后提供查询服务的时候直接从本地内存走。

但是因为没有限制本地缓存的大小，并且没有使用 LRU 之类的算法定期淘汰一些缓存里的数据，导致缓存在内存里的对象越来越多，进而造成了内存泄漏。

解决问题很简单，只要使用类似 EHCache 之类的缓存框架就可以了，他会固定最多缓存多少个对象，定期淘汰删除掉一些不怎么访问的缓存，以便于新的数据可以进入缓存中。

## 065、案例实战：百万级数据误处理导致的频繁 Full GC 问题优化

系统升级之后代码加入了 String.Split ()操作，瞬间导致内存使用量暴增 N 倍，引发了上面说的每分钟一次 Young GC，两分钟一次 Full GC，根本原因就在于这行代码的引入。

后来紧急对这段代码逻辑进行了优化，避免对几十万条数据每一条都执行 String.Split ()这行代码让内存使用量暴增 N 倍，然后再对那暴增 N 倍的字符串进行处理。

就当时而言，其实 String.Split ()这个代码逻辑是可用可不用的，所以直接去除就行了。

但是如果从根本而言，说白了，还是这种大数据量处理的系统，一次性加载过多数据到内存里来了，所以后续对代码还是做了很多的优化

## 066、阶段性复习：JVM 运行原理和 GC 原理你真的搞懂了吗？

### 对象进入老年代

一个对象在年轻代里躲过 15 次垃圾回收，年龄太大了，寿终正寝，进入老年代

对象太大了，超过了一定的阈值，直接进入老年代，不走年轻代

一次 Young GC 过后存活对象太多了，导致 Survivor 区域放不下了，这批对象会进入老年代

可能几次 Young GC 过后，Surviovr 区域中的对象占用了超过 50%的内存，此时会判断如果年龄 1+年龄 2+年龄 N 的对象总和超过了 Survivor 区域的 50%，此时年龄 N 以及之上的对象都进入老年代，这是动态年龄判定规则

## 067、阶段性复习：JVM 性能优化到底该怎么做？

### 频繁 Full GC 的原因：

系统承载高并发请求，或者处理数据量过大，导致 Young GC 很频繁，而且每次 Young GC 过后存活对象太多，内存分配不合理， Survivor 区域过小，导致对象频繁进入老年代，频繁触发 Full GC。

系统一次性加载过多数据进内存，搞出来很多大对象，导致频繁有大对象进入老年代，必然频繁触发 Full GC

系统发生了内存泄漏，莫名其妙创建大量的对象，始终无法回收，一直占用在老年代里，必然频繁触发 Full GC

Metaspace（永久代）因为加载类过多触发 Full GC

误调用 System.Gc ()触发 Full GC

## 068、如何为你的面试准备自己负责的系统中的 JVM 优化案例？

所以你在这里应该思考的一个问题，就是你负责的系统，假设数据量和访问量暴增 10 倍，或者 100 倍，此时会不会出现频繁 Full GC 的问题？ 利用学习过的知识去倒推一下，其实很可能的，在有限的机器资源下，一旦压力增长，很可能因为内存分配不合理，导致频繁 Full GC 的！ 上面我们说过好几种频繁 Full GC 的触发条件，你是不是都可以放在自己的系统里去思考一下，自己的系统有没有可能会发生上述几种场景下的频繁 Full GC？

## 069、关于作业的说明

## 070、第 10 周答疑汇总

## 071、Java 程序员的梦魇：线上系统突然挂掉，可怕的 OOM 内存溢出

学习如何监控、定位、排查、分析和解决 JVM OOM 的问题

## 072、大厂面试题：什么是内存溢出？在哪些区域会发生内存溢出

分析一下 Metaspace、 Java 虚拟机栈和堆内存这几块内存区域到底在什么情况下会发生内存溢出。

## 073、Metaspace 区域是如何因为类太多而发生内存溢出的？

如下两个参数就是用来设置 Metaspace 区域大小的：

-XX:MetaspaceSize=512 m

-XX:MaxMetaspaceSize=512 m

---

平心而论，Metaspace 这块区域一般很少发生内存溢出，如果发生内存溢出一般都是因为两个原因：

第一种原因，很多工程师他不懂 JVM 的运行原理，在上线系统的时候对 Metaspace 区域直接用默认的参数，即根本不设置其大小。这会导致默认的 Metaspace 区域可能才几十 MB 而已，此时对于一个稍微大型一点的系统，因为他自己有很多类，还依赖了很多外部的 jar 包有有很多的类，几十 MB 的 Metaspace 很容易就不够了

第二种原因，就是很多人写系统的时候会用 cglib 之类的技术动态生成一些类，一旦代码中没有控制好，导致你生成的类过于多的时候，就很容易把 Metaspace 给塞满，进而引发内存溢出

## 074、无限制的调用方法是如何让线程的栈内存溢出的？

走一个递归方法调用。不停的让线程调用方法，不停的往栈里放入栈桢，此时终有一个时刻，大量的栈桢会消耗完毕这个 1 MB 的线程栈内存，最终就会导致出现栈内存溢出的情况。

## 075、对象太多了！堆内存实在是放不下，只能内存溢出！

发生堆内存溢出的原因其实总结下来，就一句话：

有限的内存中放了过多的对象，而且大多数都是存活的，此时即使 GC 过后还是大部分都存活，所以要继续放入更多对象已经不可能了，此时只能引发内存溢出问题。

---

所以一般来说发生内存溢出有两种主要的场景：

系统承载高并发请求，因为请求量过大，导致大量对象都是存活的，所以要继续放入新的对象实在是不行了，此时就会引发 OOM 系统崩溃

系统有内存泄漏的问题，就是莫名其妙弄了很多的对象，结果对象都是存活的，没有及时取消对他们的引用，导致触发 GC 还是无法回收，此时只能引发内存溢出，因为内存实在放不下更多对象了

因此总结起来，一般引发 OOM，要不然是系统负载过高，要不然就是有内存泄漏的问题

## 076、动手实验：自己模拟出 JVM Metaspace 内存溢出的场景体

一旦我们程序中拼命的生成大量的类，而且这些类还不能被回收，那么必然会最终导致 Metaspace 区域被占满，进而导致 Metaspace 内存溢出了。

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312250024831.png)

限制他的 Metaspace 区域比较小一点，如下所示，我们把这个程序的 JVM 中的 Metaspace 区域设置为仅仅 10m：

-XX:MetaspaceSize=10 m -XX:MaxMetaspaceSize=10 m

## 077、动手实验：自己模拟出 JVM 栈内存溢出的场景体验一下！

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312250025138.png)

需要设置这个程序的 JVM 参数如下：-XX:ThreadStackSize=1 m，通过这个参数设置 JVM 的栈内存为 1MB。

## 078、动手实验：自己模拟出 JVM 堆内存溢出的场景体验一下！

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312250026241.png)

用下面的 JVM 参数来运行一下代码：-Xms 10 m -Xmx 10 m，我们限制了堆内存大小总共就只有 10 m，这样可以尽快触发堆内存的溢出。

## 079、案例实战：一个超大数据量处理系统是如何不堪重负 OOM

刚开始负责这块的工程师选择了一个思考欠佳的技术方案。一旦发现 Kafka 故障，就会将数据都留存在内存里，不停的重试，直到 Kafka 恢复才可以。最终无法释放的内存最终导致 OOM。

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312250026636.png)

当时就临时直接取消了 Kafka 故障下的重试机制，一旦 Kafka 故障，直接丢弃掉本地计算结果，允许释放大量数据占用的内存。后续的话，将这个机制优化为一旦 Kafka 故障，则计算结果写本地磁盘，允许内存中的数据被回收。

## 080、案例实战：两个新手工程师误写代码是如何导致 OOM 的？

### 一个无限循环调用

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312250028937.png)

### 没有缓存的动态代理

这个框架直接导致瞬间创建了一大堆的类，塞满了 Metaspace 区域无法回收，进而导致 Metaspace 区域直接内存溢出，系统也崩溃了。
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312250029046.png)

## 081、如何对对线上系统的 OOM 异常进行监控和报警！

公司最好是应该有一种监控平台，比如 Zabbix、Open-Falcon 之类的监控平台。

如果有监控平台的话，就可以接入系统异常的一些监控和报警，你可以设置一旦系统出现了 OOM 异常，就发送报警给对应的开发人员，通过邮件、短信或者钉钉之类的 IM 工具。

这个是中大型公司里最常用的一种方案了，一般来说我们都对线上系统有以下几个层面的监控：

机器（CPU、磁盘、内存、网络）资源的负载情况，JVM 的 GC 频率和内存使用率，系统自身的业务指标，系统的异常报错。

这些东西都会基于监控平台接入对应的监控项，同时设定关键监控项的一些报警阈值。

今天给大家总结了一下发现 OOM 的两种办法：一种是通过监控系统，一种是被动等待系统挂掉后客服来通知你。

## 082、一个关键问题：如何在 JVM 内存溢出的时候自动 dump 内存

在 JVM 的启动参数中加入如下的一些参数：

-XX:+HeapDumpOnOutOfMemoryError

-XX:HeapDumpPath=/usr/local/app/oom

第一个参数意思是在 OOM 的时候自动 dump 内存快照出来，第二个参数是说把内存快照放到哪儿去

只要你加入了这两个参数，在 JVM OOM 崩溃的时候，无论你是立马主动收到一个报警，还是被动让客服通知了你，立马就可以去找 OOM 时候的内存快照了。

## 083、动手实验：Metaspace 区域内存溢出的时候，应该如何解决

类里搞出来了一大堆的动态生成的类，所以填满了 Metaspace 区域。

所以此时直接去代码里排查动态生成类的代码即可。

解决这个问题的办法也很简单，直接对 Enhancer 做一个缓存，只有一个，不要无限制的去生成类就可以了。

## 084、动手实验：JVM 栈内存溢出的时候，应该如何解决？

实际上我们会在这里看到大段大段的如上所示的异常，也就是说，他会直接告诉你这个栈内存溢出的问题，是因为你拼命的调用 Demo 2 这个类的 work ()方法时发生的。

因此就栈内存溢出而言，我们定位和解决问题非常的简单，你只要把所有的异常都写入本地日志文件，那么当你发现系统崩溃了，第一步就去日志里定位一下异常信息就知道了。

## 085、动手实验：JVM 堆内存溢出的时候，应该如何解决？

### 堆内存溢出的问题如何分析和定位

其实很简单，一个是必须在 JVM 参数中加入自动导出内存快照，一个是到线上看一下日志文件里的报错，如果是堆溢出，立马用 MAT 分析内存快照。

MAT 分析的时候一些顺序和技巧，还有思路，也教给大家了，先看占用内存最多的对象是谁，然后分析那个线程的调用栈，接着就可以看到是哪个方法引发的内存溢出了。接着优化代码即可。


## 086、案例实战：每秒仅仅上百请求的系统为什么会因为 OOM 而崩溃

记得每个系统上线，务必得设置一个参数：

-XX:+HeapDumpOnOutOfMemoryError

这个参数会在系统内存溢出的时候导出来一份内存快照到我们指定的位置。

接着排查和定位内存溢出问题，主要就得依托这个自动导出来的内存快照了。


---
也就是说明明每秒才 100 个请求，怎么可能 Tomcat 的 400 个线程都处于工作状态？

到 Tomcat 的配置文件里搜索一下，发现了如下的一个配置：

Max-http-header-size: 10000000

有了，就是这个东西，导致 Tomcat 工作线程在处理请求的时候会创建 2 个数组，每个数组的大小如上面配置就是 10 MB。

---
每秒 100 个请求，每个请求处理需要 4 秒，导致 4 秒内有 400 个请求同时被 400 个线程在处理，每个线程会根据配置创建 2 个数组，每个数组是 10 MB，占满了 8 G 的内存。

RPC 调用超时的配置，惊讶的发现，负责这个系统的工程师居然将服务 RPC 调用超时时间设置为了刚好是4秒！

之所以每个请求需要处理 4 秒钟，是因为下游服务故障了，网络请求都是失败的，此时会按照设置好的 4 秒超时时间一直卡住 4 秒钟之后才会抛出 Timeout 异常，然后请求处理结束。

这就是一个请求处理需要 4 秒钟的根本原因，进而导致每秒 100 个请求的压力下，4 秒内积压 400 个请求同时在处理，导致 400 个工作线程创建了 800 个数组，每个数组 10 MB 内存，耗尽了 8 G 的内存，最终导致内存溢出！

---

最核心的问题就是那个超时时间设置的实在太长了，因此立马将超时时间改为 1 秒即可。

这样的话，每秒 100 个请求过来，也就只有 200 个数组，占据 2 G 内存，远远不会把堆内存塞满的，然后 1 秒内这 100 个请求会全部超时，请求就处理结束了。

下一秒再来 100 个请求又是新的一轮处理，不会每秒积压 100 个请求，4 秒积压 400 个请求同时处理了。

另外一个，对 Tomcat 的那个参数，max-http-header-size，可以适当调节的小一些就可以了，这样 Tomcat 工作线程自身为请求创建的数组，不会占据太大的内存空间的。


## 087、案例实战：Jetty 服务器的 NIO 机制是如何导致堆外内存溢

Direct buffer memory

这个东西其实就是堆外内存，顾名思义，他是 JVM 堆内存之外的一块内存空间，这块内存空间不是 JVM 管理的，因此之前我们也没怎么多讲这块内容，但是你的 Java 代码确实是可以在 JVM 堆之外使用一些内存空间的。

一个是内存设置不合理，导致 DirectByteBuffer 对象一直慢慢进入老年代，导致堆外内存一直释放不掉

另外一个是设置了-XX:+DisableExplicitGC 导致 Java NIO 没法主动提醒去回收掉一些垃圾 DIrectByteBuffer 对象，同样导致堆外内存无法释放。

因此最终对这个项目做的事情就是：

一个是合理分配内存，给年轻代更多内存，让 Survivor 区域有更大的空间

另外一个就是放开-XX:+DisableExplicitGC 这个限制，让 System.Gc ()生效。

做完优化之后，DirectByteBuffer 一般就不会不断进入老年代了。只要他停留在年轻代，随着 young gc 就会正常回收释放堆外内存了。

## 088、案例实战：一次微服务架构下的 RPC 调用引发的 OOM 故障
此时把 OOM 的时候自动导出的内存快照打开分析，发现占用内存最大的是一个超大的 byte[]数组！

最终的问题就出在这里了，当时服务 A 的工程师修改了很多 Request 类的字段，结果没告诉服务 B 的工程师。所以服务 A 上线之后，序列化的 Request 对象到服务 B 那里是没办法反序列化的，此时服务 B 就会直接开辟一个默认4GB 的 byte[]数组。


其实解决这个问题的办法很简单，把 RPC 框架中那个数组的默认值从 4 GB 调整为 4 MB 即可，一般请求都不会超过 4 MB，不需要开辟那么大的数组。


## 089、案例实战：一次没有 WHERE 条件的 SQL 语句引发的 OOM 
分析内存快照，说白了，无非就是找到占用内存最大的对象，然后就是找到谁在引用这个对象，是哪个线程在引用，接着找到创建这些对象的相关代码和方法，然后你就可以一头扎到对应的源码里去分析问题了。

我们当时追踪到这里，发现某个 Tomcat 的工作线程创建了一大堆的 java. Lang. HashMap，那么这些 java. Lang. HashMap 中是什么？ 我们发现全都是各种从数据库里查出来的字段，你只要展开那个 HashMap 就能看到你出来放入内存的所有数据。

此时就直接对那个方法对应的 SQL 语句进行修改即可，要求他必须每次都带上 WHERE 条件。


## 090、本周思考题
结合自己公司系统的业务来分析，遇到内存溢出该怎么处理？ 如果你的线上系统数据量猛增 100 倍，会出现 OOM 问题吗？ 对自己的线上系统，导出一份内存快照分析一下！


## 091、本周答疑问题汇总！

## 092、案例实战：每天 10 亿数据的日志分析系统的 OOM 问题排查

因为有大量的 XXClass.Process ()方法的递归执行，每个 XXClass.Process ()中都创建了大量的 char 数组！

问题所在了，刚开始都是年轻代的 Eden 区在涨，接着 YGC 从 36 到 37，就是发生了一次 YGC，接着 Old 区直接从占比 69%到99%。OOM 的排查方法去分析，发现主要是内存太小导致的问题

优化第一步：增加堆内存大小；
优化第二步：改写代码；每次调用都切割一次日志，生成大量的 char[]数组。


## 093、案例实战：一次服务类加载器过多引发的 OOM 问题排查


经常一段时间内无法访问这个服务的接口，但是过了一会儿又可以访问了！
这个服务的进程对 CPU 耗费很少，仅仅耗费了 1%的 CPU 资源，但是他耗费了 50%以上的内存资源。
居然是一大堆的 ClassLoader 也就是类加载器，有几千个，而且这些类加载器加载了的东西，都是大量的 byte[]数组，所有这些一共占用了超过 50%的内存。
解决这个问题非常的简单，直接就是修改代码，避免重复创建几千个自定义类加载器，避免重复加载大量的数据到内存里来，就可以了。

## 094、案例实战：一个数据同步系统频繁 OOM 内存溢出的排查
既然每次重启过后都会在一段时间以后出现内存溢出的问题，说明肯定是每次重启过后，内存都会不断的上涨。
一般要高到 JVM 出现内存溢出，通常就是两种情况，要不然是并发太高，瞬间大量并发创建过多的对象，导致系统直接崩溃了。要不就是有内存泄漏之类的问题，就是很多对象都赖在内存里，无论你如何 GC 就是回收不掉。

当时这个写代码的工程师，直接就是每次消费几百条数据出来给做成一个 List，然后把这个 List 放入到队列里去！ 最后就搞成了这种情况：比如一个队列有 1000 个元素，每个元素都是一个 List，每个 List 里都有几百条数据！

把上述内存队列的使用修改了一下，做成了定长的阻塞队列。比如最多 1024 个元素，然后每次从 Kafka 消费出来数据，一条一条数据写入队列，而不是做成一个 List 放入队列作为一个元素。



## 095、总复习：线上系统的 JVM 参数优化、GC 问题定位排查

第一个是 JVM 运行我们写好的系统最根本的工作原理，包括： 内存各个部分的划分代码在执行的过程中，各个内存区域是如何配合协调工作的对象是如何分配的 GC 如何触发 GC 执行的原理是什么常见的用于控制 JVM 工作行为的一些核心参数都有哪些第二个是对于一个写好的系统，我们应该如何通过预估的方法给他设置一些相对合理的 JVM 参数，然后在测试的时候如何合理的优化调整 JVM 的参数另外在线上部署的系统如何对 JVM 进行监控，如何对线上出现 GC 性能问题的 JVM 进行合理的优化。除此以外，我们提供了大量的来自生产一线的实战案例，向大家展示了各种奇怪场景下的 JVM GC 问题，通过案例来给大家展示解决这类问题的思路和方法。第三个是对于一个生产运行的系统，如果出现了 OOM 内存溢出问题，我们应该采用一种什么样的方式来进行分析、定位和解决？ 同样我们也提供了大量的一线生产案例，给大家展示了各种千奇百怪的 OOM 问题的场景，同时展示了对这类问题的分析、定位和解决的思路。我们相信，如果大家认认真真的学习完这个专栏，首先对 JVM 的运行原理一定有了一个较为深刻的理解同时对自己负责的线上系统，能给出比较合理的 JVM 参数的设置另外，对线上系统可能发生的频繁 GC 和 OOM 两种问题，都能有一定的经验和能力，去采用正确的思路分析解决生产问题。


## 096、专栏彩蛋：面试中如何展现自己的 JVM 实战经验？
第一个是你们生产环境的系统的 JVM 参数怎么设置的？

为什么要这么设置？

还有一个是你在生产环境中的 JVM 优化经验可以聊聊？ 

另外一个是说说你在生产环境解决过的 JVM OOM 问题？

---

如果没有，那么想一下，假设你的系统压力增长 10 倍或者 100 倍，会不会让你的系统产生案例中的问题？ 然后你就可以拿着这些思考出来的东西到面试里去说了，可以结合你们自己的系统的情况，说说系统发生哪些生产问题？如何优化和解决的？这么做背后的本质是什么？为什么要这么做？


