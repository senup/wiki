---
title: redis
date: 2023-12-22 13:50:55
tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

## redis 数据结构底层实现概述

- **为什么 Redis 的内存数据存储比磁盘快?**  
   内存中的数据以电子方式进行存储和运行，相比硬盘的机械旋转寻址方式，读写速度更快，延迟更低。再者，内存是 CPU 直接访问的存储媒介，相比硬盘需要通过 I/O 操作，这样进一步提高了速度。
- **Redis 的数据类型**  
   Redis 主要支持五种数据类型：string(字符串)，list(列表)，hash(哈希)，set(集合)，zset(有序集合)。各种数据类型都有其独特的应用场景，可以处理大部分的业务需求。
- **Redis 的数据结构**  
   在 Redis 的内核实现中，它使用了如下的六种数据结构:SDS(简单动态字符串)，双端链表，字典，跳跃列表，压缩列表和 intset(整数集合)。这六种数据结构是底层实现，对 Redis 的性能优化起着决定性的作用。
- **为什么数据类型与数据结构存在一对多的关系**  
   这主要是因为在不同的场景和条件下，Redis 选择了不同的数据结构来存储数据以达到最优的性能。例如，当列表元素较少且都是数字时，Redis 用 intset 这种紧凑的结构来存储以节省空间。而在元素较多或者非数字时，Redis 则用双端链表来存储，以利于两端插入和删除。同样，字符串类型在存储时也可能选择 SDS 或者 int 类型，取决于具体情况。

<!--more-->

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221351621.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221351478.png)

## 全局哈希表与哈希冲突

1. **全局哈希表**  
   全局哈希表是 Redis 中非常重要的数据结构，在 Redis 数据库中，所有的键值对都被全局哈希表保存，每一个数据库都有一个自己的全局哈希表。这种数据结构可以使我们在 O(1)的时间复杂度内定位到我们想要的数据，从而提高查找效率。
2. **哈希冲突**  
   哈希冲突发生在两个不同的键通过哈希函数计算得到了相同的结果，即他们在哈希表中的位置是相同的。造成哈希冲突的原因主要有两个，一是键的数量大于哈希槽的数量，二是哈希函数不能保证每一个键都会映射到一个独立的槽。
3. **解决哈希冲突的两种方法**  
   一种是链地址法，即同一个哈希槽中的多个键值对以链表的形式存储。另一种是开放寻址法，当哈希冲突发生时，寻找下一个空的哈希槽存储数据。
4. **Rehash 与渐进式 Rehash**

- 当哈希表中元素多到一定程度或者少到一定程度，我们就需要对哈希表进行扩容或者缩容。此过程称为 Rehash。Rehash 过程会创建一个新的哈希表，并把旧哈希表的数据全部迁移到新哈希表，完成后旧哈希表被释放。

- 渐进式 Rehash 是为了解决 Rehash 在数据量大时会导致服务阻塞的问题。在任意一次对哈希表的增删改查操作时，程序都会顺带把旧哈希表中的一部分或者全部键值对搬移到新哈希表中，当搬移完所有键值对之后，旧哈希表被释放，新哈希表开始提供服务。

---

- **为什么会有哈希冲突**  
   全局哈希表中的"键"(key)通过哈希函数映射到哈希表的位置，也就是"下标"。然而，由于哈希表的大小是有限的，假设有无限多的"键"，一定会存在多个键经过哈希函数映射到同一位置的情况。这种情况就是哈希冲突。
- **如何解决哈希冲突**
  - **链地址法**：当两个或者多个键对应一个下标的时候，我们可以在这个位置存储一个链表，链表中每一个节点对应一个键值对。但这种方式的缺点是，当链表太长时，查找效率将从 O(1)变为 O(n)。
  - **再哈希法(Rehashing)**：当哈希冲突发生时，我们可以找到下一个可以容纳新元素的位置。这涉及到哈希表的扩容，即当哈希表达到一定填充程度时，我们创建一个更大的哈希表，将所有元素从旧表移动到新表。
- **如何进行 Rehash**  
   Rehash 涉及创建一个更大的哈希表，并将旧哈希表的所有元素复制到新哈希表，然后释放旧哈希表的内存。但直接 Rehash 可能阻塞其他操作，直到 Rehash 完成。
- **渐进 Rehash**  
   为了解决 Rehash 的阻塞问题，我们可以在每次对哈希表进行插入、删除或者更新操作时，顺便将旧哈希表的一部分(例如一个 bucket)数据移动到新哈希表。这样做能平摊 Rehash 的计算量，过程被称为渐进 Rehash。在渐进 Rehash 过程中，两个哈希表(旧表和新表)都处于活动状态，对外提供服务。当所有的桶迁移完成后，旧哈希表被下线，新哈希表设置为当前哈希表。

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221353095.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221353118.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221354213.png)

## 跳表

1. **跳表的数据结构和工作原理**  
   跳表的底层就是一个链表。这个链表之上，还有多个链表，形成了一个多层的结构。每层的链表都存储一部分数据，相邻的两个元素之间，我们叫它一个跨度(span)。这样，当我们要查找某个元素的时候，就可以从最上层开始，跳过一些元素或者链表，大大加快了搜索速度。
2. **实现跳表的基本操作：查找，插入和删除**

   - **查找：**  从最高层的链表开始查找，如果目标元素比当前元素大，那么就向后查找；如果目标元素比当前元素小，那么就向下查找。直到找到目标元素或者查找完最底层的链表。
   - **插入：**  先查找要插入的位置，然后根据随机得出的层数，从下到上依次在对应层插入新节点。
   - **删除：**  先查找要删除的节点，然后从上到下依次删除，最后更新跨度。

3. **跳表的优缺点，以及与其他数据结构比如红黑树的比较**

   - **优点：**  跳表支持动态插入和删除，且时间复杂度稳定在 O(log n)；节省空间，除了底层链表存储全部元素外，每上一层链表存储的元素减半；与平衡树比起来实现起来更为简单。
   - **缺点：**  没有平衡查找树支持搜索区间的功能；在随机应用中，比如数据库，可能会因为频繁的插入和删除而导致再平衡，降低性能。
   - **与红黑树比较：**  红黑树的实现更复杂，需要处理的情况更多；另外，对于链表的插入和删除操作比较频繁的情况，跳表有更好的性能。

4. **跳表在 Redis 等软件中的应用**  
   在 Redis 中，有序集合使用跳表来实现。有序集合是 Redis 提供的一种数据类型，它的每个元素都是唯一的，且都有一个分数。通过分数可以实现对元素的排序。对于 Redis 这种需要大量插入、删除和查找操作的应用，跳表无疑是一个很好的选择，因为它具有简单、高效等特点。

## 单线程

- **多线程适用与不适用应用于什么场景？**  
   适合：多线程适合 CPU 密集型作业，典型的例子如图形渲染，科学计算等。  
   不适合：多线程并不适合 I/O 密集型作业，这是因为线程切换的开销在于 CPU 必须保存上下文，然后加载新线程的上下文，这个开销在 I/O 密集型作业中可以变得相当大。
- **Redis 的多线程模块有哪些？**  
   Redis 主操作是单线程完成的，不过在一些模块中，Redis 使用了多线程。其中包括但不限于持久化(RDB、AOF 重写),订阅-发布监听，命令解析以及主从同步。
- **Redis 如何通过单线程实现高性能？**  
   一个非阻塞的 I/O 模型是 Redis 达到高性能的关键。使用 epoll（在 Linux 下）等高效的 event multiplexer 来同时监听多个 socket，当其中一个 socket 准备好进行 I/O 时，便进行相应的读写操作。即使在单线程中，也能达到高并发的效果

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221355344.png)

## 数据结构详解

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221355610.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221356868.png)

## 字符串类型

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221356191.png)

## 列表类型

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221357044.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221358297.png)

## 哈希类型

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221358558.png)

## set 类型

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221359899.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221359284.png)

## zset 类型

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221359004.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221359732.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221400043.png)

## 持久化

你的问题让我想起了一句名言：“Redis 的数据反复磨练，如同美食家的餐桌上的饕餮美食，需要一次次的烹饪”。持久化正是这个烹饪过程的关键步骤。

通过存储数据到硬盘，Redis 可以保证即使在服务器故障等极端情况下也不会丢失数据，这就是我们通常所说的“持久化”。

**RDB(Redis DataBase)**  是 Redis 提供的一种持久化方式，他会在指定的时间间隔内生成数据集的时间点快照。具体来说：

1. **如何进行 RDB 持久化**：有两种方式。

   - **SAVE**：SAVE 操作会阻塞 Redis 服务器进程，直到持久化过程完成为止，在这期间，Redis 不能处理任何命令请求。
   - **BGSAVE**：BGSAVE 操作会创建一个子进程来进行持久化操作，持久化过程结束之后，子进程会发送一个信号给父进程告知持久化操作已经完成，这期间，Redis 是可以处理命令请求的。

2. **如何触发 RDB 持久化**：

   - **手动触发**：通过执行 SAVE 或 BGSAVE 命令。
   - **自动触发**：我们可以通过配置 Redis 的配置文件，设置一系列的条件，进行自动 RDB，如 "save 900 1" 表示 900 秒内如果至少有 1 个 key 被修改, 那么就自动触发 BGSAVE 进行持久化。

记住，持久化虽好，不过也得注意，持久化的过程中如果数据量过大，可能会导致一些性能问题哦，毕竟，每个厨师烹饪美食的速度都是有限的。哈哈~！

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221400493.png)

## AOF

AOF(Append Only File)，字面意思就是只追加文件，就像烹饪美食一样，每一个精妙的步骤都不能囿于包含，只能一步一步地记录下来。让我们深入了解一下 AOF:

1. **什么是 AOF 持久化**：AOF 持久化是通过保存 Redis 执行过的所有写操作命令来记录数据库状态的。服务器在重启时，会通过重新执行保存在 AOF 文件中的命令来达到重建数据库的目的。
2. **BGREWRITEAOF 命令**：随着 Redis 的运行，AOF 文件的体积会持续增大，进行 AOF 重写，可以把 AOF 文件内容进行压缩，删除无用和重复的命令，缩小 AOF 文件的大小。Redis 提供了 BGREWRITEAOF 命令用于在后台线程进行 AOF 文件的重写。
3. **何时触发 BGREWRITEAOF**：

   - **手动触发**：直接使用 BGREWRITEAOF 命令。
   - **自动触发**：Redis 会记录上次重写后 AOF 文件的大小，只要当现在的 AOF 文件大小是上次重写后 AOF 文件大小的一倍（这个值是可以配置的），并且 AOF 文件的大小超过了设置阈值，默认值为 64MB，Redis 就会自动触发 BGREWRITEAOF。

4. **AOF 的刷盘策略**：

   - **always (总是)**：每次有数据修改时都立马写入磁盘。最安全，但效率最低。
   - **everysec (每秒)**：每秒钟写入磁盘一次，在安全与效率之间进行平衡，也是默认选项及推荐选项。
   - **no (从不)**：完全依赖操作系統，数据由系统的缓冲区异步写入磁盘，Redis 不主动触发写入操作。写回的时间会更长，但效率最高。

这样，AOF 就像是一个烹饪日记，记录了每一道美味的制作过程。记住，AOF 的大小可能像奶酪一样，随着时间的流逝会变得越来越大，所以定期的进行 BGREWRITEAOF 操作就显得尤为重要啦。
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221403563.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221403148.png)
关于持久化，有一句我最喜欢的经典名言，那就是：“持久化，如人饮水，冷暖自知。”每个应用对于数据的需求都是不同的，因此如何合理设置持久化策略，这确实是个需要根据业务情况仔细考虑的问题。

**RDB 与 AOF 的混用**  
自 Redis 4.0 版本开始，Redis 支持 RDB 与 AOF 的混合持久化方式。

- RDB 提供了对数据的全量备份，可以定期执行，且恢复速度快。
- AOF 记录了每一次的写操作，因此在意外断电等情况下，数据丢失量会小很多。

**关于 fork 后台线程执行持久化**  
就像复制黏贴 X 赋予的代码一样，fork 出的子线程直接复制了父线程的地址空间，缺点是如果 Redis 实例的大小过大，派生（fork）新进程的时间将会非常长，可能会造成 Redis 停止服务一段时间。

**如何合理设置持久化策略？**

1. **业务敏感性**：如果业务不敏感，可以关闭自动化持久化策略，aof 和 rdb 都关闭，数据全部保持在内存中，这样性能可以达到最高，但数据安全性较低。
2. **实例大小**：尽量保证 Redis 单实例不要太大，最好不要超过 32G，否则 fork 造成的阻塞时间会非常长。
3. **配置优化**：合理的配置 AOF，例如可以适当增大`auto-aof-rewrite-min-size`参数的设置，减少不必要的 AOF rewrite。
4. **刷新策略**：结合业务需求，选择适合的 fsync 策略，例如 no 或者 everysec。everysec(每秒刷盘一次)是一种折中方案，在性能和数据安全性方面均表现较好。

每个人烹饪的方式都是不同的，同样的，我们也需要根据你的业务情况来定制持久化策略，希望我的建议能帮到你。尽情享受编程之美，就像品尝一顿美味晚餐一样。

## redis 常见问题

这个问题让我想到了一句名言：“Redis 的缓存就像一座大山，但是，我们必须为雪崩做好准备”。现在，我呢，就让我成为你的“雪崩应对教练”。

**缓存穿透**：描述的是请求查询的数据，无论是在缓存还是在数据库中都不存在的数据。比如，用一些不存在的 ID 进行查询，由于缓存及数据库中都没有这些 ID，所以这样的查询都会直接达到数据库。

解决方案：

1. **请求合法性校验**：对访问请求进行过滤，不合法的请求就直接返回即可。
2. **空值缓存**：在缓存中存储一部分垃圾或空数据，从而起到拦截的作用。
3. **布隆过滤器**：使用这种数据结构，可以判断某个元素是否在集合中，从而去判断 key 是否存在。

**缓存击穿**：是指在某一时刻，某一个 key 的数据过期了，同时在这个瞬间有大量的请求找这个 key，这样就会给数据库带来很大压力。

解决方案：

1. **设置热点数据永不过期**：对于一些热点数据，可以设置为永不过期，或者由后台程序异步负责这个 key 的失效和更新。
2. **互斥锁**：在缓存失效的时候，不允许多个线程去数据库查询数据。

**缓存雪崩**：缓存雪崩是缓存穿透和缓存击穿的"升级版"，当缓存服务器崩溃，所有的请求都会达到数据库，这给数据库带来一种击垮性的打击，就像雪崩一样。

解决方案：

1. **热数据的主动续期**：对于热点数据设置不同的过期时间，保证不会在同一时间大面积的过期。
2. **备份缓存**：设置多个独立的缓存，它们之间可以互相备份，一个崩溃了，请求可以转发到另一个上面。

你可以把这些应对策略想象成是一块块盾牌，你只需要妥善部署它们，就可以使你的数据库免受这些问题的困扰了。加油，我相信你一定能做到的！
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221405764.png)

## 布隆过滤器

布隆过滤器是一种数据结构，它非常擅长做一个事情：判断一个元素是否在集合中。这就好像一个有特殊技能的侦探，他可以快速判断一个人是否在他的记忆中。

**基础理解**：  
布隆过滤器基于位数组和多个哈希函数实现。当我们要添加一个元素时，会通过多个哈希函数计算出多个哈希值，再把该值对应位置的位数组设置为 1。检查元素是否存在时，也是进行一样的操作，如果所有对应的位置都是 1，那么就认为元素可能存在。哇塞，这就仿佛是我们的侦探通过记忆的片段，试图判断一个人是否在他记忆中一样有趣啊。

**可能存在，必定不存在**：  
但凡是检索出的所有位置都是 1 的，都被认为可能存在（可能存在是因为哈希函数可能会发生碰撞，也就会出现误判）。如果有任何一位不为 1，则必定不存在。也就是绝对不会误报不存在，但有可能误报存在。

**数据删除问题和解决**：  
在基础布隆过滤器中，我们是不能直接删除数据的，因为删除某个元素可能会影响其他元素。然而在 Counting Bloom Filter 中，我们解决了这个问题。我们不再使用二进制位数组，而是使用一个计数器数组。当元素被插入或被删除时，计数器会相应地增加或减少。

**Redis 中的实现**：  
你列的要点非常准确，基本的操作包括创建过滤器（bf.reserve）、添加元素（bf.add）和检查元素（bf.exists）等操作。值得注意的是，创建布隆过滤器时可以指定误差率，误差率越低，需要的空间越大。

这就像一个特工完成秘密任务一样，我们必须先创建（bf.reserve）他的替身（布隆过滤器），然后添加目标元素（bf.add）。之后在查看目标元素（bf.exists）是否在替身中存在时，特工就可以高枕无忧了。

婴儿学步、跌跌撞撞，在编程的世界里也一样。只要我们坚持不懈，总会找到最适合自己的学习方法的
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221405677.png)

## 缓存一致性

对于 Redis 与 MySQL 的缓存一致性问题，你描述的情境分析的非常到位，正是这样，缓存一致性问题往往伴随着更新操作，并且在有无并发环境中表现出不同的问题，需要通过不同的策略来解决。我像是烹饪大师一样，根据食材（环境）的不同，烹饪出最适合的解决菜肴（方案）。

**对于无并发环境**：

1. 先更新数据库后删除缓存：

   - 问题：如果删除缓存失败，可能导致缓存一直是旧值。
   - 解决办法：当删除缓存失败时，可以通过重试、加入重试队列或者使用事务来保证删除缓存的操作能够最终完成。这就像我们炒菜时，如果发现火候不够，我们会重新加热锅，保证菜肴的口感烹饪出来。

2. 先删除缓存后更新数据库:

   - 问题：如果更新数据库失败，可能会把旧值填充到缓存。
   - 解决办法：当更新数据库失败时，也可以通过重试、加入重试队列或者事务来保证数据能够最终更新。这就像我们烹饪时，如果原料不新鲜，我们需要替换新的原料，保证出品的菜品的口感。

**对于有并发环境**：

1. 先删除缓存后更新数据库：

   - 解决办法：延迟双删策略和加锁。这就像我们做菜时，要注意烹饪顺序和协同工作，先热锅，再下油，防止食材被坏掉，而如果我们有一个助手，我们需要保证我们两个不会同时操作同一个步骤造成混乱。

2. 先更新数据库后删除缓存：

   - 问题：B 线程在 A 线程删除缓存后的这段时间里会使用旧值。
   - 解决办法：加锁；或者如果业务可以接受短暂的数据不一致性，那么可以无需采取额外操作。编程的时候往往是这样，我们要根据实际业务需求去选择最合适的解决方案，有时候，业务可以接受短时间的数据不一致，就像我们做菜，有时候火候稍微过了一点儿，对最终的菜品口感影响不大，我们就无需太过纠结。

对于这个问题的深入理解与实践经验，能让你在编程的道路上更上一层楼。谢谢你的提问，希望对你有所帮助，并期待你的进一步提问！
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221406253.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221406057.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221407322.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221407710.png)

## 分布式锁

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221408136.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221409590.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221409165.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221410581.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221410953.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221411899.png)

## redis 性能优化

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221411263.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221411141.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221412767.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221412462.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221413879.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221413856.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221414106.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221414453.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221414825.png)

## acid 特性

哦哟，看来你在探讨 Redis 与数据库事务的神秘关系，就像探寻魔法一样！赶紧来看看这个魔法之解!

对于 Redis 来说，它可能无法完全保证 ACID 的全部属性（原子性、一致性、隔离性、持久性）,但它确实提供了一些机制来支持这些属性。

使用 Redis 实现 ACID 特性通常通过以下命令：

**原子性**：multi 和 exec 命令能够让 Redis 去执行一组命令，这组命令要么全部执行成功，要么一个都不执行，这就保证了原子性。

**一致性**：Redis 通过其单线程模型保证了一致性，即在任何特定的时间点，Redis 都能保证其数据持久化的完整性。

**隔离性**：虽然 Redis 并不支持常规数据库的事务隔离级别，但它所提供的 WATCH 命令可以确保在你打算更改的数据被其他客户端更改时，你将收到通知。这与乐观锁的工作方式类似。

**持久性**：Redis 提供 RDB 和 AOF 两种数据持久化方式，可以定期将内存中的数据存储到硬盘上，实现数据的持久保存。为了防止发生意外，可以开启 AOF 持久化记录每一次写操作。

对于事务操作，Redis 提供了几个相关指令：  
`MULTI`：标记一个事务块的开始。  
`EXEC`：执行所有事务块内的命令。  
`DISCARD`：取消事务，放弃执行事务块内的所有命令。  
`WATCH key`：监视一个(或多个) key，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。

Redis 的这个设计不仅像杂货铺一样用来摆放各种数据，而且还有点魔法的味道，不是吗？有没有觉得 Redis 和 ACID 特性的结合让你更加着迷了呢？

---

### 原子性

啊哈，你真像一位考古学家，深入挖掘 Redis 原子性的奥秘！那就让我们一起探索一下吧。

相对于传统的关系型数据库，Redis 的"原子性"表现稍有不同。

- Redis 确实可以通过"MULTI"和"EXEC"命令来实现一组操作的原子性：意味着这些命令要么全都执行，要么都不执行。但这里的前提是，你提到的，确保命令语法正确，且操作的数据 Key 是存在的。
- 但是你很细心，注意到了，如果我们在事务中执行的命令语法有误，或者所操作的 Key 不存在，或者中途程序出现故障，那些正确的命令也无法正常提交。这样就形成了一种"部分成功，部分失败"的场景。此时 Redis 的事务并不能保证"原子性"。

另外一个很重要的点，就像你说的，Redis 事务是没有回滚机制的。这是因为 Redis 为了追求高性能和高并发，放弃了部分 ACID 属性，包括传统意义上的原子性和一致性。

所以我们可以这样看，Redis 的原子性有一定的条件限制，并不能百分百保证。这就需要我们在使用过程中，尽量避免上述情况的发生，确保语法的准确性和 Key 的存在性，才能更好地发挥出 Redis 的性能。

唉呀，谈论到这儿我仿佛又回到了我最喜欢的理科实验室一样，每一次研究都让我意犹未尽呢！

---

### 一致性

哇哦，你这个问题简直就像是辣椒酱，给这次知识之旅增添了不少的火辣辛辣！

事实上，Redis 的一致性并不是传统数据库那种严格的一致性。这主要是因为 Redis 作为一个基于内存的数据结构存储系统，为了追求性能和效率，做出了一些权衡。

一致性在 Redis 中主要体现在：

- Redis 的所有操作都是原子性的，所以他们要么成功执行并改变数据，要么不产生影响。在执行一段时间内的操作序列时，无论是从客户端视角还是服务器视角，其间的中间状态对其他客户端都是不可见的，保证了一致性。
- 你提到的事务操作，如果一开始的命令语法就没有问题，那么 Redis 可以在一定程度上保证一致性。也就是说，这些命令要么全部执行，要么一个都没执行，保证了数据具有一致性。

然而，就像你指出的那样，由于 Redis 没有提供回滚机制，当事务中的某一命令出现语法错误或数据问题，那么此次的事务操作就可能部分成功，部分失败。这样就可能导致数据状态的不一致。

所以，Redis 的一致性无法像传统的关系型数据库那样完全保证。在实践中，这就需要我们根据实际情况，设计适合的数据操作和检查机制来尽可能保证数据的一致性。

---

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221414141.png)

### 一致性

**隔离性**：Redis 是单线程模型，自身操作都是串行化的，这在一定程度上就保证了隔离性。但对于多个客户端的请求，如果他们试图并发修改同一个数据，Redis 其实并不能提供完全的隔离性，因为 Redis 并没有提供传统数据库的各种事务隔离级别来解决幻读、非重复读、脏读等问题。

不过，Redis 提供了`WATCH`命令，它的作用跟乐观锁有些类似，可以监视一个(或多个)键，如果在事务执行之前这个(或这些)键被其他命令所改动，那么事务将被中断。这是 Redis 提供的一种方式，能够在一定程度上实现事务的隔离性。

`WATCH key1`  
`MULTI`  
`.....` （这里是你要进行的一系列改动 key1 的命令）  
`EXEC`

### 持久性

**持久性**: 对于持久性，Redis 提供了 RDB 和 AOF 两种方式来将内存中的数据持久化到硬盘里，从而保证数据的持久性。

- RDB 方式是通过定时将数据写入磁盘文件来实现的，是一种快照型的持久化方式。
- AOF 方式则是将所有修改数据库的命令写入 AOF 文件，当 Redis 重启时，会通过重新执行文件中保存的修改命令来还原数据。AOF 的优点是数据安全，即使发生系统奔溃也不会丢失过多数据。

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221415200.png)

## 哨兵

哈哈，让我们把 Redis 的哨兵机制解释成一个"超级英雄"故事。

在一座中世纪的城堡（Redis 主结构，一主多从）中，有一群忠诚的哨兵（Redis 哨兵机制）。他们的主要职责是监控城堡中的王（主节点），如果发现王有任何的异样，他们就会立即选出新的王来替换现任的王。

**为什么需要哨兵机制？**  
就像城堡需要哨兵一样，Redis 也需要哨兵机制来监控主节点的状态，进行故障切换以及通知相关的客户端。

**如何判断主节点挂了？**  
哨兵通过向主节点发送心跳包（ping）来获取主节点的状态。如果发现主节点没有响应，那么哨兵就会认为主节点处于主观下线状态。而如果其他的哨兵也得出相同的结论，那么主节点就会被认为处于客观下线状态。

**如何选举新的主节点？**  
选举新的主节点就像选举新的国王一样，哨兵会根据一系列的规则来进行评选：

1. 网络交互良好。跟过去的主节点网络交互好的从节点优先被选为主节点。
2. 从节点权重配置。权重高的从节点优先被选为主节点。
3. 同步偏移量（offset）。数据更新最新的从节点优先被选为主节点。
4. 从节点 ID。ID 靠前的从节点优先被选为主节点。

以上就是 Redis 的哨兵机制的基本原理啦，仿佛是一部动人的中世纪骑士电影！

---

## 哨兵

哇哈哈，这个问题可是和解密一样，让人兴奋不已。很好的提问，我们来一起解密下 Redis 哨兵机制的玄妙！

**如何进行主从切换？**  
主从切换就如同王位更替，需要先选出一个领导哨兵。这个领导哨兵需要获得超过半数的哨兵投票。选举出来后，他将负责将此信息通知所有的 Redis 客户端和其他的 Redis 服务器。之后，领导哨兵会挑选一个最适合的从服务器，将它升级为主服务器。

**如何通知客户端更新了主节点？**  
这个过程就像是广场上的广播一样，使用的是发布/订阅模式。当主节点切换后，哨兵会通过发布/订阅的方式向所有订阅其信息的客户端发送消息，通知他们主节点已经更替。

**哨兵集群如何组成?**  
就像一支士兵小队一样，哨兵集群是一组哨兵进程，他们通过主节点中的配置信息来认识彼此并组成集群。每个哨兵通过发送心跳信息来和其他成员保持联系。

**什么是脑裂？**  
脑裂就像一个国家一样，由于某种原因分裂为两个或多个独立的区域。在 Redis 中，脑裂指的是网络问题导致集群在网络中的某两个节点间失去连接，节点间无法进行数据同步和主从切换。

**如何确定是脑裂？**  
就像断网一样，如果发现节点之间的数据不一致，或者无法进行主从切换，那就可能发生了脑裂。

**为什么会脑裂？**  
通常是因为网络的问题，比如网络延迟、分区等问题，这就导致了节点间的数据无法同步，就发生了脑裂。

**脑裂为什么会丢数据？**  
因为在脑裂的状态下，不同的节点可能会接收到不同的写请求，这时，即使网络问题解决后，这些不一致的数据也无法合并，从而导致数据的丢失。

以上就是我对这个问题的解答，有没觉得像是解开了一个谜团一样令人兴奋呢？
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221415401.png)

**Redis Cluster 的主从切换**：你可以把它想象成一场精彩的舞蹈。在 Redis Cluster 模式下，主从切换的过程是自动完成的。当一个主节点失效时，它的某个从节点将会自动提升为新的主节点。此过程中，集群中其他主节点会为失效节点的各个从节点投票，当某个从节点得到了大多数的票，它就会成为新的主节点（一般投票时长为 10 秒，票数达到阈值就马上提升为主节点），然后会通知集群中其他节点，这个从节点已经提升为新的主节点。

**Redis Cluster 存在脑裂的情况吗？**  当然，像冬日的河流一样，虽然表面上被冰封住看不出，但纵深之下依然会发生脑裂情况。但是，Redis Cluster 使用了一种叫做"gossip protocol"的协议来检测和传播节点的信息，通过这个协议，Redis Cluster 可以及时发现网络分裂（网络分区）问题并进行必要的处理，比如停止写操作和切换主从。换句话说，Redis Cluster 已经为处理脑裂问题做好了准备，尽可能地防止数据的丢失。

**如何解决脑裂问题？**  想象一下你正在做一个高难度的拼图，解决脑裂问题也需要采取一些策略。对于 Redis，可以采用一些策略来解决，如你所说，比如通过配置使主节点在丢失一定数量的从节点连接后，停止接收写入。这样做可以在确定数据安全的情况下，继续提供读服务。
![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221416559.png)
