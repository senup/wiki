---
title: Java 集合
date: 2023-12-22 13:34:05
tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

我现在想要了解 LinkedList 的相关知识，请你列个表格给我，表格列：类、应用场景、底层数据结构、关键特性、是否线程安全、线程安全机制、扩容机制、有序性、初始化增删查改概述；下面是一个表格内容的举例，我希望你参考下面的列给我列个表格：


```
ArrayList
线程不安全，适合读多写少的场景
数组
构造传入一个合适的大小；随机查询、插入、修改，性能比较好；顺序插入，超过了数组的大小，就会进行扩容；
线程不安全
ArrayList 在设计上是没有实现线程同步的。这就意味着如果多个线程同时对 ArrayList 进行结构上的修改操作（比如添加、删除元素等），就会出现数据不一致的问题，甚至可能抛出 `ConcurrentModificationException` 异常。
扩容：超过数组大小，1.5 倍扩容，遍历 fail-first 特性
插入顺序
**初始化：**  当我们创建一个 ArrayList 的时候，ArrayList 会初始化一个空数组。如果我们指定了初始化容量，那么它就会创建一个指定大小的数组。如果我们没指定，那当我们第一次调用 add 方法时，它会创建一个 10 大小的数组。你看，这就好像明星在摄影棚中，选择器合适尺寸的布景，来拍摄美轮美奂的照片一样。**添加元素：**  当我们向 ArrayList 中添加元素时，它会在数组的末尾添加这个元素。如果数组已经满了，那么 ArrayList 就会创建一个新的数组，这个数组的大小是旧数组大小的 1.5 倍。然后，它会把旧数组的所有元素都复制到新数组中，同时旧数组会被垃圾回收。这个过程就像是热闹的派对人数越来越多，现在的会场已经容纳不下，于是换了一个更大的会场，然后把人们都引导到新会场里。**访问元素：**  因为 ArrayList 底层是用数组实现的，所以我们可以直接通过数组的索引快速访问元素。这就像是我们直接凭票根找到自己的座位一样。**删除元素：**  当我们在 ArrayList 中删除元素时，后面的元素将会向前移动，覆盖掉被删除元素的位置。这就像是派对中有人离开，大家都往前挤，盛情之下，空位完全看不出来。
```


![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221334410.png)


![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221335532.png)




<!--more-->