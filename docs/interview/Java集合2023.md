---
title: Java 集合
date: 2023-12-22 13:34:05
tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---


## 表格



|类| 记忆                                                         | 功能                                                         | 应用场景                                                     | 底层数据结构                                                 | 扩容机制                                                     | 有序性                                                   | 初始化                                                       | 添加元素                                                     | 访问元素                                                     | 删除元素                                                     |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ArrayList             | ArrayList，可以将其比喻为一列火车。初始化一个 ArrayList，就像买了一列火车，有固定的车厢数量（也就是数组的大小）。你可以在车厢里放东西（元素），如果车厢满了还有更多的东西要放，火车会"自动"增加车厢。 | ArrayList 是一个非常灵活和强大的数据结构，它提供了动态调整大小的能力，非常适合需要频繁添加和删除元素的场合。在现实生活中，比如火车运输，可能需要随着货物的增加或减少，增加或减少车厢，而 ArrayList 就是实现这个功能的理想选择。 | 线程不安全，动态数组，适用于随机访问元素                     | ArrayList 是一个基于动态数组实现的，它可以随机访问数组中的元素。 | ArrayList 可以自动增长和缩小，在添加元素使得数组容量不足时，它会提前分配（旧容量的1.5倍）新的存储空间；在移除元素使得数组空间过多时，也可以通过 trimToSize 方法释放多余的存储空间。 | 有序，元素的插入顺序                                     | **初始化：** 初始化 ArrayList ，就如同买了一列火车，预先有了固定的车厢（可以通过指定初始容量来决定车厢的数量）。 | **添加元素：** 向 ArrayList 添加元素，就像在车厢里填充物品，如果物品太多车厢不够用，火车会自动增加车厢（数组扩容）。 | **访问元素：** 访问 ArrayList 的元素，就像查看某个车厢中的物品。 | **删除元素：** 删除 ArrayList 中的元素，就像清空车厢中的物品，并且能够通过 trimToSize 方法来移除空的车厢。 |
| LinkedList            | 可以把它想象成一条龙舞队伍。每个人（节点）通过牵手（链接）将队伍连成一体，每个人手中都有自己的工具（元素）。 | LinkedList是一种很灵活的数据结构，对于添加和删除元素的操作有很高的效率，特别适合于数据的动态插入与删除操作。就像舞龙队伍，队员之间通过牵手连接在一起，每位队员都可以灵活地加入和退出队伍，这样的队伍组织方式就体现了 LinkedList的特性。 | 线程不安全，双向链表，适用于频繁增删操作场景                 | LinkedList是一个基于链接节点的双向链表，它可以随机访问列表中的元素，但是效率较低（需要从头节点或尾节点开始遍历）。 |                                                              | 有序，插入顺序                                           | **初始化：** 初始化 LinkedList，就像组成一支舞龙队伍。       | **添加元素：** 向 LinkedList添加元素，就像让一位新队员加入舞龙队伍。由于是双向链表，新队员可以灵活地加入队伍的任何位置。 | **访问元素：** 访问 LinkedList的元素，就像查看某位队员的工具。 | **删除元素：** 删除 LinkedList中的元素，就像让某位队员退出队伍。 |
| CopyOnWriteArrayList  | 可以想象一个正在进行剧本创作的剧团。每当剧本需要进行修改（添加或删除元素）的时候，而原来的剧本会被保留，新的修改会在副本上进行，以确保其他的演员所拿到的剧本的一致性 | CopyOnWriteArrayList非常适合读多写少的并发环境。在剧团的例子中，演员们（读操作）的数量通常远大于剧本的修改（写操作）的次数，所以尽管写操作的代价较大（需要复制剧本），但总体上，剧团能够确保所进行的工作是有效和高效的。 | 线程安全，适用于读多写少的场景                               | 基于数组实现，写时复制的策略                                 | 通过写时复制（Copy-on-Write）策略实现线程安全。即每次对列表的修改都会复制一份新的数组，完成修改操作后，再使新数组替换原数组。 因为每次修改操作都需要复制一份新数组和数据迁移，所以在写操作较多时，性能不佳。 对于读操作，则可以直接读取原数组的数据，无需加锁，读的效率较高。 | 有序，元素的插入顺序                                     | **初始化：**  初始化CopyOnWriteArrayList，就像剧团把原来的剧本复印出来供大家熟悉。 | **添加元素：** 修改CopyOnWriteArrayList，就像在原剧本上进行修改，具体方法是新复印一份剧本，并在副本上进行修改，修改完成后，副本就成了新的标准剧本。 | **访问元素：** 读取CopyOnWriteArrayList的元素，就像演员读取他们的剧本，因为剧本在修改时不会影响到原剧本，所以他们总能读取到一致的内容，无需担心在读取过程中剧本发生改变。 | **删除元素：** 删除CopyOnWriteArrayList的元素也是在副本上完成的，原剧本不受影响，直到新剧本编辑完成，才会替换掉原来的剧本。 |
| Vector                | 将它想象成一个智能存储设备。它可以不断地按需添加存储空间，并且我们可以随时在设备的任何位置存取数据 | 尽管 Vector 在功能上与 ArrayList 类似，但由于其线程安全的特性，使其在需要考虑线程安全的情况下，比如多线程环境，成为一个非常好的选择。 | 线程安全，需要线程安全的List操作时使用，和ArrayList基本功能类似 | 基于数组实现。相比ArrayList（非线程安全），它在性能上会有些许损失。 | 当 Vector 内部的数组满了，它会自动扩容，一般默认扩大一倍，当然也可以自定义扩大多少。<br /> 当我们插入一个元素，Vector 会自动将其放到数组的末尾，顺序是按照插入的顺序。 | 有序，元素插入的顺序                                     | **初始化：** 初始化一个 Vector，就像购买一个有初始存储空间的智能存储设备，你可以根据需要进行扩容。 | **添加元素：** 向 Vector 中添加元素，就好像在设备上存储数据，当存储空间不足时，设备会智能地增加存储空间。 | **访问元素：** 访问 Vector 的元素就像在设备中查找数据，无论数据在设备的什么位置，我们都可以直接访问到。 | **删除元素：** 从 Vector 中删除元素，就像从设备中删除数据。当数据被删除后，设备会自动调整剩余数据的位置。 |
| Stack                 | Stack（堆栈），我们可以把它想象成一叠盘子。当你需要添加一个新的盘子（元素）时，你会把它放在最上面，当你需要使用盘子时，你也会选择最上方的盘子，这就是“后进先出（Last In First Out，LIFO）”策略 | 堆栈是计算机科学中的基石，许多算法，如深度优先搜索（DFS），都依赖于堆栈来完成。另外在程序的运行时，方法的调用就是依靠了系统的堆栈实现的。像我们上面提的餐厅例子中的已经洗好的盘子堆一样，你无法从中间取一个盘子，只能从顶部开始拿，这就是 "后进先出" 的特点。 | 线程不安全，需要LIFO操作时候使用<br />Stack 内部基于 Vector 实现，它是线性表的一种数据结构，只允许在一端插入和删除元素。 | 基于数组实现                                                 | 虽然 Stack 内部改写了 Vector 的一些方法，增加了同步操作，但是在多线程并发出栈或者入栈的情况下使用 Stack 可能会出现数据不一致的问题。 和 Vector 一样，Stack会根据需要进行动态扩容。 | 有序，元素插入的顺序                                     | **初始化：** 初始化一个 Stack，就像拿出一个可以放盘子的货架，准备好放置盘子。 | **添加元素：** 入栈（Push）操作就像在盘子堆的顶部添加一个新盘子。 | **访问元素：** 当你需要访问最近添加的元素，你只能查看（Peek）或移除（Pop）最顶端的盘子。 | **删除元素：** 出栈（Pop）操作就像拿走最上方的盘子。         |
|                       |                                                              |                                                              |                                                              |                                                              |                                                              |                                                          |                                                              |                                                              |                                                              |                                                              |
| HashMap               | 可以把 HashMap 想象成一间大型的自助餐厅                      | 虽然 HashMap 是线程不安全的，但是在 Java 集合类库中，适应多线程环境的 ConcurrentHashMap，提供了高并发高性能的并发访问。在 | 线程不安全，读多写少或者说并发性要求不高的情况下<br />利用唯一键和哈希函数能在常数时间内对元素进行添加、删除和定位操作。哈希冲突解决方案——链地址法 | 数组 + 链表/红黑树（当链表长度大于8时，会转换为红黑树）      | 在并发情况下，可能出现多线程导致数据不一致，即竞态条件。也可能出现正在读取数据时，数据被其他线程修改，导致结果不可预测。 | 无序                                                     | **初始化：** 当我们创建一个 HashMap 的时候，HashMap 会初始化一个空数组，这就像是早上的自助餐厅，各个台面都已经摆好，就等着客人来挑选美食了。 | **添加元素：** 在我们向 HashMap 添加元素时，根据元素的哈希值确定其在数组中的位置，如果该位置已经有其他元素（发生哈希冲突），那么新元素就会被链到已存在元素的后面，这就像是去自助餐台盛菜，有些热爱同一种食物的客人，就会在这道菜前面排起了队。 | **访问元素：** 通过元素的哈希值，我们可以在常数时间内定位到元素的位置，这就像通过颜色、形状、味道辨别食物一样方便。 | **删除元素：**  删除元素也是通过哈希值快速定位，然后将元素删除，这就像顾客吃完一盘子鸡翅，把骨头从盘子里挑出来一样。 |
| LinkedHashMap         | 想象成一个有序的自助餐厅，不仅可以享受美食，还能按照菜品的顺序一口一口品尝 | 在享受 HashMap 带来的快速查找的同时，LinkedHashMap 还能使元素保持一种有序状态，简直就是自助餐厅中的 VIP 体验！ | 线程不安全，当需要按照插入顺序或者访问顺序遍历元素时<br />既具有 HashMap 的快速查找特性，又增加了元素的有序性，可以根据插入的顺序或者访问的顺序来获取元素。 | HashMap + 双向链表                                           | LinkedHashMap 并未实现同步，因此如果多个线程同时访问一个 LinkedHashMap，而其中至少一个线程在结构上修改了这个映射，则必须在外部进行同步。 无扩容机制，因为它是基于链表，无须扩容 | 元素的插入顺序                                           | **初始化：** 创建一个 LinkedHashMap，你可以选择按插入顺序或者访问顺序来排序元素。这就像你进入一家自助餐厅，选择的优先级食物是你喜欢的顺序，还是按菜单上的顺序。 | **添加元素：** 当你向 LinkedHashMap 添加元素时，不仅将元素添加到 HashMap 中，还会添加到双向链表的尾部。这就像你在自助餐盘子上盛食物，不仅要考虑食物的美味，还要考虑食物的搭配。 | **访问元素：** 当获取元素时，如果是访问顺序的 LinkedHashMap，会将访问的元素移动到双向链表的尾部。这就像你每尝一口盘子里的食物，不喜欢的就被你放到一边，喜欢吃的总是在你最容易到达的位置。 | **删除元素：** 删除元素时，需要同时在 HashMap 和链表中删除，这就像你吃完一种食物后，会把盘子清理干净，让它不再占浪费你的胃口。 |
| TreeMap               | 想象成一家讲究等级的中餐厅，每个菜品都按照特定的顺序摆放，以此来方便不同口味的客人找到他们想要的菜品。 | 讲究等级的 TreeMap 餐厅                                      | 线程不安全，适用于排序的场景                                 | 基于红黑树的 NavigableMap 实现，这意味着它的元素是有序的。   | TreeMap 的结构会被并发修改，可能会影响 TreeMap 的行为，甚至引发不可预测的结果<br /> 无需扩容，因为TreeMap底层采用红黑树的数据结构，添加元素时，直接在红黑树上添加一个新的节点。 | 有序，根据元素的键值对进行自然排序。                     | **初始化：**创建 TreeMap 的时候，会创建一个空的红黑树，在这棵树上添加新的节点就像在一个空的餐厅中添加新的菜品，以等待食客们的挑选。 | **添加元素：**在添加一个新元素到 TreeMap 时，红黑树会以一种特定的方式来重新排序，以确保它的顺序。这就像一个讲究等级的餐厅，菜品会按照一定的顺序，比如价格、口味来排列，这样客人就可以更方便地找到他们想要的菜品。 | **访问元素：**用户可以直接通过键来快速检索和获取元素，这就像你在菜单上找到一道菜，然后告诉服务员，他们就会在短时间内为你上菜。 | **删除元素：** 删除一个元素时，红黑树会进行自我平衡，以保持它的有序性和高效性。这就像在餐厅中有菜品被客人吃完，但是剩下的菜品会重新排列，以保持菜单的整洁和秩序。 |
| ConcurrentHashMap     | 可以将其想象成一家大型超市。超市内商品种类繁多（多个键值对），为了方便顾客寻找，商品被分布在各个区域（分段锁的设计）。 | 并发情况下，ConcurrentHashMap是个不错的选择，它在保证线程安全的同时，也考虑到了访问效率。在其内部，它将数据分为多个小的分区（Segment），不同的线程可以在不同的分区上进行操作，这既保证了线程安全，也提升了并发性能。就比如我们的超市，每个顾客可以在各自感兴趣的区域寻找商品，而不会互相影响。 | 线程安全，适用于高并发的 HashMap 操作                        | 基于数据分段的锁实现。   ConcurrentHashMap是一个线程安全的散列映射表，它允许线程并发进行更新操作，使其在多线程环境下能够提供更高的性能。 | ConcurrentHashMap使用分段锁技术，相比HashTable的线程安全性，不需要锁住整个集合就可以保证数据的完整性和并发更新。 对于扩容，使用了更为安全的CAS操作 | 有序，元素插入的顺序                                     | **初始化：** 初始化 ConcurrentHashMap就像购买一个超市，并为各种商品分类。 | **添加元素：** 向 ConcurrentHashMap 添加键值对，就像往超市的货架上添商品，如果商品很多，货架空间不够了，超市会翻倍扩建。 | **访问元素：** 访问 ConcurrentHashMap 的元素，就像顾客在超市中寻找自己需要的商品。 | **删除元素：** 删除 ConcurrentHashMap 中的键值对，就像将过期的或者破损的商品从超市中移除。 |
|                       |                                                              |                                                              |                                                              |                                                              |                                                              |                                                          |                                                              |                                                              |                                                              |                                                              |
| HashSet               | 把它想象成一座大型的公园，每个人（元素）都是独一无二的，每个人都有自己的位置（通过哈希值确定） | 这个公园是如此的美妙，每个走进的人都能在这里找到属于自己的位置，尽管找到他们可能要花一些时间，但他们都是独特的，无可替代的。 | 线程不安全，存储需去重且不要求保持顺序的数据                 | 基于 HashMap 实现 。HashSet中的元素都是独一无二的，没有重复的元素。并且它们并无特定的排列顺序。 | HashSet 在设计上并未实现线程同步，所以在多线程并发修改 HashSet 时可能会出现数据不一致的问题。 HashSet没用实现扩容，因为它是基于HashMap，所以扩容问题由HashMap负责。 | 无序                                                     | **初始化：** 初始化一个 HashSet，其实就是初始化一个背后的 HashMap，这就像是在公园的一块草地上插入许多的桩，标定了每个人可能的站立位置。 | **添加元素：** 向 HashSet 中添加元素，实际上就是向背后的 HashMap 的 key 中添加元素，value 使用一个固定的对象。每个人进入公园，根据他们的一些特征（哈希值），分配到一个位置上。 | **访问元素：** HashSet 的读取需要遍历整个集合，无法通过索引（因为无序），快速定位元素，就像要在公园里找一个人，可能需要走遍整个公园的每一个角落。 | **删除元素：** 通过元素的哈希值，我们可以在常数时间内在 HashMap 中定位并删除掉这个元素，  就像公园管理员清理一些不应该在公园的东西一样。 |
| LinkedHashSet         | 把它想象成一座公园，不仅每位访客（每个元素）都是不重复的，而且还可以记住访客的到访顺序。让人觉得既有序又井然。 | 每个人都会被按到访的顺序记住，这使得每个参观的经历都独一无二。人们来来往往，但公园管理者会始终记住他们的顺序，这才是 LinkedHashSet 真正迷人之处。 | 线程不安全，适合存储需去重且保持插入顺序的数据               | 基于 LinkedHashMap 实现。 既有 HashSet 不重复性的特性，又保持了元素的插入顺序。 | LinkedHashSet 和其它的 Set 实现类一样，在设计上并未实现线程同步。在多线程环境下，可能会出现数据不一致的问题。 由于 LinkedHashSet 是基于 LinkedHashMap 实现，所以扩容问题由 LinkedHashMap 负责。 | 有序，它按照元素的插入顺序进行排序                       | **初始化：** 创建 LinkedHashSet 其实就是创建一个背后的 LinkedHashMap，已准备存储你的独特元素。 | **添加元素：** 添加元素到 LinkedHashSet，就像是记录每位来访的客人，并确保他们都在自己的位置，并按照他们到访的顺序。 | **访问元素：** 与 HashSet 类似，如果需要访问特定元素，需要遍历整个集合。但由于元素是有序的，所以在某些情况下，这可能会更加高效。 | **删除元素：** 删除元素时，LinkedHashSet 会从 LinkedHashMap 中删除对应的元素，以保持所有元素的独特性和顺序性。 |
|TreeSet| 把它想象成一个精心设计的花园，不仅每株花朵（元素）都不会重复，而且它们还会按一定的顺序排序，如颜色、形状或大小 | 欣赏这个花园就像遍历一个 TreeSet，无论你何时来访，花朵（元素）的顺序总是按照一种预定的方式进行，这使得这个花园（集合）具有非常可预测的行为。虽然它不允许生长同样的两朵花（重复的元素），但正因为如此，每一朵花（元素）都显得那么的特别。 | 线程不安全，需要排序的场景                                   | 基于 TreeMap实现。 TreeSet是一个有序的集合，它的元素按自然排序或根据创建 set 时提供的 Comparator 进行排序。其中的元素同样不会重复。 | TreeSet并未实现同步，多线程环境下可能出现数据不一致。 无需扩容，基于红黑树的数据结构，添加元素时，直接在红黑树上添加一个新的节点。 | 有序，元素根据自然排序或者提供的Comparator进行排序。     | **初始化：** 当我们创建 TreeSet的时候，实际上是创建了一个背后的TreeMap来存储元素。 | **添加元素：** 向 TreeSet添加元素，就像在花园中种下一种新的花朵。每种花朵都按一定的顺序种植，所以当你看花园时，你会发现每种花朵都占据了自己独特的位置。 | **访问元素：** 由于元素有序，我们可以很容易地找到所需的元素，这就像在花园中找到一种特定的花朵。 | **删除元素：**  删除元素时，TreeSet会从TreeMap中删除相应的元素，就像园丁摘掉一朵枯萎的花朵，让花园的美丽得以保持。 |
|                       |                                                              |                                                              |                                                              |                                                              |                                                              |                                                          |                                                              |                                                              |                                                              |                                                              |
| ArrayDeque            | 把它想象成一种特殊的数据结构，就像一个循环的排队系统，可以看作一个队列（Queue）也能看作一个双端队列（Deque），你可以在系统的任意一端添加或移除元素 | ArrayDeque 是一个很好的数据结构，它的错综复杂的功能在许多情况下都会派上用场，尤其是当你需要在队列两端进行操作时。不仅如此，由于 ArrayDeque 的内部实现，它在性能上也往往优于 Stack 和 LinkedList，所以它是 Java 提供的集合类库中的一颗璀璨之星。 | 线程不安全，需要双端队列操作时使用                           | 基于数组实现。 ArrayDeque是一种特殊的队列，它可以在队列的头部或尾部进行添加和删除元素的操作，这使得它成为双端队列（Deque：Double Ended Queue）。 | 在多线程并发操作 ArrayDeque 的时候可能会出现数据不一致的问题。 ArrayDeque 内部使用一个动态扩容的循环数组实现，因此插入元素和删除元素的平均时间复杂度都是常数级别。可以同时在队列的头部和尾部进行添加和删除操作。 | 有序，可以从头部或尾部插入和删除，有序性取决于具体操作。 | **初始化：** 当你创建一个 ArrayDeque 的时候，就像你在准备一个可以从两端进出的排队系统。 | **添加元素：** 你可以在队列的前端或尾端添加元素，就好像让新人加入排队系统，要么排在队尾，要么插队站在队首。 | **访问元素：** 你能够访问或移除队列的头部和尾部元素，就好像你可以选择服务排队系统的第一位或最后一位顾客。 | **删除元素：** 同样，你也可以从队列的两端删除元素，这就像你让顾客离开排队系统，无论他是第一个顾客还是最后一个顾客。 |
| ConcurrentLinkedQueue | 将其想象成一条自助餐厅的取餐线。每个人可以并行地从取餐线取自己需要的食物，而取餐线则始终保持最前面是最新的食物 | 并发情况下，ConcurrentLinkedQueue是个很好的选择，它支持高并发的数据操作。尤其是在很多生产者-消费者模型中，ConcurrentLinkedQueue都能发挥重要作用。就像在我们的自助餐厅中，厨师（生产者）和顾客（消费者）可以同时进行操作，厨师在队列尾部添加食物，而顾客则从队列头取食物，互不干扰，非常高效。 | 线程安全，适用于高并发的 Queue 操作                          | 基于链表实现。 ConcurrentLinkedQueue是一种基于链接节点的无界线程安全队列，采用先进先出的原则对元素进行排序。 | 通过一种称为“无锁CAS（Compare And Swap）”技术来保证数据的一致性和并发更新，没有使用传统的锁同步。 内部采用链表结构，节点间通过链接串联起来 | 有序，元素插入的顺序就是它们在队列中的顺序。             | **初始化：** 初始化 ConcurrentLinkedQueue，就像设置一条取餐线，等待顾客来取食物。 | **添加元素：** 向 ConcurrentLinkedQueue 添加元素，就像添加新的食物到取餐线的末端。 | **访问元素：** 访问 ConcurrentLinkedQueue 的元素，就像顾客在查看取餐线上最前方的食物，但并未取走。 | **删除元素：** 删除 ConcurrentLinkedQueue 中的元素，就像顾客从取餐线最前方取走食物。 |
| LinkedBlockingQueue   | 将其想象成银行的排队服务。当有新的客户来办理业务时，他们会被添加到队尾；当柜员准备好服务新的客户时，就从队首取出一个；如果队列中没有客户，柜员就等待。可以看出，银行的排队服务就有点像一个阻塞队列 | LinkedBlockingQueue非常适合用于生产者-消费者场景。在现实生活中，就像银行的排队服务系统。当没有客户时，柜员可以稍事休息；当客户太多，新到的客户则需要排队等候。这就是典型的阻塞行为，而 LinkedBlockingQueue 则是在程序中实现这种行为的工具。 | 线程安全，适用于生产者消费者场景                             | 基于链表实现。 LinkedBlockingQueue 是一个基于链表的阻塞队列，相当于一个长度可以指定（如不指定，将为 Integer.MAX_VALUE）的有界阻塞队列。 线程安全 | 通过 ReentrantLock 与 Condition 来保证数据的一致性并实现生产者消费者模型。在队列为空时，消费者在 take 时候会阻塞，直到生产者生产了数据为止。同样，当队列满时，生产者在 put 时会阻塞，直到消费者消费了数据为止。 内部采用链表结构，节点间通过链接串联起来 | 有序，线程安全，插入顺序                                 | **初始化：** 初始化 LinkedBlockingQueue，就像在银行内部启动一个排队服务系统。 | **添加元素：** 向 LinkedBlockingQueue 添加元素，就像有新的客户走入银行，并排在队伍最后面。 | **访问元素：** 访问 LinkedBlockingQueue 的元素，就像柜员查看队伍第一个客户，但是并未开始为他服务。 | **删除元素：** 删除 LinkedBlockingQueue 中的元素，就像柜员开始为队伍第一个客户提供服务，并从队伍中移除他。 |
| ArrayBolcokingQueue   | 将其比喻为一个停车场。停车场有固定的车位数（确定的容量），每当有车进来（生产者）就占用一个车位，当车位满了就不能再进车，需要等待。而当有车开走（消费者）就释放一个车位，若停车场无车，再有人想取车就需要等待。 | ArrayBlockingQueue 非常适合生产者消费者模式，在高并发中可以很好地处理请求。在现实生活中，比如我们的停车场，车位满了，新来的车只能等待；停车场无车，再有人想取车也得等待，这种现象在生活中很常见，而 ArrayBlockingQueue 则提供了在程序中模拟这个现象的可能。 | 线程安全，适用于生产者消费者场景                             | 基于数组实现。<br /> 生产者线程向队列中插入元素，如果队列满，线程被阻塞直到队列非满；消费者从队列中取走元素，如果队列空，线程被阻塞直到队列非空。 <br />必须设置队列容量 | 基于数组实现，必须在初始化时指定容量。使用 ReentrantLock 来保证数据的一致性，在队列为空时，消费者在 take 时会阻塞，直到生产者生产了数据为止。 | 有序，线程安全，插入顺序                                 | **初始化：** 初始化 ArrayBlockingQueue ，其实就像我们在规划一个停车场一样，必须预先确定停车位的大小。 | **添加元素：** 向 ArrayBlockingQueue 添加元素，就好像有辆新车开进停车场，并占用一个车位。 | **访问元素：** 访问 ArrayBlockingQueue 的元素，就像查看停车位上的第一辆车，但并未将其开走。 | **删除元素：** 删除 ArrayBlockingQueue 中的元素，就像驾驶第一辆车离开停车场，从而空出一个车位。 |
| synchronizedQueue     | 把它想象成一个正在进行接力比赛的队伍。只有当手中的接力棒（即队列中的元素）被接走后，才能接受新的接力棒。 | SynchronousQueue非常适合传递性设计，比如在一个线程中使用的数据，传递给另一个线程使用。就像接力比赛，一个运动员把接力棒传给另一个运动员，然后他就可以安心地休息了，等下一轮比赛再接受新的接力棒。 | 线程安全，适用于传递性场景                                   | 基于链表或者基于栈实现。 SynchronousQueue是一个没有存储空间的阻塞队列，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。 | 通过不存储元素来保证线程安全，对SynchronousQueue的操作被认为是其他线程可立即使用的。也就是说，它是一种在线程之间传递元素的方式。 | 无序，没有存储元素，只是在线程间进行数据传递。           | **初始化：** 初始化 SynchronousQueue，犹如叫集成员，准备参加接力比赛。 | **添加元素：** 向 SynchronousQueue添加元素，就像递出接力棒，这时就必须有人接过这个接力棒。 | **访问元素：** 由于 SynchronousQueue没有存储空间，不能单纯地访问元素。可以认为，在take操作时已顺带完成了访问与删除两个动作，就像队友接走了接力棒。 | **删除元素：** SynchronousQueue没有存储元素，故也无删除操作。同上，我们可以认为在take操作时已经完成了删除操作。 |
|                       |                                                              |                                                              |                                                              |                                                              |                                                              |                                                          |                                                              |                                                              |                                                              |                                                              |
|                       |                                                              |                                                              |                                                              |                                                              |                                                              |                                                          |                                                              |                                                              |                                                              |                                                              |



---

# 

## 截图

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221334410.png)


![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221335532.png)




<!--more-->