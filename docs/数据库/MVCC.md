---
title: MVCC
date: 2023-12-27 12:51:15
Tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

## 定义

MVCC, multi version concurrent control，多版本并发控制。

实现思路是依托于 undo log 的版本链+read view 来实现的。

什么是 undo log 版本链呢？就是数据行会有一个版本历史，类似 git 历史版本一样，有两个隐藏字段最近一次更新的事务 id 和回滚指针，指向更新这个事务之前的 undo log。

什么是 read view 呢？就是开启事务就会生成一个视图，视图记录这最小事务的 id 和最大事务 id（下一个要生成的事务 id），活动事务 id，当前事务 id。

然后呢，事务并发的时候就会去跟这个数据行的事务 id 进行比较，有四种情况。

- 如果小于最小事务 id，说明是之前提交的，可以访问；
- 如果大于事务最大 id，说明之后提交的，不能被访问；
- 如果在最大最小范围里面，则判断活动事务 id 有无，有就说明一起执行的事务还没提交不能访问；否则就可以访问；
- 如果发现事务 id 相等，说明是自己创建的，可以访问。

~~需要符合在这个事务的最小~最大 id 范围内，然后判断当前数据行是否在活动事务内，如果在那么说明还没提交，不可见。否则就对比当前事务 id 和数据行 id，当前事务 id 大或者等于的情况就可以访问；否则就通过 undo log 版本链的指针指向下一个版本；重复上述比较。~~

## RC VC RR

RC 每次都会开启一个 read view，RR 只有一开始开启一个 read view。

区别在于 RC 里面活动事务可能执行完了，所以 RC 能够看到并发事务的时候，另一个已提交事务的数据行，因为刚好满足在事务 id 的最大最小范围内而且活动事务内没有另一个事务 id，因此就满足了条件。

## 疑惑的点

文章表示事务 id=60 在 RC 状态下是可以查询到 id=70 的已提交的事务。按照这个说法那其实不用比较事务的大小。

怎么解释呢？就是我理解有问题。参考上面删除线的早期内容。

> RR 在访问某条记录时，会根据该事务中的事务快照 ReadView 进行判断：
>
> 1. 行记录中的事务 id 是否为该事务本身的 id，相同则说明自己创建的，可见
> 2. 行记录中的事务 id 比事务快照 ReadView 中最小的还小，表明该记录为之前提交的，能够被当前事务访问。
> 3. 行记录中的事务 id 比事务快照 ReadView 中最大的事务 id 还要大，表明该记录为之后提交的，不能被当前事务访问
> 4. 行记录中的事务 id 在活跃的事务 Id 列表之间，那么就使用二分，判断是否能在活跃集合中找到该事务 id，能找到，说明该事务快照时，还未提交，本事务无法访问，如不在活跃事务集合中，说明已提交，可以访问
>    ![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312271332569.png)

<!--more-->

参考：[MVCC 下的 RR 和 RC 级别的区别和实现-CSDN 博客](https://blog.csdn.net/qq_35634181/article/details/113280233)
