---
title: 两阶段提交
date: 2023-12-28 08:29:58
Tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

## 简记

**两阶段提交**是为了实现分布式系统中的事务一致性，它分为两个阶段进行：

- _第一阶段_：事务协调者询问各个事务参与者是否已经准备好提交事务，收到各个参与者的“已就绪”回报后，进入第二阶段。老朋友来电问是否可以一起出去玩，你说油满为平就好，那就进入第二阶段啦。
- _第二阶段_：事务协调者向所有参与者发出“提交”请求，所有参与者收到此请求后提交事务，并向协调者报告“已提交”完成事务。所有朋友统一行动，同一时间出门，然后告诉老朋友说，出门啦！

但是，两阶段提交有一个主要问题，就是每个事务参与者在等待其他参与者响应的时候必须阻塞自身，此时处于不可接受其他任何事务请求的状态，这可能造成资源的低效利用。

<!--more-->

所以，我们必需对其进行升级和改进，那就引入了  **[[三阶段提交]]协议**！

- _第一阶段_：和两阶段提交一样，询问所有参与者是否可以提交事务，只有所有的参与者都返回“准备好了”，才进入第二阶段。还是老朋友打来电话，一切准备就绪就进入第二阶段。
- _第二阶段_：协调者向所有参与者发送一个“**预提交**”消息，参与者接收到该消息后，执行事务操作，然后向协调者反馈“准备提交”。
- _第三阶段_：等所有参与者都返回了第二阶段的响应，协调者便向所有参与者发送一个“正式提交”指令。所有的参与者接收到此消息后，提交事务，并向协 ordinator 发送“已提交”的消息。这就好比所有朋友收拾好，出门的时间临近，然后所有人都向那位组织活动的老朋友汇报，“已经出门了”！

而且呢，不像两阶段提交那样参与者需要在第二阶段持续等待，这就是它相比于两阶段提交的最关键的改进点。不过，别忘了，尽管三阶段提交解决了饥饿问题，但仍然可能出现网络分区等问题。

## 二阶段提交协议

二阶段提交算法的成立是基于以下假设的：

- 在该分布式系统中，存在一个节点作为**协调者**（Coordinator），其他节点作为**参与者**（Participants），且节点之间可以进行网络通信；
- 所有节点都采用预写式日志，日志被写入后被保存在可靠的存储设备上，即使节点损坏也不会导致日志数据的丢失；
- 所有节点不会永久性损坏，即使损坏后仍然可以恢复。

两阶段提交中的两个阶段，指的是  **Commit-request 阶段**和  **Commit 阶段**，两阶段提交的流程如下：

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312280859265.png)

#### 提交请求阶段

在提交请求阶段，协调者将通知事务参与者准备提交事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功）或取消（本地事务执行故障），在第一阶段，参与节点并没有进行 Commit 操作。

#### 提交阶段

在提交阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消这个事务。这个结果的处理和前面基于半数以上投票的一致性算法不同，必须当且仅当所有的参与者同意提交，协调者才会通知各个参与者提交事务，否则协调者将通知各个参与者取消事务。

参与者在接收到协调者发来的消息后将执行对应的操作，也就是本地 Commit 或者 Rollback。

#### 两阶段提交存在的问题

![分2.png](https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e5%88%86%e5%b8%83%e5%bc%8f%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%9845%e8%ae%b2-%e5%ae%8c/assets/Ciqah16eldqAX17XAAGwMfUwb2M109.png)

两阶段提交协议有几个明显的问题，下面列举如下。

- 资源被同步阻塞:在执行过程中，所有参与节点都是事务独占状态，当参与者占有公共资源时，那么第三方节点访问公共资源会被阻塞。

- 协调者可能出现单点故障:一旦协调者发生故障，参与者会一直阻塞下去。

- 在 Commit 阶段出现数据不一致:在第二阶段中，假设协调者发出了事务 Commit 的通知，但是由于网络问题该通知仅被一部分参与者所收到并执行 Commit，其余的参与者没有收到通知，一直处于阻塞状态，那么，这段时间就产生了数据的不一致性。

## 应用

在 MySQL 中，二进制日志是 server 层，主要用来做**主从复制**和**即时点恢复**时使用的；而事务日志（Redo Log）是 InnoDB 存储引擎层，用来保证事务安全的。

在数据库运行中，需要保证 Binlog 和 Redo Log 的一致性，如果顺序不一致， 则意味着 Master-Slave 可能不一致。

在开启 Binlog 后，如何保证 Binlog 和 InnoDB redo 日志的一致性呢？MySQL 使用的就是二阶段提交，内部会自动将普通事务当做一个 XA 事务（内部分布式事务）来处理：

- Commit 会被自动的分成 Prepare 和 Commit 两个阶段；
- Binlog 会被当做事务协调者（Transaction Coordinator），Binlog Event 会被当做协调者日志。
