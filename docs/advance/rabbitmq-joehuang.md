---
title: rabbitmq-joehuang
date: 2023-12-22 12:57:14
Tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

# rabbitmq 的关键要素

## 建立连接

- 工厂、连接、通道：就像快乐大本营里的游戏一样，在 RabbitMQ 世界中，先要有一个工厂（ConnectionFactory）来生成连接（Connection），然后再由这些连接创建通道（Channel）。有了这些，才能开始我们的游戏大冒险，执行各种操作。
- Spring 管理：试图把建立连接这件事交给 Spring，就像请管家照看你的豪宅。可以说这是一种“富贵病”，但是它让你可以更专注于业务实现而不被底层细节所困扰。

## 生产者

生产者（Producer）：这就像是一台“魔法饲料机”，它生产出一条又一条消息，然后喂给 RabbitMQ。

## 交换机

### 交换机的功能

交换机（Exchange）：

- 交换机连接生产者和队列，就像在大型舞台上，把明星（生产者）和粉丝（队列）连接起来。没有交换机，RabbitMQ 就会变得非常"无聊"。
- 它具有路由功能，决定生产的消息，应该如何转发到哪一个队列里面去。就像邮政员一样，根据地址把信送到各个不同的邮箱中。

---

### 交换机的类型

交换机的类型有四种：直接交换机（Direct）、主题交换机（Topic）、头交换机（Headers）和扇形交换机（Fanout）。每种类型的交换机都有其独特的“解码能力”。

```shell
- 直接交换机：直接交换机就像一个严谨的检查员，只有当消息的路由键（Routing key）和绑定键一样时，才会将消息发送到对应的队列。也就是说，直接交换机是根据消息的“身份证”——路由键去找到它的“家”——队列。
- 主题交换机：主题交换机的处理方式更像一个精妙的填词游戏，它把消息通过模糊匹配的方式发送到队列。路由键可以是多个词，这些词之间用"."分隔，"_"%% 匹配一个词 %%，“#”匹配多个词（可以是零个）。比如，"log.error"的路由键能匹配到"_.error"和"log.#"的绑定键。
- 头交换机：头交换机是一个颇有洁癖的角色，不走寻常路。它根据消息内容中的 headers 属性进行匹配。在这种类型中，路由键实际上并没有被用到。
- 扇形交换机：  扇形交换机就像一个滔滔不绝的大嘴巴  ，它会把所有发送到该交换机的消息路由到所有与它绑定的队列。在这种类型下，如果设置了路由键，也会被忽略。
```

所以在这个“解码战舰”上，消息会被高效准确地分配去它们正确的“家”，即队列。对于 RabbitMQ 来说，找到一个适合你需求的交换机类型就像是找到了一个高效的邮政员，能把你的消息准确地送到它们应到达的地方。

---

假设你是一位艺术家，想要向粉丝发送你的新录音——这就是我们的消息。你的粉丝们如果要接收你的新录音，他们需要订阅你的“交换机”。

1. **Direct Exchange**：向你的粉丝们公告，只有在‘rock’类型中订阅的粉丝会收到你的新录音。在这种情况下，只有那些订阅了为‘rock’的队列会收到消息。就像你把乐团通告放在一个专门的‘rock music’的公告栏上，喜欢‘rock music’的人就可以看到。
2. **Fanout Exchange**：无论你的粉丝喜欢什么类型的音乐，他们都将收到你的新录音。这就是一种“广播”，所有订阅你的“交换机”的队列都会收到消息。就像你在一个巨大的广播站向全世界广播你的通告。
3. **Topic Exchange**：这时候，你可以允许你的粉丝在更详细的级别上订阅，比如‘_.rock._’。例如，那些订阅‘heavy.rock.guitars’的队列会接收到所有与‘heavy.rock.guitars’的消息，但那些只订阅‘rock’的则不会。就像你向所有热爱‘heavy rock guitars’的人进行发送，更具针对性。
4. **Headers Exchange**：这是一种更高级的场景，你可以根据消息内容中的‘headers’的属性来匹配和发送消息。比如你发送一段"Unplugged"系列的录音，标头可以设置为"{'style': 'unplugged'}"，那么所有队列的标头也设置为"{'style': 'unplugged'}"的，就能接收到录音。

以上就是四种交换机类型的象征性例子，每一种都有它的应用场景。就像学会乐器，掌握得越高，你可以创造的音乐就更丰富。即使在复杂的系统下，不忘初心，向音乐出发！

## 队列

队列（Queue）：这是消息的队伍，要尽职尽责地等待消费者来领取。

## 消费者

消费者（Consumer）：最终的主角，他们就像是领奖的幸运儿，从队列中领取信息，然后进行处理。

## 如何建立生产过程

> 建立连接，得到一个 channel
> 声明交换机（简单模式，工作模式，可以不声明交换机；；；发布订阅，direct, topic）
> 声明一个队列
> 进行一个交换机和队列绑定
> 路由规则，决定交换机的消息什么情况到队列
> 生产消息，发给交换机和路由规则

创建一个生产过程有点像厨师做一个美味菜肴的步骤。就像要准备好原料、洗净、剁碎、炒煮一样，我们也有一些固定的步骤来制作一个“美味”的消息生产者。

1. **建立连接，得到一个 channel**：  
   这就是收集所有原料的步骤。我们需要创建 ConnectionFactory（连接工厂），然后通过它创建一个新的 Connection（连接），接着我们再从这个连接中获取 Channel（通道）。这个过程就像切洋葱一样，你得一层一层剥开才能获取到核心部分。
2. **声明交换机**：  
   现在是“洗菜”的步骤了。决定了你要使用的交换机类型（direct, topic, fanout 等），你现在可以声明你的交换机了，这就像预热烤箱一样，做好准备工作。
3. **声明一个队列**：  
   这就像准备一个碗来放你做好的菜。你需要告诉 RabbitMQ 你的消息要放在哪个队列里。
4. **交换机和队列的绑定**：  
   好了现在你可以开始做菜了。你需要告诉 RabbitMQ 你的交换机（你的锅虽然热乎乎的，但你需要添加你的原料）和队列的绑定关系，这样 RabbitMQ 就知道这个交换机的消息会被发送到哪个队列。
5. **制定路由规则**：  
   这个环节就好像你在调试你的菜一样，你根据你的口味添加更多的香料或者原料到菜里。这里的路由规则就是你的口味，他决定了你的交换机会在什么情况下把消息送到你的队列（碗）里。
6. **生产消息，发送给交换机和路由规则**：  
   所有事情都准备就绪，你可以开始享用你的美食了。这个步骤就是把你的消息（菜肴）通过 channel（你的勺子）发送到交换机，然后交换机根据你设置的路由规则决定如何把消息路由到正确的队列。

所以，创建一个生产者过程就像我们在厨房做一个美味的菜肴。不断地试验和修正，直到我们得到我们想要的结果。而最开心的是，我们做的菜肴通常不会太糟糕，因为我们始终有 RabbitMQ 这个料理师教程在旁边不断指导我们。

## 如何建立消费过程

> 建立连接，得到 channel
> 声明到哪个交换机
> 声明一个队列（可以消费端单独实现）
> 绑定
> 消费消息

感觉像这次我们是要做如何去品尝美食的指南！那很好，我们可以按照以下步骤行动：

1. **建立连接，得到 channel**：  
   就像去餐厅前要确保你们的预订一样，我们需要建立一个连接并从中获取 channel，这是你进入 RabbitMQ 的大门的钥匙，没有它就不能继续下去。
2. **声明交换机**：  
   这个环节就像你在餐桌上坐好并开始读菜单。你需要指定从哪个交换机接收消息，就想选择好你要品尝的美食。
3. **声明一个队列**：  
   好了，拿出手机打开外卖 App，选择想要的食物吧。这个步骤就是你告诉 RabbitMQ 你要从哪个队列（商家）消费消息（食物）。注意，如果你选择的队列还未被创建，那么 RabbitMQ 会自动为你创建一个。
4. **绑定**：  
   这一步就像你选择好食物后，按下“下单”按钮一样，你需要将你的队列和交换机绑定在一起，这样 RabbitMQ 才能知道它应该为你分发什么。
5. **消费消息**：  
   等待一段时间后，你的食物终于到了，你可以开始享用啦！通过 channel 和 queue 进行消费操作，就真的像在品尝美食一样了！注意，你需要告诉 RabbitMQ 你是否已经成功消费了消息。如果成功，你就返回一个 ack（应答），RabbitMQ 就会从队列中删除该消息。如果消费过程中发生错误，你就发送一个 nack 或者不发送 ack，那么 RabbitMQ 会尝试再次分发给你或者直接放弃。

这个消费者创建过程的例子感觉也很美味对吧？好比在享用美味大餐！

## 消费模式

> 简述几种消费模式，画图

消费模式有点像你选择在什么场合用餐。快餐？家庭晚餐？还是烛光晚餐？让我来给你介绍一下几种不同的 RabbitMQ 消费模式。

1. **简单模式**：  
   就像享用快速便捷的快餐，一个生产者发送消息给一个消费者，这就是最简单的模型。不过，人生不可能只有一种味道，对吧？
2. **工作模式**：  
   这是家庭晚餐的场景，一份食物，大家轮流品尝。在这个模式下，一个生产者，多个消费者，每个消费者获取到的消息是唯一的。RabbitMQ 默认使用轮询调度（Round-Robin Scheduling）方式来分发消息。
3. **发布订阅模式**：  
   这有点像举办一场大型晚宴，大家分享同样的食物。一条消息会被投递给所有的队列，消费者从自己的队列中获取消息，每个队列都有一个消费者来消费。这就是说，每个消费者都会接收到同样的消息。
4. **路由模式**：  
   这像是在自助餐厅，你可以根据自己的口味选择想要的食物。这个模式相比发布订阅模式，增加了路由功能。生产者在发送的时候定性 Routing key，消费者在绑定的时候也定性 Routing key，消息最后会投放到 Routing key 完全相同的队列里去。
5. **Topic 模式**：  
   最后，这像是去酒吧，不仅有食物，还有各种各样的鸡尾酒。Topic 模式就更加灵活，它让路由变得更加动态。队列和交换机之间的绑定会定义一种模式，然后 RabbitMQ 会将满足模式的所有消息路由给队列。

正如你在晚餐时可以根据您的心情和需求选择不同的餐饮模式一样，RabbitMQ 为你提供了各种模式来满足你的需求。

# 消息的消费

## 消费者缓冲区的设置

> Rabbitmq 推送，队列不断给消费者推送，push
> Kafka 就是 pull
> 默认情况，不断推送，消费者积压未处理消息，占用大量内存设置缓冲区，100~300，测试验证最大未确认消息数量阈值设置

消费者的缓冲区设置，这就像你在自助餐厅里为自己挑选食物的那个托盘。

RabbitMQ 默认是采用推送模式（push），意味着它会持续不断地推送消息到消费者，而不关注消费者的处理速度和能力。这就好比自助餐的厨师不断地将食物放进你的托盘，而不管你有没有空间装下。如果消费者处理消息的速度跟不上消息到来的速度，那么未处理的消息就会积累起来，占用大量内存。

为了避免这种情况，RabbitMQ 引入了流量控制机制，也就是我们可以设置消费者的缓冲区大小，或者说是“预取数”（prefetch count）。预取数可以限制 RabbitMQ 给消费者推送的未确认消息的数量。

例如，如果我们设置预取数为 100，那就意味着 RabbitMQ 在接收到消费者对一个消息的确认信号之前，最多只会向它推送 100 条消息。这就好像你的托盘只能装 100 个食物，不论厨师是否还有更多的食物，都必须在你的托盘有空间的时候再给你端上新的食物。

通过这种方式，RabbitMQ 可以确保消费者的缓冲区中消息的数量不会无限增长，避免了消费者因内存溢出而崩溃。

如何设置预取数呢？只需在 Consumer 对象上调用 basicQos 方法，传入你想设置的预取数即可，比如你的例子中是 100~300。但具体的预取数值应该根据实际的应用场景和消费者的处理能力进行测试和调整。

就这样，不论是在自助餐还是使用 RabbitMQ，我们都需要找到合适自己的那个“托盘大小”，以确保最佳的体验。

## 消息应答

应答
当队列收到 ack 之后，删除对应消息
自动应答
给到消费者，不需要主动 ack/nack，默认成功消费报错只能消费丢先
消费端故障，宕机了
手动应答（生产上）

主要去 ack/nack

Spring，实现消费者 destroy 方法，故障对将要 ack 的消息，完成




![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221259765.png)



![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221300040.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221301639.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221302672.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221303273.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221303649.png)

<!--more-->
