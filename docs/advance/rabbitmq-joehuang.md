---
title: rabbitmq-joehuang
date: 2023-12-22 12:57:14
Tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

# rabbitmq 的关键要素

## 建立连接

- 工厂、连接、通道：就像快乐大本营里的游戏一样，在 RabbitMQ 世界中，先要有一个工厂（ConnectionFactory）来生成连接（Connection），然后再由这些连接创建通道（Channel）。有了这些，才能开始我们的游戏大冒险，执行各种操作。
- Spring 管理：试图把建立连接这件事交给 Spring，就像请管家照看你的豪宅。可以说这是一种“富贵病”，但是它让你可以更专注于业务实现而不被底层细节所困扰。

## 生产者

生产者（Producer）：这就像是一台“魔法饲料机”，它生产出一条又一条消息，然后喂给 RabbitMQ。

## 交换机

### 交换机的功能

交换机（Exchange）：

- 交换机连接生产者和队列，就像在大型舞台上，把明星（生产者）和粉丝（队列）连接起来。没有交换机，RabbitMQ 就会变得非常"无聊"。
- 它具有路由功能，决定生产的消息，应该如何转发到哪一个队列里面去。就像邮政员一样，根据地址把信送到各个不同的邮箱中。

---

### 交换机的类型

交换机的类型有四种：直接交换机（Direct）、主题交换机（Topic）、头交换机（Headers）和扇形交换机（Fanout）。每种类型的交换机都有其独特的“解码能力”。

```shell
- 直接交换机：直接交换机就像一个严谨的检查员，只有当消息的路由键（Routing key）和绑定键一样时，才会将消息发送到对应的队列。也就是说，直接交换机是根据消息的“身份证”——路由键去找到它的“家”——队列。
- 主题交换机：主题交换机的处理方式更像一个精妙的填词游戏，它把消息通过模糊匹配的方式发送到队列。路由键可以是多个词，这些词之间用"."分隔，"_"%% 匹配一个词 %%，“#”匹配多个词（可以是零个）。比如，"log.error"的路由键能匹配到"_.error"和"log.#"的绑定键。
- 头交换机：头交换机是一个颇有洁癖的角色，不走寻常路。它根据消息内容中的 headers 属性进行匹配。在这种类型中，路由键实际上并没有被用到。
- 扇形交换机：  扇形交换机就像一个滔滔不绝的大嘴巴  ，它会把所有发送到该交换机的消息路由到所有与它绑定的队列。在这种类型下，如果设置了路由键，也会被忽略。
```

所以在这个“解码战舰”上，消息会被高效准确地分配去它们正确的“家”，即队列。对于 RabbitMQ 来说，找到一个适合你需求的交换机类型就像是找到了一个高效的邮政员，能把你的消息准确地送到它们应到达的地方。

---

假设你是一位艺术家，想要向粉丝发送你的新录音——这就是我们的消息。你的粉丝们如果要接收你的新录音，他们需要订阅你的“交换机”。

1. **Direct Exchange**：向你的粉丝们公告，只有在‘rock’类型中订阅的粉丝会收到你的新录音。在这种情况下，只有那些订阅了为‘rock’的队列会收到消息。就像你把乐团通告放在一个专门的‘rock music’的公告栏上，喜欢‘rock music’的人就可以看到。
2. **Fanout Exchange**：无论你的粉丝喜欢什么类型的音乐，他们都将收到你的新录音。这就是一种“广播”，所有订阅你的“交换机”的队列都会收到消息。就像你在一个巨大的广播站向全世界广播你的通告。
3. **Topic Exchange**：这时候，你可以允许你的粉丝在更详细的级别上订阅，比如‘_.rock._’。例如，那些订阅‘heavy.rock.guitars’的队列会接收到所有与‘heavy.rock.guitars’的消息，但那些只订阅‘rock’的则不会。就像你向所有热爱‘heavy rock guitars’的人进行发送，更具针对性。
4. **Headers Exchange**：这是一种更高级的场景，你可以根据消息内容中的‘headers’的属性来匹配和发送消息。比如你发送一段"Unplugged"系列的录音，标头可以设置为"{'style': 'unplugged'}"，那么所有队列的标头也设置为"{'style': 'unplugged'}"的，就能接收到录音。

以上就是四种交换机类型的象征性例子，每一种都有它的应用场景。就像学会乐器，掌握得越高，你可以创造的音乐就更丰富。即使在复杂的系统下，不忘初心，向音乐出发！

## 队列

队列（Queue）：这是消息的队伍，要尽职尽责地等待消费者来领取。

## 消费者

消费者（Consumer）：最终的主角，他们就像是领奖的幸运儿，从队列中领取信息，然后进行处理。

## 如何建立生产过程

> 建立连接，得到一个 channel
> 声明交换机（简单模式，工作模式，可以不声明交换机；；；发布订阅，direct, topic）
> 声明一个队列
> 进行一个交换机和队列绑定
> 路由规则，决定交换机的消息什么情况到队列
> 生产消息，发给交换机和路由规则

创建一个生产过程有点像厨师做一个美味菜肴的步骤。就像要准备好原料、洗净、剁碎、炒煮一样，我们也有一些固定的步骤来制作一个“美味”的消息生产者。

1. **建立连接，得到一个 channel**：  
   这就是收集所有原料的步骤。我们需要创建 ConnectionFactory（连接工厂），然后通过它创建一个新的 Connection（连接），接着我们再从这个连接中获取 Channel（通道）。这个过程就像切洋葱一样，你得一层一层剥开才能获取到核心部分。
2. **声明交换机**：  
   现在是“洗菜”的步骤了。决定了你要使用的交换机类型（direct, topic, fanout 等），你现在可以声明你的交换机了，这就像预热烤箱一样，做好准备工作。
3. **声明一个队列**：  
   这就像准备一个碗来放你做好的菜。你需要告诉 RabbitMQ 你的消息要放在哪个队列里。
4. **交换机和队列的绑定**：  
   好了现在你可以开始做菜了。你需要告诉 RabbitMQ 你的交换机（你的锅虽然热乎乎的，但你需要添加你的原料）和队列的绑定关系，这样 RabbitMQ 就知道这个交换机的消息会被发送到哪个队列。
5. **制定路由规则**：  
   这个环节就好像你在调试你的菜一样，你根据你的口味添加更多的香料或者原料到菜里。这里的路由规则就是你的口味，他决定了你的交换机会在什么情况下把消息送到你的队列（碗）里。
6. **生产消息，发送给交换机和路由规则**：  
   所有事情都准备就绪，你可以开始享用你的美食了。这个步骤就是把你的消息（菜肴）通过 channel（你的勺子）发送到交换机，然后交换机根据你设置的路由规则决定如何把消息路由到正确的队列。

所以，创建一个生产者过程就像我们在厨房做一个美味的菜肴。不断地试验和修正，直到我们得到我们想要的结果。而最开心的是，我们做的菜肴通常不会太糟糕，因为我们始终有 RabbitMQ 这个料理师教程在旁边不断指导我们。

## 如何建立消费过程

> 建立连接，得到 channel
> 声明到哪个交换机
> 声明一个队列（可以消费端单独实现）
> 绑定
> 消费消息

感觉像这次我们是要做如何去品尝美食的指南！那很好，我们可以按照以下步骤行动：

1. **建立连接，得到 channel**：  
   就像去餐厅前要确保你们的预订一样，我们需要建立一个连接并从中获取 channel，这是你进入 RabbitMQ 的大门的钥匙，没有它就不能继续下去。
2. **声明交换机**：  
   这个环节就像你在餐桌上坐好并开始读菜单。你需要指定从哪个交换机接收消息，就想选择好你要品尝的美食。
3. **声明一个队列**：  
   好了，拿出手机打开外卖 App，选择想要的食物吧。这个步骤就是你告诉 RabbitMQ 你要从哪个队列（商家）消费消息（食物）。注意，如果你选择的队列还未被创建，那么 RabbitMQ 会自动为你创建一个。
4. **绑定**：  
   这一步就像你选择好食物后，按下“下单”按钮一样，你需要将你的队列和交换机绑定在一起，这样 RabbitMQ 才能知道它应该为你分发什么。
5. **消费消息**：  
   等待一段时间后，你的食物终于到了，你可以开始享用啦！通过 channel 和 queue 进行消费操作，就真的像在品尝美食一样了！注意，你需要告诉 RabbitMQ 你是否已经成功消费了消息。如果成功，你就返回一个 ack（应答），RabbitMQ 就会从队列中删除该消息。如果消费过程中发生错误，你就发送一个 nack 或者不发送 ack，那么 RabbitMQ 会尝试再次分发给你或者直接放弃。

这个消费者创建过程的例子感觉也很美味对吧？好比在享用美味大餐！

## 消费模式

> 简述几种消费模式，画图

消费模式有点像你选择在什么场合用餐。快餐？家庭晚餐？还是烛光晚餐？让我来给你介绍一下几种不同的 RabbitMQ 消费模式。

1. **简单模式**：  
   就像享用快速便捷的快餐，一个生产者发送消息给一个消费者，这就是最简单的模型。不过，人生不可能只有一种味道，对吧？
2. **工作模式**：  
   这是家庭晚餐的场景，一份食物，大家轮流品尝。在这个模式下，一个生产者，多个消费者，每个消费者获取到的消息是唯一的。RabbitMQ 默认使用轮询调度（Round-Robin Scheduling）方式来分发消息。
3. **发布订阅模式**：  
   这有点像举办一场大型晚宴，大家分享同样的食物。一条消息会被投递给所有的队列，消费者从自己的队列中获取消息，每个队列都有一个消费者来消费。这就是说，每个消费者都会接收到同样的消息。
4. **路由模式**：  
   这像是在自助餐厅，你可以根据自己的口味选择想要的食物。这个模式相比发布订阅模式，增加了路由功能。生产者在发送的时候定性 Routing key，消费者在绑定的时候也定性 Routing key，消息最后会投放到 Routing key 完全相同的队列里去。
5. **Topic 模式**：  
   最后，这像是去酒吧，不仅有食物，还有各种各样的鸡尾酒。Topic 模式就更加灵活，它让路由变得更加动态。队列和交换机之间的绑定会定义一种模式，然后 RabbitMQ 会将满足模式的所有消息路由给队列。

正如你在晚餐时可以根据您的心情和需求选择不同的餐饮模式一样，RabbitMQ 为你提供了各种模式来满足你的需求。

# 消息的消费

## 消费者缓冲区的设置

> Rabbitmq 推送，队列不断给消费者推送，push
> Kafka 就是 pull
> 默认情况，不断推送，消费者积压未处理消息，占用大量内存设置缓冲区，100~300，测试验证最大未确认消息数量阈值设置

消费者的缓冲区设置，这就像你在自助餐厅里为自己挑选食物的那个托盘。

RabbitMQ 默认是采用推送模式（push），意味着它会持续不断地推送消息到消费者，而不关注消费者的处理速度和能力。这就好比自助餐的厨师不断地将食物放进你的托盘，而不管你有没有空间装下。如果消费者处理消息的速度跟不上消息到来的速度，那么未处理的消息就会积累起来，占用大量内存。

为了避免这种情况，RabbitMQ 引入了流量控制机制，也就是我们可以设置消费者的缓冲区大小，或者说是“预取数”（prefetch count）。预取数可以限制 RabbitMQ 给消费者推送的未确认消息的数量。

例如，如果我们设置预取数为 100，那就意味着 RabbitMQ 在接收到消费者对一个消息的确认信号之前，最多只会向它推送 100 条消息。这就好像你的托盘只能装 100 个食物，不论厨师是否还有更多的食物，都必须在你的托盘有空间的时候再给你端上新的食物。

通过这种方式，RabbitMQ 可以确保消费者的缓冲区中消息的数量不会无限增长，避免了消费者因内存溢出而崩溃。

如何设置预取数呢？只需在 Consumer 对象上调用 basicQos 方法，传入你想设置的预取数即可，比如你的例子中是 100~300。但具体的预取数值应该根据实际的应用场景和消费者的处理能力进行测试和调整。

就这样，不论是在自助餐还是使用 RabbitMQ，我们都需要找到合适自己的那个“托盘大小”，以确保最佳的体验。

## 消息应答

消息的应答机制就像你在商店购买物品后，付款并拿到收据的过程。这就是 rabbitmq 的消息确认机制，主要分为以下几点：

1. **应答（Acknowledgment）**：  
   当 RabbitMQ 投递消息给消费者之后，它需要知道消息是否成功到达。消费者会发送一个应答（ACK）告诉 RabbitMQ 已经成功接收并处理了这些消息。这就像你告诉店员：“好的，我已经拿到货物了。”
2. **消息删除**：  
   当 RabbitMQ 收到 ACK 后，它会删除队列中的对应消息，就像销母我们在售货员手中的货物记录一样。
3. **自动应答**：  
   这种方式是 RabbitMQ 默认的应答模式，也叫做自动确认。当消息一旦被投递，消费者会立刻回送 ACK，无需等待消费者实际处理完消息。这就好像你一拿到货就告诉售货员我已经确认，但实际上你还没检查货物。
4. **消费者异常**：  
   但是在自动应答模式下，如果消费者在处理消息的过程中发生故障宕机了该怎么办？MQ 无从得知，已发出的消息就会丢失。这就像当你拿到货走到门口时撞到门槛摔倒，还没来得及确认货物的情况，结果货物就丢了。
5. **手动应答**：  
   因此，在生产环境中，推荐使用手动应答。消费者处理完消息后，再发送确认信息。如果消费者在处理消息过程中宕机，未发送确认信号的消息则会被 RabbitMQ 重新投递。这就像你认真检查货物后才确认并告诉售货员：“我已经确认，货物没问题。”
6. **实现确认机制**：  
   在 Spring 中，我们可以在消费者（Listener）代码里面调用 Channel 的 basicAck 方法来发送 ACK。如果我们需要在业务处理成功后确认，那么我们可以保证消息一定被正确处理。

所以总体来说，消息的应答机制就是一个有保障的处理流程，确保了消息一定会被正确处理，不会丢失。这不仅可以让我们更加安心，也保证了我们的消息通信的稳定可靠！

## 幂等性

1. **何为幂等性**:  
   幂等性在计算中主要指的是一次和多次请求某一个资源应该具有同样的副作用。简单点说，就像你多次点击电梯按钮，无论你点击一次或者狂点 1000 次，电梯都只会来一次。这就是幂等性，它确保了重复执行操作，结果都是一致的。
2. **消息重复发送，也是成功消费 1 条**:  
   在 RabbitMQ 中，可能会因为网络问题，消费者处理速度，甚至是 RabbitMQ 的内部错误，可能导致消息被重复发送。但如果我们实现了幂等性，就能保证即便消息被重复消费，应用的状态也不会改变，就像你不断按电梯按钮，电梯也只会来一次。
3. **如何解决**:  
   如何保证幂等性呢？其实有很多方法。例如，我们可以使用 Redis 的 SETNX 命令来做，SETNX 会先检查这个 key 是否存在，如果不存在，那么设置值，如果存在，那么不会进行设置。这样我们就只会处理一个消息。

   另外，也可以在消费端维护一个计数器。每当消费一个消息，就将消息的 id 和消费状态存入一个数据表中，只有当消费状态为未处理时，我们才真正去消费该消息。

   这两种方法都是为了确保我们的程序在处理消息时，能够保证消费操作的幂等性。

## 如何保证生产消息高可用

提高消息的高可用性，像是你在备好不同的道具来做一道丰富可口的料理。那好，让我们开始这个旅程吧！

1. **生产 ACK 的流程（发布确认流程）**：  
   在发布消息前，我们需要先建立一个连接。就像你首先要回到你的厨房一样，这个步骤就是创建一个连接到 RabbitMQ 的信道（Channel）。然后生产者开始生成消息，这时候信道会帮每条消息创建一个唯一的 id，然后 RabbitMQ 收到消息后会返回一个 ACK 或 NACK，并带上这个 id。这就像你做好了每道菜，然后餐厅的服务员会告诉你，这道菜是否成功送达每一个顾客。
2. **单个确认，批量确认**：  
   生产者可以选择单个确认还是批量确认。单个确认意味着每发送一条消息就收到确认，批量确认则是指定一个数量，只有当这个数量的消息都发送出去后才收到确认。这就像煮饭，你可以选择每完成一道菜就试一下味道，或者一口气做完几道菜再试。
3. **异步方式的实现**：  
   对于高并发的环境，异步确认更加有优势。因为它在确认消息的过程中不会阻塞其他操作，也就是说，生产者在等待确认的同时，还可以继续发送其他消息。这就像你在等待一道菜炖的时候，可以处理另一道菜一样，效率更高。
4. **备份交换机**：  
   这是一个进阶的方案。如果你的主交换机因为某种原因无法正常工作，RabbitMQ 可以自动将消息路由到备份交换机。这样即使出现问题，消息也不会丢失。这就像是餐馆里有源源不断的食材供应，即使你手上的一部分食材出了问题，你也能从其他地方拿到新的食材来继续做菜。

通过以上步骤，我们可以实现消息的高可用性，这就像用不同的工具和方法来烹饪一道好菜一样，只要我们精心准备，掌握每一个环节，就可以做出我们自己的杰作。

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221259765.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221302672.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221303273.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221303649.png)

<!--more-->
