---
title: jvm-joehuang
date: 2023-12-22 14:36:27
Tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

## JVM

JVM，也就是 Java 虚拟机，可以说是 Java 程序的执行引擎。它负责将 Java 源代码编译成能在特定平台上运行的字节码，这样就能在不同的设备上无缝运行。

JVM 也有自己的内存管理系统，负责内存的分配和回收，确保程序运行的高效性和稳定性。

简单来说，JVM 就像是 Java 程序和计算机硬件之间的桥梁，让 Java 代码能够在各种环境中运行。

## JVM、JRE、JDK 分别是什么关系？

JVM 是 Java 虚拟机，是 Java 程序的执行引擎；
JRE 是 Java 运行时环境，包含了 JVM 和 Java 程序运行所需的核心类库；而 JDK 则是 Java 开发工具包，里面集成了 JRE，也包含了开发 Java 程序所需的编译器、调试器等开发工具。

想象成房子吧，JVM 就是房子的框架，JRE 是房子的基础和结构，而 JDK 则是整个房子，包括了框架、基础和装修。

在开发 Java 程序时，需要 JDK 来编写代码、编译和运行程序；
而在运行 Java 程序时，只需要 JRE，因为它包含了程序运行所需的环境和库。

## JVM 的内存模型

JVM 的内存模型描述了在运行 Java 程序时，JVM 如何组织和管理内存。它包括了不同的内存区域，每个区域都有自己的作用和特点。

### 1. 内存模型的内容和作用

- **方法区（Method Area）**：用来存储类结构信息、常量、静态变量等。在 Java 8 之前，这里还有永久代（PermGen），但在 Java 8 后被元空间（Metaspace）所取代。
- **堆（Heap）**：存放对象实例，是被所有线程共享的内存区域。通过垃圾回收来管理，主要分为新生代（Young Generation）和老年代（Old Generation）等不同区域。
- **栈（Stack）**：每个线程都有自己的栈，存储局部变量、方法调用、部分结果等。栈分为**虚拟机栈**和**本地方法栈**。虚拟机栈用于存储方法调用和局部变量，而本地方法栈是针对 Native 方法服务的。
- **程序计数器（Program Counter Register）**：存储当前线程执行的字节码指令地址，也就是当前线程所执行的位置。

### 2. 两种栈

- **虚拟机栈（Java Virtual Machine Stack）**：用于存储方法执行过程中的局部变量、操作数栈、动态链接、方法出口等信息。
- **本地方法栈（Native Method Stack）**：与虚拟机栈类似，但是服务于 Native 方法。

### 3. 堆和栈的区别

- **堆**是用于存放对象实例的区域，通过垃圾回收机制进行管理，是所有线程共享的内存区域。
- **栈**是为每个线程分配的内存区域，用于存放线程私有的局部变量、方法调用等信息。

### 4. 1.6 到 1.8 的区域变化

在 Java 1.6 到 1.8 中，最大的变化是元空间（Metaspace）取代了永久代（PermGen）。永久代存放类的元数据信息、字符串常量池等，在大量使用动态生成类的场景下容易出现 PermGen Space 内存溢出。元空间使用的是本地内存，解决了永久代的一些限制，但需要注意控制元空间的大小，以防止系统内存被耗尽。

## 内存的两种分配方式，以及如何保证分配内存是线程安全

在内存管理中，有两种主要的分配方式：指针碰撞（Bump Pointer）和空闲列表（Free List）。

1. **指针碰撞（Bump Pointer）**：在内存中，堆空间被划分为已使用和未使用的部分。当使用指针碰撞方式时，内存中有一个指针（称为“分配指针”），用于标记未使用内存的起始位置。当需要分配内存时，JVM 通过移动这个分配指针来分配内存，把分配指针后移相应大小的空间，指向分配后的内存起始位置。这种方式要求堆内存空间的分配是连续的，因为分配指针需要持续移动。
2. **空闲列表（Free List）**：与指针碰撞不同，空闲列表方式不要求内存空间必须是连续的。它将空闲的内存空间以链表的形式组织起来，记录每块内存的大小和是否可用。当需要分配内存时，JVM 会在空闲列表中寻找合适大小的空闲块，然后标记为已分配。当内存释放时，将被释放的内存块加入到空闲列表中，以便后续分配使用。

为了保证内存分配的线程安全性，通常采取以下策略：

- **线程封闭（Thread Confinement）**：每个线程分配独立的内存区域，避免多线程之间的竞争。
- **加锁（Locking）**：使用锁机制来保证在分配或释放内存时只有一个线程可以操作，保证操作的原子性和互斥性。
- **CAS（Compare and Swap）**：使用 CAS 操作确保对内存的原子性操作，避免并发冲突。
- **空闲列表的并发处理**：在多线程环境中，对空闲列表的操作需要考虑并发性，使用适当的同步机制来保证线程安全。

这些方法可以帮助确保内存分配的线程安全性，以防止不同线程之间出现竞争条件或数据不一致的情况。

---

当我们写程序时，计算机需要地方来存储数据。就像是一个房子要安置家具一样，计算机要存放程序需要的数据。有两种主要的方式来安排这个存储空间：

1. **指针碰撞（Bump Pointer）**：就像是有一块空地，我们用一个箭头指着可以放家具的地方。每当需要放一个新的东西，箭头就会指向下一个空地，这样就能一个一个地放进去。
2. **空闲列表（Free List）**：这个方式像是一张列表，上面记录了哪些地方有空地可放家具。当需要放东西时，就找到列表上一个空地，然后把东西放进去，同时在列表上做标记说这个地方已经有东西了。

为了确保多个人同时放东西不乱套，我们有几个办法：

- **每个人有自己的地盘**：就像是每个人有自己的房间一样，不会和别人抢一个地方放东西。
- **有人指挥大家放东西**：就像有一个管理者，大家想放东西的时候得先问问他，这样不会乱成一团。
- **大家轮流来放东西**：每次只有一个人能放东西，其他人得等着，这样不会同时抢着放东西。

这些方法保证了放置家具时不会出现混乱，每个家具都能被安排到合适的地方。就像是大家有规矩和秩序一样，保证了数据存储的顺利进行。

## 类和对象加载

### 类加载和对象创建的关系

类加载和对象创建的关系，是个很奇妙的话题。我喜欢将类加载看作是建立蓝图，而创建对象就像使用这个蓝图建造房子。

首先，类加载器负责找到你的蓝图（也就是类的字节码文件），然后解析它，然后准备好相关的材料，最后生产出一份可以用来建造房子的蓝图。这个过程就是“加载”、“链接”和“初始化”。

然后，每当你实例化一个新对象（也就是 new 一个对象）时，Java 就会根据这个蓝图在内存中划出一块空间，再按照蓝图上的设计进行建造，也就是给这个对象的各个属性赋值，完成了你房子的建造，得到了一个新的对象。

### 有几种类加载噐
类加载器主要有以下几种：

  

1. 引导类加载器（Bootstrap）
2. 扩展类加载器（Extension）
3. 系统类加载器或应用类加载器（System或Application）
4. 自定义类加载器（Custom）
### 类的加载过程


### 什么是双亲委派模式

对象的创建方式

对象的构造过程

对象的内部构造

对象头里面有什么

对象的两种访问方式

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221436675.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221436666.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221437781.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221437842.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221438964.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221438235.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221439236.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221439851.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221440185.png)

最后一节实战可以用

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221440926.png)

<!--more-->

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221441263.png)
