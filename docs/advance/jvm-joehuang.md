---
title: jvm-joehuang
date: 2023-12-22 14:36:27
Tags:
  - tech
Draft: true
HideInList: false
Feature: 
IsTop: false
---

## JVM

JVM，也就是 Java 虚拟机，可以说是 Java 程序的执行引擎。它负责将 Java 源代码编译成能在特定平台上运行的字节码，这样就能在不同的设备上无缝运行。

JVM 也有自己的内存管理系统，负责内存的分配和回收，确保程序运行的高效性和稳定性。

简单来说，JVM 就像是 Java 程序和计算机硬件之间的桥梁，让 Java 代码能够在各种环境中运行。

## JVM、JRE、JDK 分别是什么关系？

JVM 是 Java 虚拟机，是 Java 程序的执行引擎；
JRE 是 Java 运行时环境，包含了 JVM 和 Java 程序运行所需的核心类库；而 JDK 则是 Java 开发工具包，里面集成了 JRE，也包含了开发 Java 程序所需的编译器、调试器等开发工具。

想象成房子吧，JVM 就是房子的框架，JRE 是房子的基础和结构，而 JDK 则是整个房子，包括了框架、基础和装修。

在开发 Java 程序时，需要 JDK 来编写代码、编译和运行程序；
而在运行 Java 程序时，只需要 JRE，因为它包含了程序运行所需的环境和库。

## JVM 的内存模型

JVM 的内存模型描述了在运行 Java 程序时，JVM 如何组织和管理内存。它包括了不同的内存区域，每个区域都有自己的作用和特点。

### 1. 内存模型的内容和作用

- **方法区（Method Area）**：用来存储类结构信息、常量、静态变量等。在 Java 8 之前，这里还有永久代（PermGen），但在 Java 8 后被元空间（Metaspace）所取代。
- **堆（Heap）**：存放对象实例，是被所有线程共享的内存区域。通过垃圾回收来管理，主要分为新生代（Young Generation）和老年代（Old Generation）等不同区域。
- **栈（Stack）**：每个线程都有自己的栈，存储局部变量、方法调用、部分结果等。栈分为**虚拟机栈**和**本地方法栈**。虚拟机栈用于存储方法调用和局部变量，而本地方法栈是针对 Native 方法服务的。
- **程序计数器（Program Counter Register）**：存储当前线程执行的字节码指令地址，也就是当前线程所执行的位置。

### 2. 两种栈

- **虚拟机栈（Java Virtual Machine Stack）**：用于存储方法执行过程中的局部变量、操作数栈、动态链接、方法出口等信息。
- **本地方法栈（Native Method Stack）**：与虚拟机栈类似，但是服务于 Native 方法。

### 3. 堆和栈的区别

- **堆**是用于存放对象实例的区域，通过垃圾回收机制进行管理，是所有线程共享的内存区域。
- **栈**是为每个线程分配的内存区域，用于存放线程私有的局部变量、方法调用等信息。

### 4. 1.6 到 1.8 的区域变化

在 Java 1.6 到 1.8 中，最大的变化是元空间（Metaspace）取代了永久代（PermGen）。永久代存放类的元数据信息、字符串常量池等，在大量使用动态生成类的场景下容易出现 PermGen Space 内存溢出。元空间使用的是本地内存，解决了永久代的一些限制，但需要注意控制元空间的大小，以防止系统内存被耗尽。

## 内存的两种分配方式，以及如何保证分配内存是线程安全

在内存管理中，有两种主要的分配方式：指针碰撞（Bump Pointer）和空闲列表（Free List）。

1. **指针碰撞（Bump Pointer）**：在内存中，堆空间被划分为已使用和未使用的部分。当使用指针碰撞方式时，内存中有一个指针（称为“分配指针”），用于标记未使用内存的起始位置。当需要分配内存时，JVM 通过移动这个分配指针来分配内存，把分配指针后移相应大小的空间，指向分配后的内存起始位置。这种方式要求堆内存空间的分配是连续的，因为分配指针需要持续移动。
2. **空闲列表（Free List）**：与指针碰撞不同，空闲列表方式不要求内存空间必须是连续的。它将空闲的内存空间以链表的形式组织起来，记录每块内存的大小和是否可用。当需要分配内存时，JVM 会在空闲列表中寻找合适大小的空闲块，然后标记为已分配。当内存释放时，将被释放的内存块加入到空闲列表中，以便后续分配使用。

为了保证内存分配的线程安全性，通常采取以下策略：

- **线程封闭（Thread Confinement）**：每个线程分配独立的内存区域，避免多线程之间的竞争。
- **加锁（Locking）**：使用锁机制来保证在分配或释放内存时只有一个线程可以操作，保证操作的原子性和互斥性。
- **CAS（Compare and Swap）**：使用 CAS 操作确保对内存的原子性操作，避免并发冲突。
- **空闲列表的并发处理**：在多线程环境中，对空闲列表的操作需要考虑并发性，使用适当的同步机制来保证线程安全。

这些方法可以帮助确保内存分配的线程安全性，以防止不同线程之间出现竞争条件或数据不一致的情况。

---

当我们写程序时，计算机需要地方来存储数据。就像是一个房子要安置家具一样，计算机要存放程序需要的数据。有两种主要的方式来安排这个存储空间：

1. **指针碰撞（Bump Pointer）**：就像是有一块空地，我们用一个箭头指着可以放家具的地方。每当需要放一个新的东西，箭头就会指向下一个空地，这样就能一个一个地放进去。
2. **空闲列表（Free List）**：这个方式像是一张列表，上面记录了哪些地方有空地可放家具。当需要放东西时，就找到列表上一个空地，然后把东西放进去，同时在列表上做标记说这个地方已经有东西了。

为了确保多个人同时放东西不乱套，我们有几个办法：

- **每个人有自己的地盘**：就像是每个人有自己的房间一样，不会和别人抢一个地方放东西。
- **有人指挥大家放东西**：就像有一个管理者，大家想放东西的时候得先问问他，这样不会乱成一团。
- **大家轮流来放东西**：每次只有一个人能放东西，其他人得等着，这样不会同时抢着放东西。

这些方法保证了放置家具时不会出现混乱，每个家具都能被安排到合适的地方。就像是大家有规矩和秩序一样，保证了数据存储的顺利进行。

## 类和对象加载

### 类加载和对象创建的关系

类加载和对象创建的关系，是个很奇妙的话题。我喜欢将类加载看作是建立蓝图，而创建对象就像使用这个蓝图建造房子。

首先，类加载器负责找到你的蓝图（也就是类的字节码文件），然后解析它，然后准备好相关的材料，最后生产出一份可以用来建造房子的蓝图。这个过程就是“加载”、“链接”和“初始化”。

然后，每当你实例化一个新对象（也就是 new 一个对象）时，Java 就会根据这个蓝图在内存中划出一块空间，再按照蓝图上的设计进行建造，也就是给这个对象的各个属性赋值，完成了你房子的建造，得到了一个新的对象。

### 有几种类加载噐

类加载器主要有以下几种：

1. 引导类加载器（Bootstrap）
2. 扩展类加载器（Extension）
3. 系统类加载器或应用类加载器（System 或 Application）
4. 自定义类加载器（Custom）

### 类的加载过程

加载类的过程包括：

1. 加载：找到并加载字节码文件，生成一个 Class 对象。
2. 链接：包括验证、准备和解析

   - 验证确保类文件的正确性。
   - 准备阶段为静态变量分配内存。
   - 解析将符号引用替换为直接引用。

3. 初始化：为静态变量赋值并执行静态块。

总的来说，类加载和对象创建就像是一场精心的建筑大赛，类加载器是设计师，负责设计并提供蓝图，然后在需要的时候根据蓝图建造出对象，就像一堆堆房子一样，并且用一种巧妙的方法保证了每个蓝图和房子加载的正确性和安全性。

### 什么是双亲委派模式

双亲委派模型是一种类加载机制：如果一个类加载器接受了一个加载类的请求，它会先将这个请求委托给父类加载器。这个过程一直向上递归，如果父类加载器可以完成类加载任务，就成功返回；否则，子类加载器尝试自己去加载。

### 对象的创建方式

创建对象，就好像在烹饪一道美味的菜肴。你需要选好食材，研究做法，然后一步一步“炖烧”出来。

在 Java 中，创建对象主要有以下几种方式:

1. 使用`new`关键字：这是我们最常用的一种方式，`new`后面紧跟类的构造函数。
2. 使用`clone`方法：这种方式是从一个已经存在的对象中创建一个一模一样的新对象。
3. 使用反射`Class`类的`newInstance`方法：这种方式可以动态地创建对象。
4. 使用`ObjectInputStream`类的`readObject`方法，即反序列化方式。

### 对象的构造过程

那么，对象的构造过程是食材烹饪的过程：首先，调用父类的构造函数，就像在准备食材。然后，初始化成员变量，就像在烹饪中炖烧。最后，在构造函数中做一些后续的处理，就像在炖烧后调整味道。

### 对象的内部构造

说到对象的内部构造，这就好比一道菜的内在风味。一个对象的内部主要由对象头、实例数据和对齐填充部分构成。

### 对象头里面有什么

对象头包含了对象的哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等信息。实例数据则是我们定义的各种类型的字段内容。对齐填充部分不存在特定的数据，主要是为了满足某些内存对齐的需求。

### 对象的两种访问方式

对象的访问方式，有两种：句柄访问和直接指针访问。

句柄访问就像我们请人代购食材，我们给这个人（句柄）食材的清单，这个人去仓库（堆内存）找到食材并交给我们。

而直接指针访问，则是我们直接拿着食材清单去仓库找到食材。

两种方式各有优缺点，但主要的区别在于是否需要找这个“代购”的人。

---

**句柄访问：**  
优点：安全性高，如果你想要找到一道菜（一个对象），需要句柄（代理人）的帮忙，就像你需要找到那个掌管所有菜肴的厨师。即使你的菜肴位置发生变化（类似于 GC 的内存整理），句柄（代理人）仍能找到正确的位置，因为句柄和对象的链接始终不变。所以，句柄访问无需关心对象的地址变换，它永远保持与对象的连接。

缺点：访问速度慢，你得先找到这个厨师（句柄），然后再通过厨师找到你的菜肴（对象）。这就相当于你需要做两次跳转，首先找到句柄，再由句柄找到对象，这会比直接找到对象更慢一些。

**直接指针访问：**  
优点：访问速度快，因为你直接知道菜肴（对象）在哪里，你可以直接去拿，无需经过厨师（句柄）。

缺点：安全性较低，如果你的菜肴被移动到其他地方了（比如在内存压缩时），你需要自己去找新的位置，因为你直接持有的是那道菜肴（对象）的地址。

---

在 Java 中，所有的对象引用都是通过句柄或者直接指针的方式进行访问的。这两种方式的选择，其实主要是由 Java 虚拟机的实现决定的，对于 Java 程序员来说是透明的。也就是说，你写的 Java 代码并不会直接受影响。但是，了解这些机制可以帮助你更好地理解程序的运行原理，比如内存管理和垃圾回收等。

实际上，大多数商业级别的 Java 虚拟机（比如 HotSpot），由于考虑到性能因素，选择了直接指针访问的方式。但在处理垃圾回收时，需要对这些对象地址进行更新，以保证引用的有效性。

---

## 垃圾回收

### 几种垃圾回收算法

**1. 标记-清理（Mark-Sweep）算法**  
这个算法的过程就像一家清洁公司，先由员工（垃圾回收器）标记哪些是垃圾，然后清理这些标记过的垃圾。

优点：能回收大部分垃圾，避免了内存的浪费。

缺点：标记和清理过程效率较低，清理后会产生不连续的内存碎片。

**2. 标记-复制（Mark-Copy）算法**  
这个算法像是在两个房间之间移动物品，首先标记出哪些是有用的，然后将这些有用的物品复制到另一个空房间，最后清空原房间的所有物品。

优点：没有内存碎片，因为有用的对象都被复制到另一边。

缺点：需要额外的内存空间，来存储复制过来的对象。

**3. 标记-整理（Mark-Compact）算法**  
这个是标记-清理算法的升级版，类似于清洁公司改进后的操作，标记垃圾后，会将所有的有用物品向一边移动，然后清除剩余的垃圾。

优点：既可以回收垃圾，又避免了内存碎片。

缺点：移动对象需要更多的时间。

**4. 分代（Generational）收集算法**  
这个算法就像将垃圾分为易腐垃圾和干垃圾一样，分别处理。将对象根据生命周期分为新生代和老年代，使用不同的算法进行回收。

优点：节省时间，针对不同类型的垃圾采用最合适的方式清理。

### JVM 有哪些垃圾收集器，分别有什么特点

**1. Serial 收集器（串行收集器）**  
这个收集器就像是一位厨师，一点一点地做着所有的事情，因此它是单线程的。它使用"复制"算法清理新生代，使用"标记-整理"算法清理老年代。由于其单线程的原因，这个收集器适用于内存较小的情况。

**2. Parallel 收集器（并行收集器）**  
Parallel 收集器如同一个团队的厨师一起清理垃圾，因此它是多线程的。同时也使用“复制“算法清理新生代，使用"标记-整理"算法清理老年代。这个收集器适用于多核服务器环境。

**3. CMS (Concurrent Mark Sweep) 收集器**  
CMS 收集器就像一个熟练的厨师，边烹饪边清理垃圾，也就是它尽量减少停顿时间，主要适用于老年代的回收。基于“标记-清理“算法，它的主要过程包括"初始标记"，"并发标记"，"重新标记"，"并发清理"。

优点：并发收集、低停顿

缺点：对 CPU 资源非常敏感，可能会产生大量内存碎片。

**4. G1 (Garbage-First) 收集器**  
G1 是一位更先进的厨师，他将内存划分为多个独立的小块，然后优先处理那些”垃圾“最多的小块。这就是 G1 名称的由来：Garbage-First。它使用了“标记-整理"算法，采用并行与并发的方式，整体上看是基于"标记-整理"算法，但局部（两个 Region 之间）上又是基于"复制"算法。

优点：并行并发收集，分区回收，预测停顿模型。

---

**5. ZGC，全名 Z Garbage Collector，是从 JDK 11 开始引入的一种全新的垃圾收集器。**

ZGC 的设计目标是在 TB 级别甚至 PB 级别的内存中提供低延迟。因此，ZGC 适合需要处理大量数据和需要低停顿时间的应用，如实时系统或大型机器学习应用。

ZGC 就像一个掌握了高阶技巧的大厨，采用了分区并行、并发、压缩的垃圾回收机制。它将 Java 堆划分为许多小的固定大小的区域，每个区域能被单独地管理和回收。这样，只需要部分停顿来回收垃圾，可以实现预期不到 10ms 的暂停时间，即使是在几 TB 的堆内存中也可以实现这个目标。并且，它能对空闲的分区进行压缩，从而更有效地利用内存。

ZGC 的工作过程包括以下步骤：

1. **并发标记**：ZGC 开始标记根对象，然后再并发地标记其他从根对象可达的对象。
2. **并发预处理**：为后续的步骤做准备，比如为存活对象的重定位更新指针等。
3. **并发标记与重定位**：ZGC 进一步标记对象，为存活的对象构建新的位置。
4. **并发重定位**：最后，ZGC 会移动对象到新位置，并清理掉不再需要的空间。

ZGC 用这种新颖的方法来处理内存中的垃圾，正如一位擅长创新的大厨用独特的方法去调制美食一样， 使其成为 Java 世界中一颗新的、闪耀的明星。

### 强引用、软应用、弱引用

> 在垃圾回收时的表现

> 让我们像在一个影院看四场连续电影一样，一起探讨一下强引用、软引用、弱引用和虚引用在 Java 中的表现吧！

**1. 强引用**：强引用就像是一部精彩的大片，观众们（垃圾回收器）从来不会在中途离场。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。它就像一条坚不可摧的链子，将对象紧紧锁在内存当中。

**2. 软引用**：软引用像是一部获奖电影。虽然有一些人可能会在中途离席，但大多数人会留至最后。只有在内存不足的时候，垃圾回收器才会在必要的时候回收掉软引用的对象。但在下一次判断时，只要内存还足，软引用依旧能保留其对应的对象。

**3. 弱引用**：弱引用就像一部被批评家评价为“口碑平平”的电影。观众们大都不愿看完全场，很可能在中途离开。垃圾回收器在进行任何一次垃圾回收操作时都会立刻回收掉只被弱引用关联的对象。

**4. 虚引用**：虚引用就像是一部还未上映的电影预告片。除了告诉你它即将上映，你什么也看不到。虚引用的存在，不会影响对象的生命周期。主要用来在被回收时收到一个系统通知。

这就是 Java 中的四种引用类型，每种引用类型在垃圾回收时都有不同的表现。就像选择看电影一样，你可以根据需要选择最合适的引用类型用于你的程序中。

### 什么情况下触发 Full GC？什么是担保机制

Full GC 是一个超级清洁工人的电调，当具有以下情况出现时，这个电调就会响起：

1. **系统调用**：当你的程序调用了 System.gc()时，系统会尝试执行 Full GC。但是，注意一点，这只是"尝试"，并不一定会立即生效，具体还要看 JVM。
2. **老年代空间不足**：如果老年代空间不足以放入新的对象，也将触发 Full GC。
3. **方法区空间不足**：当方法区空间不足时，也会触发 Full GC。
4. **CMS GC 时的 Concurrent Mode Failure 和 CMS GC 后预测到 Old 区域无法放下所有 Survivor**：也就是说，假设出现了并发模式失败，或者 CMS 预测到 Old 区无法放置所有的年轻代对象，也会影响 Full GC。

现在说说**担保机制**，它好比是一个飞行员的降落伞，出现了问题时能保证程序安全降落。当 Minor GC 无法找到足够的空间来存放新生代中存活的对象时，JVM 会启动担保机制，将新生代中存活的对象直接放入老年代，从而避免程序的出错。

---

当 Minor GC 后新生代的 Survivor 空间不足以放下所有存活的对象时，我们该如何处理呢？直接报错吗？当然不是，这就是 Java 担保机制出场的时刻!

具体来说，担保机制的工作原理如下：

1. **首先**，在每次进行 Minor GC 前，虚拟机都会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果是，那么 Minor GC 可以确保是安全的。这个检查的过程就是担保机制的一部分。
2. **其次**，如果老年代最大可用的连续空间小于新生代所有对象总空间，那么虚拟机会查看 HandlePromotionFailure 设置是否允许担保失败。如果允许，那么将只会进行 Minor GC；如果不允许，那么会进行一次 Full GC。
3. **最后**，如果在 Minor GC 中有大量对象需要移动到老年代中，而老年代无法接纳的话，那么也需要启动 Full GC 操作。

如此便保障了在新生代空间不足时，不会引起应用程序的错误，让程序得以“安全降落”。

### 对象什么时候会进入老年代？

对象进入老年代的情况，就像我们决定什么时候搬家一样，要取决于具体的情况：

1. **年龄达到门槛**：首先，每当新生代中的对象经过一次 Minor GC, 它的年龄就会加 1. 当对象的年龄达到一定值（默认是 15，这个值可以通过-XX:MaxTenuringThreshold 来设置）时，它就会被移动到老年代。 这就好比，当我们在某个地方住够了一定的年份，就可能会想搬家到别的地方去。
2. **动态年龄判断**：为了更好地适应不同程序的需要，HotSpot 虚拟机并不是永远等到-XX:MaxTenuringThreshold 设置的值才将对象移至老年代。如果 Survivor 空间中相同年龄所有对象大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX:MaxTenuringThreshold 中设定的年龄。 简单来说，如果你的东西太多，即使你租的公寓还能住，你也可能会选择搬家。
3. **Survivor 空间不足**：如果 Survivor 空间没有足够的空间来保存一次 Minor GC 后存活的对象时，那些无法放入 Survivor 的对象将直接进入老年代，无论它们的年龄。也就是说，当你家里已经没有足够的空间来储存你的东西，那你就不得不选择搬家了。

以上就是对象进入老年代的几种情况。无论在何时，争取确定一个家的位置总是件挺开心的事！

### 如何判断对象是否存活，GC root 的对象有哪些？

如何判断对象是否存活，就像淘宝上的商品，被收藏的越多，就越受欢迎。在 Java 的垃圾回收中，主要采用的是可达性分析算法。这个算法的基本理念就是通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果当一个对象到 GC Roots 没有任何引用链相连（用图论的话说，就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。

"GC Roots"的对象包括：

1. **虚拟机栈（栈帧中的本地变量表）中引用的对象**。 玩过乐高积木的话，你应该知道，如果把乐高积木当作对象，那么放在桌子上（虚拟机栈）的乐高积木就是栈中引用的对象，它们都是 GC Roots。
2. **方法区中类静态属性引用的对象**。 这就好比是你家的家具，它们不会被随便动，所以他们也就是 GC Roots。
3. **方法区中常量引用的对象**。 就像一些家庭传统一样，他们是如此的重要，以至于你不会轻易改变的，它们当然也是 GC Roots。
4. **本地方法栈中 JNI（即一般说的 Native 方法）引用的对象**。 这就好比是大楼的基础，一切都建立在上面，所以他们肯定是 GC Roots。

总结一下，就是判断对象是否存活，其实就看这个对象是否在 GC Roots 路径上。那些在 GC Roots 路径上的对象就想淘宝上被收藏的商品，是活跃的，不可回收的，那些不在的，就是要被清理出去的。

### 如何回答线上用的是什么垃圾收集器？为什么要用它？

给一些案例，为什么使用这些 GC

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221436666.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221437781.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221437842.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221438964.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221438235.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221439236.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221439851.png)

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221440185.png)

最后一节实战可以用

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221440926.png)

<!--more-->

![image.png](https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221441263.png)
