import{_ as t,o as r,c as a,R as o}from"./chunks/framework.7FlijoJG.js";const M=JSON.parse('{"title":"ZGC","description":"","frontmatter":{"title":"ZGC","date":"2024-01-16T22:22:24.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"JVM虚拟机/ZGC.md","filePath":"JVM虚拟机/ZGC.md","lastUpdated":1711296414000}'),e={name:"JVM虚拟机/ZGC.md"},C=o('<h2 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构&quot;">​</a></h2><p>首先，关于 ZGC 的结构，ZGC 将堆内存分成了许多小的块（区块），每个块的大小可能是 2MB、1GB 甚至更大，每个块可能处于如下的任一状态：未分配的、可用的、已使用的、空闲的、不可用的。</p><p>接下来是标记过程。ZGC 使用了一种叫做并发标记的方式来找出所有的存活对象。起初，所有的对象都被视为垃圾，从根对象开始遍历，被访问到的对象都被标记为存活。举个例子，就像是我们在探险，一开始我们并不知道前方的路，但只要我们踏过的地方就会被标记起来，说明这里是安全的。</p><p>最后是垃圾回收，ZGC 默认会通过并发的方式来进行垃圾回收，避免了因为垃圾回收导致的应用暂停。根据标记阶段得出的结果，它会发现那些没有被标记的、即被判断为垃圾的块，然后释放这些块之前它们占用的内存。</p><hr><p>垃圾回收器的选择对于 Java 应用的性能来说非常重要。先说到 CMS(Concurrent Mark Sweep)和 ZGC(Z Garbage Collector)两种垃圾回收器的特性。CMS 使用的是&quot;标记-清除&quot;算法，优点在于并发收集、低停顿，但是缺点非常明显：一是 CPU 资源敏感，同时使用的几个线程不能太多，否则会直接影响到系统的处理能力；二是无法处理浮动垃圾，可能导致 Concurrent Mode Failure；三是会产生很多碎片。</p><p>相比之下，ZGC 是一个可扩展的低延迟垃圾回收器。主要设计目标就是以不超过 10ms 的暂停时间来处理数 TB 到数 PB 的堆内存。为了达到低延迟的目标，ZGC 主要使用了以下技术手段：</p><ol><li>无锁并发实现：ZGC 的设计者对 heap 的各个部分都进行了细粒度的划分，使得在进行并发操作的时候无需进行全局的 STW(stop-the-world)操作，从而大大降低了 GC 时的暂停时间。</li><li>读屏障：ZGC 使用了一种称为“load barrier”的技术，也就是在每次读取堆中对象的时候，都会立刻检查这个地址，如果发现这个对象正在被其他线程回收，那么就会立刻停下来等待回收完成。这就保证了堆的一致性，也减少了 STW 的时间。</li><li>染色指针和多阶段并发：在 ZGC 中，每个 Java 对象对应的内存块都会被着色，通过不同的颜色标记内存块的状态。在后台，GC 线程会根据颜色进行标记和清理工作，从而实现了无锁并发。</li><li>类型压缩和对象移动：ZGC 不但解决了 CMS 的内存碎片问题，还通过压缩空闲列表，实现了高效率的内存复用。同时，它会在后台进行对象的移动，进一步减少了碎片，提高了内存的使用效率。</li></ol><p>由于这些因素，ZGC 往往比 CMS 在性能上要好很多，这可能就是你们公司换成 ZGC 后性能提高的原因。</p><h2 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h2><p>ZGC(Z Garbage Collector)和 CMS(Concurrent Mark Sweep)都是 Java 的垃圾回收器，但是 ZGC 相比 CMS 有多项优势和改进，主要包括以下几点：</p><ol><li><strong>低停顿时间</strong>：ZGC 的设计目标是将垃圾回收的停顿时间控制在 10ms 以下，哪怕是在 TB 级别的内存中也能达到这样的效果。这要好过 CMS，因为 CMS 在面对大内存时，垃圾回收的停顿时间可能会很长。</li><li><strong>并发执行</strong>：ZGC 的大部分工作都可以和应用线程并发执行，包括标记、整理和再映射等阶段。这样可以最大限度地减少垃圾回收对应用程序性能的影响。而 CMS 在进行标记和清除阶段时，虽然可以和应用线程并发执行，但是在进行初始标记和重新标记阶段还是需要停止应用线程。</li><li><strong>更好的内存碎片处理</strong>：ZGC 使用了一种新颖的压缩技术来处理内存碎片问题。应用线程能在垃圾回收过程中正常运行，无需等待垃圾回收完成，这避免了因内存碎片造成的性能下降。</li><li><strong>更好的可伸缩性</strong>：ZGC 采用了一种新的、无锁的设计，使得它能够很好地扩展到多 CPU 和大内存的环境中。而 CMS 在面对大内存和多 CPU 时，垃圾回收的效率可能会下降。</li><li><strong>内存压缩</strong>：ZGC 可以在运行时压缩 Java 堆，帮助减少内存占用和提高内存使用效率。这是 CMS 所不能做到的。</li></ol><p>以上这些改进和优势使得 ZGC 在处理大内存应用时，可以提供更低的延迟和更高的吞吐量，从而在很多情况下比 CMS 有更好的性能。</p><hr><p>让我们来通过一个实际的场景来对比一下 ZGC 和 CMS 的区别和优势。假设你在运营一个在线购物网站，这是一个需要处理大量请求并且内存占用较高的 Java 应用。</p><p>如果你使用 CMS 作为垃圾回收器，会碰到以下几个问题：</p><p><strong>停顿时间</strong>：CMS 在处理大型堆时可能存在长时间的垃圾收集暂停。这个暂停时间与堆的大小成正比。所以，当你的线上购物网站在高峰期访问量猛增时，CMS 可能会产生较长的停顿时间。这可能导致用户体验下降，比如网页加载缓慢。</p><p><strong>内存碎片</strong>：CMS 正如它的全称 Concurrent Mark Sweep 所示，它使用标记-清扫的方式进行垃圾回收。在清扫阶段，被回收的对象可能会留下空洞，多次回收后可能会导致大量的内存碎片，空间利用率下降。</p><p><strong>并发模式失败</strong>：如果 CMS 执行过程中，Java 堆空间不足以支持应用程序的持续运行，那么就会触发“并发模式失败”，此时 CMS 会退化为串行回收，性能大打折扣。</p><p>如果你使用 ZGC 作为垃圾回收器，则会有以下优势：</p><p><strong>低延迟</strong>：ZGC 的设计目标是将垃圾回收的停顿时间控制在 10ms 以下，使得用户在使用网站时几乎无法察觉到垃圾回收的存在，从而提供更好的用户体验。</p><p><strong>高吞吐量</strong>：因为 ZGC 可以和应用线程并发执行，并且只在极少的情况下需要停顿，所以能有效提高系统的吞吐量。</p><p><strong>处理大内存</strong>：ZGC 可以非常好地处理 TB 级别的内存，对于大型 Java 应用来说，ZGC 能提供更稳定、更高效的性能。</p><p><strong>内存整理</strong>：ZGC 在进行垃圾回收的过程中，可以进行内存整理，很好地解决了 CMS 的内存碎片问题。</p><p>在这个场景中，ZGC 的优点明显，能有效提高这款购物网站的性能和用户体验。所以，ZGC 相比 CMS 具有明显的优势。</p>',25),s=[C];function n(p,l,i,G,Z,S){return r(),a("div",null,s)}const g=t(e,[["render",n]]);export{M as __pageData,g as default};
