import{_ as a,o as e,c as l,R as i}from"./chunks/framework._4g7boG9.js";const _=JSON.parse('{"title":"操作系统对内存的管理","description":"","frontmatter":{},"headers":[],"relativePath":"wiki/操作系统-内存管理.md","filePath":"wiki/操作系统-内存管理.md","lastUpdated":1700574435000}'),p={name:"wiki/操作系统-内存管理.md"},t=i('<h1 id="操作系统对内存的管理" tabindex="-1">操作系统对内存的管理 <a class="header-anchor" href="#操作系统对内存的管理" aria-label="Permalink to &quot;操作系统对内存的管理&quot;">​</a></h1><p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，需要管理以下方面：</p><ol><li>操作系统负责内存空间的分配与回收</li><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li><li>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行互不干扰</li></ol><h1 id="内存分配策略" tabindex="-1">内存分配策略 <a class="header-anchor" href="#内存分配策略" aria-label="Permalink to &quot;内存分配策略&quot;">​</a></h1><ul><li>连续分配：为用户进程分配的必须是一个连续的内存空间</li><li>非连续分配：为用户分配的可以是一些分散的内存空间</li></ul><p>连续内存分配的缺点：</p><ol><li>分配给一个程序的物理内存是连续的</li><li>内存利用率极低</li><li>有外碎片、内碎片的问题</li></ol><p>非连续内存分类的优点：</p><ol><li>一个程序的物理地址空间是非连续的</li><li>更好的内存利用和管理</li><li>允许共享代码和数据（如C++的共享库等）</li><li>支持动态加载和动态链接</li></ol><p>非连续内存分配的缺点：如何建立虚拟地址到物理地址之间的转换（软件方案、硬件方案）</p><p>现代操作系统基本都是采用分段机制和分页机制来完成非连续分配的地址转换问题的，因此以下只重点梳理非连续内存分配相关的知识点。</p><h1 id="虚拟内存" tabindex="-1">虚拟内存 <a class="header-anchor" href="#虚拟内存" aria-label="Permalink to &quot;虚拟内存&quot;">​</a></h1><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><h1 id="分页系统地址映射" tabindex="-1">分页系统地址映射 <a class="header-anchor" href="#分页系统地址映射" aria-label="Permalink to &quot;分页系统地址映射&quot;">​</a></h1><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><h1 id="页面置换算法" tabindex="-1">页面置换算法 <a class="header-anchor" href="#页面置换算法" aria-label="Permalink to &quot;页面置换算法&quot;">​</a></h1><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h2 id="_1-最佳" tabindex="-1">1. 最佳 <a class="header-anchor" href="#_1-最佳" aria-label="Permalink to &quot;1. 最佳&quot;">​</a></h2><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h2 id="_2-最近最久未使用" tabindex="-1">2. 最近最久未使用 <a class="header-anchor" href="#_2-最近最久未使用" aria-label="Permalink to &quot;2. 最近最久未使用&quot;">​</a></h2><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">4，7，0，7，1，0，1，2，1，2，6</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">4，7，0，7，1，0，1，2，1，2，6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_3-最近未使用" tabindex="-1">3. 最近未使用 <a class="header-anchor" href="#_3-最近未使用" aria-label="Permalink to &quot;3. 最近未使用&quot;">​</a></h2><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h2 id="_4-先进先出" tabindex="-1">4. 先进先出 <a class="header-anchor" href="#_4-先进先出" aria-label="Permalink to &quot;4. 先进先出&quot;">​</a></h2><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p><h2 id="_5-第二次机会算法" tabindex="-1">5. 第二次机会算法 <a class="header-anchor" href="#_5-第二次机会算法" aria-label="Permalink to &quot;5. 第二次机会算法&quot;">​</a></h2><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><h2 id="_6-时钟" tabindex="-1">6. 时钟 <a class="header-anchor" href="#_6-时钟" aria-label="Permalink to &quot;6. 时钟&quot;">​</a></h2><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><h1 id="分段" tabindex="-1">分段 <a class="header-anchor" href="#分段" aria-label="Permalink to &quot;分段&quot;">​</a></h1><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h1 id="段页式" tabindex="-1">段页式 <a class="header-anchor" href="#段页式" aria-label="Permalink to &quot;段页式&quot;">​</a></h1><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h1 id="分页与分段的比较" tabindex="-1">分页与分段的比较 <a class="header-anchor" href="#分页与分段的比较" aria-label="Permalink to &quot;分页与分段的比较&quot;">​</a></h1><ul><li><p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p></li><li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p></li><li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p></li><li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p></li></ul>',60),o=[t];function s(r,n,c,h,d,u){return e(),l("div",null,o)}const m=a(p,[["render",s]]);export{_ as __pageData,m as default};
