import{_ as a,o as l,c as p,R as n,k as s}from"./chunks/framework._4g7boG9.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"wiki/topk.md","filePath":"wiki/topk.md","lastUpdated":1700574435000}'),o={name:"wiki/topk.md"},e=n('<h3 id="topk" tabindex="-1">TopK <a class="header-anchor" href="#topk" aria-label="Permalink to &quot;TopK&quot;">​</a></h3><p>在大规模数据处理中，经常会遇到 TopK 问题，也就是在海量数据中找到最大/小的 k 个数。这也是校招面试常问的算法题，TopK 问题的应用场景很多，比如微博中找到搜索关键字中最热的 10 个词作为热搜、搜索引擎中找到一段时间中搜索次数最多的k个关键字，歌曲库中统计下载次数最多的k首歌曲等等。</p><h3 id="思路优化" tabindex="-1">思路优化 <a class="header-anchor" href="#思路优化" aria-label="Permalink to &quot;思路优化&quot;">​</a></h3><h4 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to &quot;排序&quot;">​</a></h4><p>最容易想到的肯定是排序算法，然后取其排序的最大/小的k个数就完事了。其时间复杂度是 O(nlogn) ，但是问题来了，如果前提是以亿为单位的数据，你还敢用排序算法吗？明明只需要k个数，为啥要对所有数都排序呢？并且对这种海量数据，计算机内存不一定能扛得住。</p><h4 id="局部淘汰法" tabindex="-1">局部淘汰法 <a class="header-anchor" href="#局部淘汰法" aria-label="Permalink to &quot;局部淘汰法&quot;">​</a></h4><p>既然只需要 k 个数，那么我们可以再优化一下，先用一个容器装这个数组的前 k 个数，然后找到这个容器中最小的那个数，再依次遍历后面的数，如果后面的数比这个最小的数要大，那么两者交换。一直到剩余的所有数都比这个容器中的数要小，那么这个容器中的数就是最大的k个数。</p><p>这种算法的时间复杂度为 O(n*m) ，其中 m 为容器的长度。</p><p>具体地，其过程如下图所示：</p><p>那么这种方法的时间复杂度也太大，同样的思路，我们其实还可以利用最大/小堆来实现，这就引出了下一个实现方法。</p><h4 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h4><p>我们可以先用前k个元素生成一个小顶堆，这个小顶堆用于存储当前k个元素，例子同上，可以构造小顶堆如下：</p><p>然后从第 k+1 个元素开始扫描，和堆顶元素比较（最小值），如果当前元素大于堆顶元素，则替换堆顶值，并调整堆，以保证堆内k个元素一直是当前最大的 k 个元素，如图所示：</p><p>直到，扫描完所有 n-k 个元素，最终堆中的 k 个元素，就是猥琐求的 TopK ：</p>',14),r=s("div",{algin:"center"},[s("img",{width:"700px",height:"auto",src:"https://blogimage-1258928558.cos.ap-guangzhou.myqcloud.com/topk/4.png"})],-1),t=n(`<p>这种堆解法的时间复杂度为O(N*logk)，并且堆解法也是求解 TopK 问题的经典解法，用代码实现如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">findKthLargest</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    PriorityQueue&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; pq </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> PriorityQueue&lt;&gt;(Comparator.</span><span style="color:#B392F0;">reverseOrder</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// 大顶堆</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> val </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> nums) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        pq.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(val);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pq.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> k)  </span><span style="color:#6A737D;">// 维护堆的大小为 K</span></span>
<span class="line"><span style="color:#E1E4E8;">            pq.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> pq.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">findKthLargest</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">    k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> k </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    PriorityQueue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; pq </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> PriorityQueue&lt;&gt;(Comparator.</span><span style="color:#6F42C1;">reverseOrder</span><span style="color:#24292E;">()); </span><span style="color:#6A737D;">// 大顶堆</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> val </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> nums) {</span></span>
<span class="line"><span style="color:#24292E;">        pq.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(val);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pq.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> k)  </span><span style="color:#6A737D;">// 维护堆的大小为 K</span></span>
<span class="line"><span style="color:#24292E;">            pq.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> pq.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>那么还有没有更高效的解法呢？</p><h4 id="快速排序" tabindex="-1">快速排序 <a class="header-anchor" href="#快速排序" aria-label="Permalink to &quot;快速排序&quot;">​</a></h4><p>我们知道，快排的思想就是分治法，即分而治之，简而言之，就是把一个大问题分解为若干个子问题，然后把每个子问题都求解出来，最后整个大问题就解决了，其伪代码如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">quick_sort</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[]arr, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> low, inthigh){ </span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(low</span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> high) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">partition</span><span style="color:#E1E4E8;">(arr, low, high); </span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#B392F0;">quick_sort</span><span style="color:#E1E4E8;">(arr, low, i</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">); </span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#B392F0;">quick_sort</span><span style="color:#E1E4E8;">(arr, i</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, high); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">quick_sort</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[]arr, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> low, inthigh){ </span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(low</span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> high) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">partition</span><span style="color:#24292E;">(arr, low, high); </span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6F42C1;">quick_sort</span><span style="color:#24292E;">(arr, low, i</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">); </span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6F42C1;">quick_sort</span><span style="color:#24292E;">(arr, i</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, high); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>那么其中的核心就在于 partition(arr, low, high) 上，这个 partition 是什么意思呢？顾名思义，就是通过这个方法把数组分为两部分。更具体地，就是以数组 arr 中的一个元素（一般默认是第一个元素 t=arr[low] ）作为划分依据，将数组 arr[low,high] 分为左右两个子数组：</p><ul><li>左半部分，都比 t 小</li><li>右半部分，都比 t 大</li></ul><p>如下图所示：</p><p>那么 partition 的返回结果就是t最终的位置i。</p><p>很容易知道， partition 的时间复杂度为 O(n) 。</p><p>那么快排跟 Topk 问题有什么关系呢？回到问题本身，TopK 就是希望求出数组 arr[1,n] 中最大的 k 个数，那么如果找到了第 k 大的数，做一次 partition ，不就一次性找到最大的 k 个数了么？结果也就是 partition 的右半区间的数。</p><p>那么问题最终就变成了找数组中第k大的数，回过头来看看第一次 partition 划分之后：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">partition</span><span style="color:#E1E4E8;">(arr,</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,n);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">partition</span><span style="color:#24292E;">(arr,</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,n);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>那么这时候有两种情况：</p><ol><li>i &gt; k，那么说明 arr[i] 左边的元素都大于 k ，于是只需要随后递归 arr[1,i-1] 里面第 k 大的元素即可；</li><li>i &lt; k，那么说明第 k 大的元素在右边，于是只需要递归 arr[i+1,n] 里第 k-i 大的元素即可。</li></ol><p>上面这段非常重要，可以多读几遍。</p><p>使用代码实现上述算法可以如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">findKthElement</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    k </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> k;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> l </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (l </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> h) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">partition</span><span style="color:#E1E4E8;">(nums, l, h);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            l </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> nums[k];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">partition</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] a, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> l, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> h) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l, j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (a[</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">i] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> a[l] </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> h) ;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (a[</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">j] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> a[l] </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> l) ;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> j) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">swap</span><span style="color:#E1E4E8;">(a, i, j);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">swap</span><span style="color:#E1E4E8;">(a, l, j);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> j;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">swap</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] a, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[j];</span></span>
<span class="line"><span style="color:#E1E4E8;">    a[j] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">findKthElement</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">    k </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> k;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> l </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (l </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> h) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">partition</span><span style="color:#24292E;">(nums, l, h);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">            l </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> nums[k];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">partition</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] a, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> l, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l, j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (a[</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">i] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> a[l] </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> h) ;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (a[</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">j] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> a[l] </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> l) ;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> j) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">swap</span><span style="color:#24292E;">(a, i, j);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">swap</span><span style="color:#24292E;">(a, l, j);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> j;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">swap</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] a, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[i];</span></span>
<span class="line"><span style="color:#24292E;">    a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[j];</span></span>
<span class="line"><span style="color:#24292E;">    a[j] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="topk的其它问题" tabindex="-1">TopK的其它问题 <a class="header-anchor" href="#topk的其它问题" aria-label="Permalink to &quot;TopK的其它问题&quot;">​</a></h3><h4 id="海量数据" tabindex="-1">海量数据 <a class="header-anchor" href="#海量数据" aria-label="Permalink to &quot;海量数据&quot;">​</a></h4><p>海量数据前提下，肯定不可能放在单机上。</p><ul><li>拆分，可以按照哈希取模或者其它方法拆分到多台机器上，并在每个机器上维护最小堆</li><li>整合，将每台机器上得到的最小堆合并成最终的最小堆</li></ul><h4 id="频率统计" tabindex="-1">频率统计 <a class="header-anchor" href="#频率统计" aria-label="Permalink to &quot;频率统计&quot;">​</a></h4><p>找出一个数据流中最频繁出现的 k 个数，比如热门搜索词汇等。</p><ul><li>使用 HashMap 进行频率统计，数据量不大时可用</li><li>Count-Min Sketch方法，具体可以<a href="https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch" target="_blank" rel="noreferrer">Google</a></li><li>Trie树解决，可以参考<a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="noreferrer">这里</a></li></ul><h3 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to &quot;参考文章&quot;">​</a></h3><ul><li><a href="https://xiaozhuanlan.com/topic/4176082593" target="_blank" rel="noreferrer">TopK</a></li><li><a href="http://zhuanlan.51cto.com/art/201809/584259.htm" target="_blank" rel="noreferrer">拜托，面试别再问我TopK了</a></li><li><a href="https://uule.iteye.com/blog/2413147" target="_blank" rel="noreferrer">海量数据处理--topK问题</a></li><li><a href="https://blog.csdn.net/tywiiu/article/details/79494737" target="_blank" rel="noreferrer">海量数据处理问题（Top k问题）的实现</a></li></ul>`,28),c=[e,r,t];function E(y,i,u,b,h,F){return l(),p("div",null,c)}const k=a(o,[["render",E]]);export{m as __pageData,k as default};
