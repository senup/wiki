import{_ as s,o as e,c as n,R as a}from"./chunks/framework.7FlijoJG.js";const h=JSON.parse('{"title":"Kafka拓展","description":"","frontmatter":{"title":"Kafka拓展","date":"2024-01-21T12:32:20.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"消息队列/Kafka拓展.md","filePath":"消息队列/Kafka拓展.md","lastUpdated":1711296414000}'),t={name:"消息队列/Kafka拓展.md"},o=a(`<h2 id="生产者" tabindex="-1">生产者 <a class="header-anchor" href="#生产者" aria-label="Permalink to &quot;生产者&quot;">​</a></h2><p>这些内容主要描述的是 Kafka 的生产者端的用法，下面我来分别说明一下它们的使用场景：</p><ol><li><p><strong>生产消息的 API</strong>：这是 Kafka 的 Java 客户端提供的生产者 API 对象，用于创建消息并发送到 Kafka 的 topic 中。在实际业务中，假设你的系统需要将日志或处理结果写入到 Kafka 中以供其他系统消费，你就需要使用这个 API。</p></li><li><p><strong>配置</strong>：这些配置参数包括 <strong>broker 的地址、发布确认机制、重试次数、批次大小和等待时长、缓冲区大小</strong>等，这些参数影响到生产者发送消息的效率和可靠性。例如，publish confirmation mechanism 能够保证生产者能够得到消息是否发布成功的确认，对于数据可靠性要求高的场景非常重要。</p></li><li><p><strong>Topic 和分区指定</strong>：你可以在生产消息时指定消息发送到哪个 topic 和分区，这可以根据业务需求来决定。例如，你可能会根据用户 ID 的 hash 值来选择分区，这样所有同一个用户的消息都会在同一个分区。</p></li><li><p><strong>回调函数</strong>：当生产者发布消息后，你可能需要执行一些额外的动作，例如记录日志、发送通知等，这些都可以通过注册回调函数来实现。</p></li><li><p><strong>自定义拦截器</strong>：可以对发送的消息做一些预处理，例如修改消息内容、变更消息格式、添加额外的元数据等。通过实现<code>ProducerInterceptor</code>接口，并注册到生产者配置中，可以实现这个功能。</p></li><li><p><strong>实现 ProducerInterceptor 接口</strong>：通过实现接口中的<code>onSend</code>，<code>onAcknowledgement</code>和<code>close</code>方法，你可以在消息发送前、发送后和生产者关闭时执行自定义的逻辑。</p></li><li><p><strong>自定义分区</strong>：当 Kafka 的默认分区规则不能满足你的业务需求时，你可以实现自定义的分区逻辑。例如，你可能想要按照业务属性来对消息进行分区，可以通过实现<code>Partitioner</code>接口的<code>partition</code>和<code>close</code>方法来实现。</p></li></ol><p>这些内容基本涵盖了 Kafka 生产者的使用，包括消息生产、配置优化、处理逻辑自定义等方面，对于使用 Kafka 处理大数据场景非常重要，从而提高处理效率和保证数据的正确性。</p><h2 id="案例" tabindex="-1">案例 <a class="header-anchor" href="#案例" aria-label="Permalink to &quot;案例&quot;">​</a></h2><p>当然了，让我来为你一一举例说明：</p><ol><li><p><strong>生产消息的 API</strong>：生产消息就是创建 ProducerRecord 对象，然后使用 producer.send()方法发送出去。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span></span>
<span class="line"><span style="color:#e1e4e8;">ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(&quot;topic&quot;, &quot;key&quot;, &quot;value&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">producer.send(record);</span></span>
<span class="line"><span style="color:#e1e4e8;">producer.close();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span></span>
<span class="line"><span style="color:#24292e;">ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(&quot;topic&quot;, &quot;key&quot;, &quot;value&quot;);</span></span>
<span class="line"><span style="color:#24292e;">producer.send(record);</span></span>
<span class="line"><span style="color:#24292e;">producer.close();</span></span></code></pre></div></li><li><p><strong>配置</strong>：这主要就是通过 Properties 对象进行，例如我们可以设置 broker 的地址，重试次数等。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Properties props = new Properties();</span></span>
<span class="line"><span style="color:#e1e4e8;">props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">props.put(&quot;retries&quot;, 3);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Properties props = new Properties();</span></span>
<span class="line"><span style="color:#24292e;">props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);</span></span>
<span class="line"><span style="color:#24292e;">props.put(&quot;retries&quot;, 3);</span></span></code></pre></div></li><li><p><strong>指定 Topic 和 Partition</strong>：当你创建 ProducerRecord 对象时，可以指定消息发送到哪个 Topic 和分区。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(&quot;topic&quot;, 1, &quot;key&quot;, &quot;value&quot;);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(&quot;topic&quot;, 1, &quot;key&quot;, &quot;value&quot;);</span></span></code></pre></div></li><li><p><strong>回调函数</strong>：在消息发送后，你可能想要确认消息是否发送成功，就可以使用回调函数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">producer.send(record, (metadata, exception) -&gt; {</span></span>
<span class="line"><span style="color:#e1e4e8;">    if (exception != null) {</span></span>
<span class="line"><span style="color:#e1e4e8;">        exception.printStackTrace();</span></span>
<span class="line"><span style="color:#e1e4e8;">    } else {</span></span>
<span class="line"><span style="color:#e1e4e8;">        System.out.println(&quot;The offset of the record we just sent is: &quot; + metadata.offset());</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">producer.send(record, (metadata, exception) -&gt; {</span></span>
<span class="line"><span style="color:#24292e;">    if (exception != null) {</span></span>
<span class="line"><span style="color:#24292e;">        exception.printStackTrace();</span></span>
<span class="line"><span style="color:#24292e;">    } else {</span></span>
<span class="line"><span style="color:#24292e;">        System.out.println(&quot;The offset of the record we just sent is: &quot; + metadata.offset());</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">});</span></span></code></pre></div></li><li><p><strong>自定义拦截器</strong>：比如我们要在每条消息前面加上时间戳：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public class TimeStampPrependerInterceptor implements ProducerInterceptor&lt;String, String&gt; {</span></span>
<span class="line"><span style="color:#e1e4e8;">    @Override</span></span>
<span class="line"><span style="color:#e1e4e8;">    public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) {</span></span>
<span class="line"><span style="color:#e1e4e8;">        return new ProducerRecord&lt;&gt;(</span></span>
<span class="line"><span style="color:#e1e4e8;">                record.topic(),</span></span>
<span class="line"><span style="color:#e1e4e8;">                record.partition(),</span></span>
<span class="line"><span style="color:#e1e4e8;">                record.timestamp(),</span></span>
<span class="line"><span style="color:#e1e4e8;">                record.key(),</span></span>
<span class="line"><span style="color:#e1e4e8;">                System.currentTimeMillis() + &quot;,&quot; + record.value()</span></span>
<span class="line"><span style="color:#e1e4e8;">        );</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    ...</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class TimeStampPrependerInterceptor implements ProducerInterceptor&lt;String, String&gt; {</span></span>
<span class="line"><span style="color:#24292e;">    @Override</span></span>
<span class="line"><span style="color:#24292e;">    public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) {</span></span>
<span class="line"><span style="color:#24292e;">        return new ProducerRecord&lt;&gt;(</span></span>
<span class="line"><span style="color:#24292e;">                record.topic(),</span></span>
<span class="line"><span style="color:#24292e;">                record.partition(),</span></span>
<span class="line"><span style="color:#24292e;">                record.timestamp(),</span></span>
<span class="line"><span style="color:#24292e;">                record.key(),</span></span>
<span class="line"><span style="color:#24292e;">                System.currentTimeMillis() + &quot;,&quot; + record.value()</span></span>
<span class="line"><span style="color:#24292e;">        );</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">    ...</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div></li><li><p><strong>实现 ProducerInterceptor 接口</strong>：在自定义拦截器时需要实现此接口的各个方法，上面的例子就是实现了 onSend 方法。</p></li><li><p><strong>自定义分区</strong>：比如我们要把含有特定字符串的消息发送到特定的分区：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public class CustomPartitioner implements Partitioner {</span></span>
<span class="line"><span style="color:#e1e4e8;">    @Override</span></span>
<span class="line"><span style="color:#e1e4e8;">    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {</span></span>
<span class="line"><span style="color:#e1e4e8;">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span></span>
<span class="line"><span style="color:#e1e4e8;">        int numPartitions = partitions.size();</span></span>
<span class="line"><span style="color:#e1e4e8;">        if (((String) key).equals(&quot;specialKey&quot;)) {</span></span>
<span class="line"><span style="color:#e1e4e8;">            return numPartitions;  // specialKey消息总是发到最后一个分区</span></span>
<span class="line"><span style="color:#e1e4e8;">        } else {</span></span>
<span class="line"><span style="color:#e1e4e8;">            return (Math.abs(Utils.murmur2(keyBytes)) % (numPartitions - 1));  // 其他消息发到其他分区</span></span>
<span class="line"><span style="color:#e1e4e8;">        }</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">    ...</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class CustomPartitioner implements Partitioner {</span></span>
<span class="line"><span style="color:#24292e;">    @Override</span></span>
<span class="line"><span style="color:#24292e;">    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {</span></span>
<span class="line"><span style="color:#24292e;">        List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span></span>
<span class="line"><span style="color:#24292e;">        int numPartitions = partitions.size();</span></span>
<span class="line"><span style="color:#24292e;">        if (((String) key).equals(&quot;specialKey&quot;)) {</span></span>
<span class="line"><span style="color:#24292e;">            return numPartitions;  // specialKey消息总是发到最后一个分区</span></span>
<span class="line"><span style="color:#24292e;">        } else {</span></span>
<span class="line"><span style="color:#24292e;">            return (Math.abs(Utils.murmur2(keyBytes)) % (numPartitions - 1));  // 其他消息发到其他分区</span></span>
<span class="line"><span style="color:#24292e;">        }</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">    ...</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div></li></ol><h2 id="消费者" tabindex="-1">消费者 <a class="header-anchor" href="#消费者" aria-label="Permalink to &quot;消费者&quot;">​</a></h2><p>Kafka 的消费 API 关键参数包括：</p><ol><li><p><strong>broker_ip_port</strong>：这是 Kafka broker 的地址和端口号。消费者需要知道至少一个 broker 的地址来获取 topic 的元数据，从而找到所有分区的 leader broker，以便从这些 leader 消费消息。</p></li><li><p><strong>消费组</strong>：消费者组是每个 Kafka 消费者必须设置的参数。如果多个消费者有相同的消费者组，则它们会负载均衡地消费数据，互相之间不重复。</p></li><li><p><strong>offset 是否自动提交</strong>：这个设置指的是 Kafka 是否自动地提交消费者的 offset。如果设置为自动提交，当消费者 poll 数据后，Kafka 会在一定的时间间隔后自动提交 offset。但是如果你希望有更精细的控制，比如只有当消息真正被成功处理后再提交 offset，那么就需要把自动提交关闭，改为手动提交。</p></li><li><p><strong>offset 提交的间隔</strong>：这个设置指的是自动提交 offset 的时间间隔，单位是毫秒。如果消费者在此间隔内挂掉，那么它可能会重复处理某些消息。</p></li><li><p><strong>offset 是否重置</strong>：这个设置用于指定当消费者的 offset 不存在或者 offset 超出了范围时，应该从哪里开始消费。这个参数可以设置为&quot;earliest&quot;或者&quot;latest&quot;。&quot;earliest&quot;表示从最早的消息开始消费，&quot;latest&quot;表示从最新的消息开始消费。</p></li><li><p><strong>keyvalue 反序列化的类</strong>：这个设置用于指定用什么反序列化器去反序列化从 Kafka 收到的消息。Kafka 自带了 ByteArrayDeserializer, StringDeserializer, IntegerDeserializer 等多种反序列化器。根据你的消息类型选择合适的反序列化器即可。</p></li></ol><p>除了这些，还有一个重要的方法是 subscribe，用于订阅 topic。比如 <code>consumer.subscribe(Arrays.asList(&quot;test&quot;))</code>，这行代码表示你创建的消费者订阅了名为&quot;test&quot;的 topic。Kafka 的消费者是面向 topic 的，所以你需要告诉 Kafka，你的消费者需要消费哪些 topic 的数据。Kafka 会根据你的消费组和订阅的 topic，决定把这些 topic 的哪些分区分配给你的消费者。</p><h2 id="消息的提交" tabindex="-1">消息的提交 <a class="header-anchor" href="#消息的提交" aria-label="Permalink to &quot;消息的提交&quot;">​</a></h2><p>在处理消息队列中的消息时，消费者通常需要向服务器发送一个确认，称为&quot;提交&quot;，以标记它已经处理了这个消息，从而避免重复处理。这个提交步骤可以是同步的，也可以是异步的。</p><p><strong>同步提交</strong>意味着消费者在处理完一个消息后，会立即发出一个确认请求并等待服务器的回应。这种模式是阻塞的，也就是说，在确认请求得到回应之前，消费者会停止处理新的消息。同步提交有一个好处，那就是它提供了更准确的错误处理，因为你可以立即知道确认请求是否成功。但是，因为它是阻塞的，所以同步提交可能会降低处理速度。</p><p><strong>异步提交</strong>则是非阻塞的。消费者在处理完一个消息后会立即开始处理下一个，而提交请求则是在后台发送的。这种模式可以显著提升处理速度，但是它也有一个缺点，那就是如果提交请求因为某种原因失败了，消费者可能不会立即得知。</p><p>至于提交和消费的顺序：</p><ol><li><p><strong>先消费后提交</strong>：这意味着只有当消费者处理完一条消息后，才会向服务器发送确认请求。这样可以确保消费者不会错过任何消息，因为只有当消息被成功处理后才会被标记为已消费。同时，这个模式也可能导致重复消费。如果在消费完消息后和提交确认请求之间，消费者出现了故障，那么这条消息可能会被再次消费。</p></li><li><p><strong>先提交后消费</strong>：这个模式中，消费者会在处理消息之前就发送确认请求。这可以减少重复消费的可能，因为一旦一条消息被标记为已消费，就不会再被送给消费者。但是，这个模式也有可能导致漏消费问题。如果在提交确认请求后和处理消息之间，消费者出现了故障，那么这条消息就会丢失。</p></li></ol><p>在实际使用中，要根据具体的业务场景和需求，选择最适合自己的消费和提交模式。</p>`,18),p=[o];function l(r,c,i,d,u,g){return e(),n("div",null,p)}const k=s(t,[["render",l]]);export{h as __pageData,k as default};
