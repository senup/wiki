import{_ as l,o as i,c as p,R as e}from"./chunks/framework.7FlijoJG.js";const g=JSON.parse('{"title":"中英文转换","description":"","frontmatter":{"title":"中英文转换","date":"2024-01-19T13:34:02.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"系统设计/中英文转换.md","filePath":"系统设计/中英文转换.md","lastUpdated":1711296414000}'),t={name:"系统设计/中英文转换.md"},o=e('<p>好的,我来分步解析这个注解的实现思路:</p><ol><li><p>定义一个注解 ChinaToEnglishNameApiAnnotation,用于标注需要中文转英文的方法</p></li><li><p>定义一个切面 ChinaToEnglishNameAop,使用@Aspect 注解表明这是一个切面类</p></li><li><p>在切面类中使用@Pointcut 定义一个切入点,这里是切入所有被 ChinaToEnglishNameApiAnnotation 注解的方法</p></li><li><p>在切面类中使用@Around 定义一个环绕通知,在这个通知方法中可以获取 joinPoint,并调用 proceed()执行原方法</p></li><li><p>在环绕通知中,首先执行原方法,得到结果 result</p></li><li><p>判断 result 的类型,如果是 Response,则从 response 中取出 info 信息进行处理</p><p>如果是 List,也直接处理</p></li><li><p>定义一个方法 getEnglishName,递归遍历对象中的字段,找出需要翻译的中文字段</p></li><li><p>将需要翻译的中文字段保存到 ChinaToEnglishVo 对象中</p></li><li><p>调用接口翻译这些中文名为英文名,保存到 map 中</p></li><li><p>定义 replaceEnglishName 方法,递归遍历对象中的字段,用英文名替换掉中文名</p></li><li><p>在环绕通知最后将处理后的 result 返回</p></li><li><p>这样通过切面和注解的方式,实现了对原方法的增强,在方法执行前后进行额外的中文转英文处理逻辑。</p></li></ol><p>总结起来,主要步骤是:</p><ol><li><p>定义注解</p></li><li><p>使用切面和切入点拦截被注解的方法</p></li><li><p>在环绕通知中执行额外逻辑</p></li><li><p>递归遍历对象替换字段</p></li><li><p>调用翻译接口</p></li><li><p>返回增强后的结果</p></li></ol><hr><p>好的,如果出现重复的中文名字,该代码会有以下处理:</p><ol><li><p>在 getEnglishName 方法中,会将所有需要翻译的中文名添加到 ChinaToEnglishVo 的相关集合属性中。这里由于用的是 Set 存储,所以会自动去重。</p></li><li><p>在 nameToEnglish 方法中,会将名字列表进行去重处理,保证传入翻译接口的名字列表无重复。</p></li><li><p>从翻译接口获取的结果中,也会有对相同中文名字返回同一个英文名的情况。</p></li><li><p>在组装名字映射 map 时,如果有重复的中文名,会保留最后一个映射关系。</p></li><li><p>在 replaceEnglishName 替换字段时,会根据该 map 直接获取对应的英文名进行替换。</p></li></ol><p>所以整体流程中,处理重复中文名主要在以下地方:</p><ol><li><p>保存到 Set 集合时自动去重</p></li><li><p>调用翻译接口前手动去重</p></li><li><p>映射 map 组装时保留最后一个映射关系</p></li><li><p>根据 map 直接翻译,重复名对应同一个英文名</p></li></ol><p>这样可以保证最终的翻译结果中,重复的中文名会统一对应一个英文名,不会产生重复的英文名,实现正确的去重处理。</p><p>综上,重复中文名的处理主要依赖 Set 自动去重、手动去重和 map 维护唯一映射关系来实现。</p><hr><p>好的,这个实现中用到了以下反射的 API 和知识:</p><ol><li>获取类的字段信息</li></ol><p>使用 Class 对象的 getDeclaredFields()方法可以获取该类声明的所有字段信息,返回 Field 数组。</p><ol start="2"><li>设置字段可访问</li></ol><p>Field 对象默认是非 public 的,需要调用 setAccessible(true)将其设置为可访问,才能获取和设置字段的值。</p><ol start="3"><li>获取和设置字段值</li></ol><p>使用 Field 对象的 get(Object obj)和 set(Object obj, Object value)方法可以获取和设置 obj 对象上的该 Field 字段的值。</p><ol start="4"><li>获取方法信息</li></ol><p>可以通过 MethodSignature 的 getMethod()方法获取切点方法的 Method 对象。然后可以调用 getAnnotation 获取该方法上的注解信息。</p><ol start="5"><li>获取类信息</li></ol><p>可以通过 Object 的 getClass()方法获取该对象的 Class 信息。</p><ol start="6"><li>判断类型</li></ol><p>可以通过 Class 对象的 isPrimitive(),isAssignableFrom()等方法来判断类型信息。</p><ol start="7"><li>递归遍历对象</li></ol><p>通过递归调用,遍历对象的字段,如果字段值也是对象,继续遍历获取其字段信息。</p><p>主要用到了这些反射 API,通过这些 API 可以动态获取类、字段、方法等信息,然后进行操作,实现了注解的解析、字段值获取等功能。</p><p>反射是实现这种场景的关键所在,所以需要掌握反射的相关知识,才能理解其工作原理。请你仔细理解这些反射知识,有任何不明白的地方都可以随时提问。</p><hr><p>用更直白的话来解释getEnglishName方法的处理流程:</p><ol><li>判断当前对象obj是否为空,为空直接返回不处理</li><li>获取obj的类信息,包含这个对象的所有字段信息</li><li>遍历obj的每个字段</li><li>将字段设置为可访问,可以获取字段的值</li><li>获取字段的值赋值给一个变量值value</li><li>判断值value是否是String字符串类型</li><li>如果是字符串,就检查这个字段有没有翻译的注解</li><li>如果有翻译注解,就将这个value值添加到需要翻译的集合中保存起来</li><li>如果值value不是字符串,那就说明它是一个对象</li><li>就以这个值value对象再次作为obj,递归调用getEnglishName方法</li><li>再次获取它的类信息、字段信息,重复上面的判断、获取值、检查注解的过程</li><li>循环递归调用,直到遍历完obj对象及其子对象的所有字段</li><li>将所有需要翻译的字段的值都添加到集合保存起来</li></ol>',32),a=[o];function s(n,r,c,_,h,d){return i(),p("div",null,a)}const u=l(t,[["render",s]]);export{g as __pageData,u as default};
