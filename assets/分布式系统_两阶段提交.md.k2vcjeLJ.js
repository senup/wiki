import{_ as e,o as a,c as t,R as o}from"./chunks/framework.7FlijoJG.js";const u=JSON.parse('{"title":"两阶段提交","description":"","frontmatter":{"title":"两阶段提交","date":"2023-12-28T08:29:58.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"分布式系统/两阶段提交.md","filePath":"分布式系统/两阶段提交.md","lastUpdated":1711296414000}'),i={name:"分布式系统/两阶段提交.md"},l=o('<h2 id="简记" tabindex="-1">简记 <a class="header-anchor" href="#简记" aria-label="Permalink to &quot;简记&quot;">​</a></h2><p><strong>两阶段提交</strong>是为了实现分布式系统中的事务一致性，它分为两个阶段进行：</p><ul><li><em>第一阶段</em>：事务协调者询问各个事务参与者是否已经准备好提交事务，收到各个参与者的“已就绪”回报后，进入第二阶段。老朋友来电问是否可以一起出去玩，你说油满为平就好，那就进入第二阶段啦。</li><li><em>第二阶段</em>：事务协调者向所有参与者发出“提交”请求，所有参与者收到此请求后提交事务，并向协调者报告“已提交”完成事务。所有朋友统一行动，同一时间出门，然后告诉老朋友说，出门啦！</li></ul><p>但是，两阶段提交有一个主要问题，就是每个事务参与者在等待其他参与者响应的时候必须阻塞自身，此时处于不可接受其他任何事务请求的状态，这可能造成资源的低效利用。</p><p>所以，我们必需对其进行升级和改进，那就引入了  <strong>[[三阶段提交]]协议</strong>！</p><ul><li><em>第一阶段</em>：和两阶段提交一样，询问所有参与者是否可以提交事务，只有所有的参与者都返回“准备好了”，才进入第二阶段。还是老朋友打来电话，一切准备就绪就进入第二阶段。</li><li><em>第二阶段</em>：协调者向所有参与者发送一个“<strong>预提交</strong>”消息，参与者接收到该消息后，执行事务操作，然后向协调者反馈“准备提交”。</li><li><em>第三阶段</em>：等所有参与者都返回了第二阶段的响应，协调者便向所有参与者发送一个“正式提交”指令。所有的参与者接收到此消息后，提交事务，并向协 ordinator 发送“已提交”的消息。这就好比所有朋友收拾好，出门的时间临近，然后所有人都向那位组织活动的老朋友汇报，“已经出门了”！</li></ul><p>而且呢，不像两阶段提交那样参与者需要在第二阶段持续等待，这就是它相比于两阶段提交的最关键的改进点。不过，别忘了，尽管三阶段提交解决了饥饿问题，但仍然可能出现网络分区等问题。</p><h2 id="二阶段提交协议" tabindex="-1">二阶段提交协议 <a class="header-anchor" href="#二阶段提交协议" aria-label="Permalink to &quot;二阶段提交协议&quot;">​</a></h2><p>二阶段提交算法的成立是基于以下假设的：</p><ul><li>在该分布式系统中，存在一个节点作为<strong>协调者</strong>（Coordinator），其他节点作为<strong>参与者</strong>（Participants），且节点之间可以进行网络通信；</li><li>所有节点都采用预写式日志，日志被写入后被保存在可靠的存储设备上，即使节点损坏也不会导致日志数据的丢失；</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li></ul><p>两阶段提交中的两个阶段，指的是  <strong>Commit-request 阶段</strong>和  <strong>Commit 阶段</strong>，两阶段提交的流程如下：</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312280859265.png" alt="image.png"></p><h4 id="提交请求阶段" tabindex="-1">提交请求阶段 <a class="header-anchor" href="#提交请求阶段" aria-label="Permalink to &quot;提交请求阶段&quot;">​</a></h4><p>在提交请求阶段，协调者将通知事务参与者准备提交事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功）或取消（本地事务执行故障），在第一阶段，参与节点并没有进行 Commit 操作。</p><h4 id="提交阶段" tabindex="-1">提交阶段 <a class="header-anchor" href="#提交阶段" aria-label="Permalink to &quot;提交阶段&quot;">​</a></h4><p>在提交阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消这个事务。这个结果的处理和前面基于半数以上投票的一致性算法不同，必须当且仅当所有的参与者同意提交，协调者才会通知各个参与者提交事务，否则协调者将通知各个参与者取消事务。</p><p>参与者在接收到协调者发来的消息后将执行对应的操作，也就是本地 Commit 或者 Rollback。</p><h4 id="两阶段提交存在的问题" tabindex="-1">两阶段提交存在的问题 <a class="header-anchor" href="#两阶段提交存在的问题" aria-label="Permalink to &quot;两阶段提交存在的问题&quot;">​</a></h4><p><img src="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e5%88%86%e5%b8%83%e5%bc%8f%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86%e4%b8%8e%e5%ae%9e%e6%88%9845%e8%ae%b2-%e5%ae%8c/assets/Ciqah16eldqAX17XAAGwMfUwb2M109.png" alt="分2.png"></p><p>两阶段提交协议有几个明显的问题，下面列举如下。</p><ul><li><p>资源被同步阻塞:在执行过程中，所有参与节点都是事务独占状态，当参与者占有公共资源时，那么第三方节点访问公共资源会被阻塞。</p></li><li><p>协调者可能出现单点故障:一旦协调者发生故障，参与者会一直阻塞下去。</p></li><li><p>在 Commit 阶段出现数据不一致:在第二阶段中，假设协调者发出了事务 Commit 的通知，但是由于网络问题该通知仅被一部分参与者所收到并执行 Commit，其余的参与者没有收到通知，一直处于阻塞状态，那么，这段时间就产生了数据的不一致性。</p></li></ul><h2 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h2><p>在 MySQL 中，二进制日志是 server 层，主要用来做<strong>主从复制</strong>和<strong>即时点恢复</strong>时使用的；而事务日志（Redo Log）是 InnoDB 存储引擎层，用来保证事务安全的。</p><p>在数据库运行中，需要保证 Binlog 和 Redo Log 的一致性，如果顺序不一致， 则意味着 Master-Slave 可能不一致。</p><p>在开启 Binlog 后，如何保证 Binlog 和 InnoDB redo 日志的一致性呢？MySQL 使用的就是二阶段提交，内部会自动将普通事务当做一个 XA 事务（内部分布式事务）来处理：</p><ul><li>Commit 会被自动的分成 Prepare 和 Commit 两个阶段；</li><li>Binlog 会被当做事务协调者（Transaction Coordinator），Binlog Event 会被当做协调者日志。</li></ul>',26),r=[l];function n(s,p,m,c,d,h){return a(),t("div",null,r)}const _=e(i,[["render",n]]);export{u as __pageData,_ as default};
