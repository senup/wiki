import{_ as a,o as t,c as o,R as e}from"./chunks/framework.7FlijoJG.js";const u=JSON.parse('{"title":"三阶段提交","description":"","frontmatter":{"title":"三阶段提交","date":"2023-12-28T08:31:48.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"分布式系统/三阶段提交.md","filePath":"分布式系统/三阶段提交.md","lastUpdated":1711296414000}'),i={name:"分布式系统/三阶段提交.md"},r=e('<h3 id="三阶段提交协议" tabindex="-1">三阶段提交协议 <a class="header-anchor" href="#三阶段提交协议" aria-label="Permalink to &quot;三阶段提交协议&quot;">​</a></h3><p>为了解决二阶段协议中的同步阻塞等问题，三阶段提交协议在协调者和参与者中都引入了超时机制，并且把[[两阶段提交]]协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。</p><p>三阶段中的 Three Phase 分别为 CanCommit、PreCommit、DoCommit 阶段。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312280903687.png" alt="image.png"></p><h4 id="cancommit-阶段" tabindex="-1">CanCommit 阶段 <a class="header-anchor" href="#cancommit-阶段" aria-label="Permalink to &quot;CanCommit 阶段&quot;">​</a></h4><p>3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 Can-Commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p><h4 id="precommit-阶段" tabindex="-1">PreCommit 阶段 <a class="header-anchor" href="#precommit-阶段" aria-label="Permalink to &quot;PreCommit 阶段&quot;">​</a></h4><p>协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p><p>A. 假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会进行事务的预执行：</p><ul><li><strong>发送预提交请求</strong>，协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段；</li><li><strong>事务预提交</strong>，参与者接收到 PreCommit 请求后，会执行事务操作；</li><li><strong>响应反馈</strong>，如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</li></ul><p>B. 假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就中断事务：</p><ul><li><strong>发送中断请求</strong>，协调者向所有参与者发送 abort 请求；</li><li><strong>中断事务</strong>，参与者收到来自协调者的 abort 请求之后，执行事务的中断。</li></ul><h4 id="docommit-阶段" tabindex="-1">DoCommit 阶段 <a class="header-anchor" href="#docommit-阶段" aria-label="Permalink to &quot;DoCommit 阶段&quot;">​</a></h4><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><p>A. 执行提交</p><ul><li>发送提交请求。协调者接收到参与者发送的 ACK 响应后，那么它将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求。</li><li>事务提交。参与者接收到 doCommit 请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源。</li><li>响应反馈。事务提交完之后，向协调者发送 ACK 响应。</li><li>完成事务。协调者接收到所有参与者的 ACK 响应之后，完成事务。</li></ul><p>B. 中断事务 协调者没有接收到参与者发送的 ACK 响应，可能是因为接受者发送的不是 ACK 响应，也有可能响应超时了，那么就会执行中断事务。</p><p>C.超时提交 参与者如果没有收到协调者的通知，超时之后会执行 Commit 操作。</p><h3 id="三阶段提交做了哪些改进" tabindex="-1">三阶段提交做了哪些改进 <a class="header-anchor" href="#三阶段提交做了哪些改进" aria-label="Permalink to &quot;三阶段提交做了哪些改进&quot;">​</a></h3><h4 id="引入超时机制" tabindex="-1">引入超时机制 <a class="header-anchor" href="#引入超时机制" aria-label="Permalink to &quot;引入超时机制&quot;">​</a></h4><p>在 2PC 中，<strong>只有协调者拥有超时机制</strong>，如果在一定时间内没有收到参与者的消息则默认失败，3PC 同时在协调者和参与者中都引入超时机制。</p><h4 id="添加预提交阶段" tabindex="-1">添加预提交阶段 <a class="header-anchor" href="#添加预提交阶段" aria-label="Permalink to &quot;添加预提交阶段&quot;">​</a></h4><p>在 2PC 的准备阶段和提交阶段之间，插入一个准备阶段，使 3PC 拥有 CanCommit、PreCommit、DoCommit 三个阶段，PreCommit 是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。</p><h4 id="三阶段提交协议存在的问题" tabindex="-1">三阶段提交协议存在的问题 <a class="header-anchor" href="#三阶段提交协议存在的问题" aria-label="Permalink to &quot;三阶段提交协议存在的问题&quot;">​</a></h4><p>三阶段提交协议同样存在问题，具体表现为，在阶段三中，如果参与者接收到了 PreCommit 消息后，出现了不能与协调者正常通信的问题，在这种情况下，参与者依然会进行事务的提交，这就出现了数据的不一致性。</p>',25),m=[r];function l(n,s,h,c,p,d){return t(),o("div",null,m)}const _=a(i,[["render",l]]);export{u as __pageData,_ as default};
