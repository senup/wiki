import{_ as s,o as a,c as n,R as l}from"./chunks/framework.7FlijoJG.js";const u=JSON.parse('{"title":"泛型","description":"","frontmatter":{"title":"泛型","date":"2023-12-27T13:55:01.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"Java相关/泛型.md","filePath":"Java相关/泛型.md","lastUpdated":1711296414000}'),p={name:"Java相关/泛型.md"},e=l(`<h2 id="泛型擦除" tabindex="-1">泛型擦除 <a class="header-anchor" href="#泛型擦除" aria-label="Permalink to &quot;泛型擦除&quot;">​</a></h2><p>在计算机科学中，类型擦除（Type Erasure）是 Java 编译器在编译过程中，将泛型的类型参数替换为其上限，如果类型参数未指定上限，如  <code>&lt;T&gt;</code>，则会被替换为 Object。这种工作机制使得 Java 的泛型既具有静态类型安全性，又能够与许多不支持泛型的库在二进制层面兼容。</p><p>例如，你写了一个这样的泛型类：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Box</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> T t;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(T </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) { </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t; }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> T </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t; }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Box</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> T t;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(T </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) { </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t; }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> T </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">() { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t; }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>由于类型擦除，Java 编译器会将其转换成一般的类，如下面形式：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public class Box {</span></span>
<span class="line"><span style="color:#e1e4e8;">    private Object t;</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void set(Object t) { this.t = t; }</span></span>
<span class="line"><span style="color:#e1e4e8;">    public Object get() { return t; }</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class Box {</span></span>
<span class="line"><span style="color:#24292e;">    private Object t;</span></span>
<span class="line"><span style="color:#24292e;">    public void set(Object t) { this.t = t; }</span></span>
<span class="line"><span style="color:#24292e;">    public Object get() { return t; }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>然后，编译器在编译时会确保你只能将正确的类型放入 Box 中，并且每次从 Box 中获取项时，都会将其强制转换为正确的类型。</p><p>类型擦除也导致了一些限制或问题，比如：</p><ul><li>运行时类型查询只适用于原始类型：由于类型信息在运行时被擦除，所以像  <code>if (object instanceof List&lt;String&gt;)</code>  这样的语句是非法的。</li><li>不能创建泛型数组：例如  <code>new List&lt;String&gt;[3]</code>  是非法的。 这是因为在运行时，数组必须知道其实际类型，而由于类型擦除，这是无法做到的。</li><li>与泛型无关的类只能有一个实例：如果一个类只依赖类型参数，那么它们将在运行时被视为同一类型，如  <code>List&lt;String&gt;</code>  和  <code>List&lt;Integer&gt;</code>。</li><li>泛型类中的静态环境无法引用类型参数：由于类型擦除，类型参数在运行时将不存在，所以无法在静态变量或方法中引用类型参数。</li></ul><p>虽然类型擦除带来了一些限制，但也使 Java 泛型能够与旧的非泛型代码兼容。这是一种权衡和妥协。</p><h2 id="导致的问题" tabindex="-1">导致的问题 <a class="header-anchor" href="#导致的问题" aria-label="Permalink to &quot;导致的问题&quot;">​</a></h2><p>一些类型擦除可能带来的问题：</p><ol><li>无法进行某些操作，如实例化：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public class Test&lt;T&gt; {</span></span>
<span class="line"><span style="color:#e1e4e8;">    T item;</span></span>
<span class="line"><span style="color:#e1e4e8;">    public Test() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        item = new T(); //错误，不能实例化类型变量</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class Test&lt;T&gt; {</span></span>
<span class="line"><span style="color:#24292e;">    T item;</span></span>
<span class="line"><span style="color:#24292e;">    public Test() {</span></span>
<span class="line"><span style="color:#24292e;">        item = new T(); //错误，不能实例化类型变量</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>在这里，我们无法实例化类型变量 T，因为编译器在运行时不知道 T 是什么。</p><ol start="2"><li>泛型数组：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1]; // 报错，不能创建具体类型的泛型数组</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1]; // 报错，不能创建具体类型的泛型数组</span></span></code></pre></div><p>由于类型擦除，Java 不能创建确切类型的泛型数组</p><ol start="3"><li>静态字段或方法中使用类型参数：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public class Test&lt;T&gt; {</span></span>
<span class="line"><span style="color:#e1e4e8;">    static T item; //错误，不能在静态字段声明中使用类型参数</span></span>
<span class="line"><span style="color:#e1e4e8;">    static T getItem() {</span></span>
<span class="line"><span style="color:#e1e4e8;">        return item; //错误，不能在静态方法声明中使用类型参数</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class Test&lt;T&gt; {</span></span>
<span class="line"><span style="color:#24292e;">    static T item; //错误，不能在静态字段声明中使用类型参数</span></span>
<span class="line"><span style="color:#24292e;">    static T getItem() {</span></span>
<span class="line"><span style="color:#24292e;">        return item; //错误，不能在静态方法声明中使用类型参数</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>在静态成员中，你无法访问类的类型变量，因为它们在静态成员层次是不可知的。</p><ol start="4"><li>无法取得泛型中类型信息：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public void printType(List&lt;T&gt; list){</span></span>
<span class="line"><span style="color:#e1e4e8;">    if(list instanceof ArrayList&lt;Integer&gt;){ // 错误，无法使用参数化类型和instanceof运算符</span></span>
<span class="line"><span style="color:#e1e4e8;">        System.out.println(&quot;Integer ArrayList&quot;);</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public void printType(List&lt;T&gt; list){</span></span>
<span class="line"><span style="color:#24292e;">    if(list instanceof ArrayList&lt;Integer&gt;){ // 错误，无法使用参数化类型和instanceof运算符</span></span>
<span class="line"><span style="color:#24292e;">        System.out.println(&quot;Integer ArrayList&quot;);</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>由于类型擦除，你不能在运行时检查一个对象是否为指定的泛型类型。</p><ol start="5"><li>异常处理：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">public class TestException&lt;T&gt; extends Exception {}   //错误，泛型类不能继承Throwable</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">public class TestException&lt;T&gt; extends Exception {}   //错误，泛型类不能继承Throwable</span></span></code></pre></div><p>这个错误的原因是 Java 的异常处理机制并不支持参数化类型。</p><h2 id="如何解决" tabindex="-1">如何解决 <a class="header-anchor" href="#如何解决" aria-label="Permalink to &quot;如何解决&quot;">​</a></h2><p>由于 JVM 在运行时，会对泛型进行类型擦除，你无法直接使用 instanceof 来判断一个对象是否为指定的泛型类型。然而，依然有一些方式可以突破这个局限。</p><ol><li>比如，如果你使用了泛型类，并在类内部用到了泛型 T，你可在类初始化的时候传入一个 Class <code>&lt;</code> T <code>&gt;</code> 类型的参数，用来保存泛型的实际类型。这样，在运行时你就能拿到泛型的具体类型了。</li></ol><p>例如以下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyGenericClass</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Class&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; type;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyGenericClass</span><span style="color:#E1E4E8;">(Class&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">type</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.type </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> type;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isInstanceOfType</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.type.</span><span style="color:#B392F0;">isInstance</span><span style="color:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyGenericClass</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Class&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; type;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyGenericClass</span><span style="color:#24292E;">(Class&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">type</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.type </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> type;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isInstanceOfType</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.type.</span><span style="color:#6F42C1;">isInstance</span><span style="color:#24292E;">(obj);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>然后你就可以像这样创建实例和使用了：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">MyGenericClass&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; stringClass </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> MyGenericClass&lt;&gt;(String.class);</span></span>
<span class="line"><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> isString </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stringClass.</span><span style="color:#B392F0;">isInstanceOfType</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">MyGenericClass&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; stringClass </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> MyGenericClass&lt;&gt;(String.class);</span></span>
<span class="line"><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> isString </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> stringClass.</span><span style="color:#6F42C1;">isInstanceOfType</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Hello, World!&quot;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>这里的 isString 的值就会是 true，因为&quot;Hello, World!&quot;确实是个 String。</p><ol start="2"><li>另外，如果你只是需要判断一个集合 Container（比如 List、Map 等）的元素类型，你可以通过遍历集合元素的方式，对这些元素进行 instanceof 操作。</li></ol><h2 id="通配符" tabindex="-1">通配符 <a class="header-anchor" href="#通配符" aria-label="Permalink to &quot;通配符&quot;">​</a></h2><p>首先从 &quot;? extends T&quot; 开始，这称之为&quot;上界通配符&quot;。当你看到这种结构时，可以理解为类型参数是 T 或者 T 的某个子类。比如 List <code>&lt;</code>? extends Number <code>&gt;</code>，就表示这个列表可以接受任何 Number 的子类，包括 Integer，Double，Float 等等。它经常用于你希望从泛型实例来读取（或生产）数据的情况，因为你知道从该实例读取的数据肯定是 Number 或 Number 的子类。</p><p>相对地，&quot;? super T&quot; 表示的是&quot;下界通配符&quot;，表示类型参数是 T 或者 T 的某个父类。比如 List <code>&lt;</code>? super Integer <code>&gt;</code>，它表示这个列表接受的类型为 Integer 或者其父类。它常常用于写入（或消费）数据到泛型实例的场景，因为你可以安全地放入一个 Integer 对象。</p><p>以下是一对它们用法的例子：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//上界通配符</span></span>
<span class="line"><span style="color:#E1E4E8;">List&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Number</span><span style="color:#E1E4E8;">&gt; list1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#6A737D;">//list1.add(new Integer(1)); //这行会报错,因为编译器无法确定List具体接受的类型是什么，编译器只允许读取。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//下界通配符</span></span>
<span class="line"><span style="color:#E1E4E8;">List&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">super</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; list2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;</span><span style="color:#F97583;">Number</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">list2.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Integer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">//可以添加Integer对象，没有问题</span></span>
<span class="line"><span style="color:#6A737D;">//Integer number = list2.get(0); //这行会报错，从list2读取数据时，编译器只知道可以接收Integer或者其父类型，但具体是什么类型，编译器是不能确定的，所以这会引发编译错误</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//上界通配符</span></span>
<span class="line"><span style="color:#24292E;">List&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Number</span><span style="color:#24292E;">&gt; list1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#6A737D;">//list1.add(new Integer(1)); //这行会报错,因为编译器无法确定List具体接受的类型是什么，编译器只允许读取。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//下界通配符</span></span>
<span class="line"><span style="color:#24292E;">List&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">super</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; list2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;</span><span style="color:#D73A49;">Number</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#24292E;">list2.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Integer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)); </span><span style="color:#6A737D;">//可以添加Integer对象，没有问题</span></span>
<span class="line"><span style="color:#6A737D;">//Integer number = list2.get(0); //这行会报错，从list2读取数据时，编译器只知道可以接收Integer或者其父类型，但具体是什么类型，编译器是不能确定的，所以这会引发编译错误</span></span></code></pre></div><p>总结一下：只向泛型对象写入（或&quot;放入&quot;，比如 List.add()方法），使用&quot;生产者&quot; 泛型通配符  <code>? extends T</code>；只从泛型对象读取（或&quot;取出&quot;，比如 List.get()方法），使用&quot;消费者&quot;泛型通配符  <code>? super T</code>。这就是所谓 &quot;PECS&quot; 原则：Producer（生产者） Extends, Consumer（消费者） Super。</p>`,42),o=[e];function t(c,r,i,y,E,d){return a(),n("div",null,o)}const b=s(p,[["render",t]]);export{u as __pageData,b as default};
