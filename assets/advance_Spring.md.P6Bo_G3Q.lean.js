import{_ as o,D as p,o as r,c as l,k as e,a,I as s,w as t,R as i}from"./chunks/framework.7FlijoJG.js";const z=JSON.parse('{"title":"Hello，Spring","description":"","frontmatter":{"title":"Hello，Spring","date":"2023-11-20T12:51:42.000Z","tags":["tech","hello","spring","Java"],"draft":false,"hideInList":false,"feature":null,"isTop":false},"headers":[],"relativePath":"advance/Spring.md","filePath":"advance/Spring.md","lastUpdated":1700722983000}'),c={name:"advance/Spring.md"},g=i("",130),u=i("",24),m=e("p",null,"这一节，我们了解了 Spring 是如何检查 prototype 类型的 bean 正在创建的，因为 prototype 类型的 bean 不像单例 bean 一样可以缓存，所以，一旦发现有 prototype 类型的 bean 正在创建，就会直接抛异常了。",-1),h=e("p",null,"而且我们也看到了，如果为 Spring 容器设置父类容器，那 Spring 在找不到当前 bean 的 BeanDefinition 时，就会到父类容器中获取 bean 的实例了。",-1),b=e("p",null,"接着，我们看到 Spring 最终会获取我们前面注册好的 BeanDefinition，将 GenericBeanDefnition 封装次 RootBeanDefinition，并且我们也看到了 bean 默认的类型就是单例的。",-1),d=e("p",null,"而且，如果 bean 配置了依赖的 bean 的名称，首先会检查下配置的依赖，是否已经处于 bean 依赖的引用链上了，如果没有处于 bean 依赖引用链上，就会提前来实例化 bean 依赖的那些 bean。",-1),y=e("blockquote",null,[e("p",null,"prototype 的 Bean 如果被发现被获取的时候就会直接抛出异常。为什么呢？因为不需要获取，每次都得拿最新创建的 Bean。")],-1),f=e("ol",null,[e("li",null,"先来简单看下 Spring 在实例化 bean 前后都会做些什么事情，寻找下真正实例化 bean 的入口在哪"),e("li",null,"然后来看下 Spring 在实例化之前，会做哪些准备工作"),e("li",null,"最后来看下 Spring 又是如何在 bean 实例化之前，提供一个机会让外界去介入 bean 的实例化过程的")],-1);function B(x,P,k,q,S,_){const n=p("font");return r(),l("div",null,[g,e("p",null,[a("SingletonObjects 这个缓存主要是用来存放已经"),s(n,{color:"#2DC26B"},{default:t(()=>[a("完全")]),_:1}),a("实例化好的单例 bean。")]),u,s(n,{color:"#2DC26B"},{default:t(()=>[a("factoryBean 有什么优势")]),_:1}),m,h,b,d,y,f])}const D=o(c,[["render",B]]);export{z as __pageData,D as default};
