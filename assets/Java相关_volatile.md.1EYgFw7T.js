import{_ as s,o as n,c as a,R as l}from"./chunks/framework.7FlijoJG.js";const h=JSON.parse('{"title":"volatile","description":"","frontmatter":{"title":"volatile","date":"2024-01-18T08:57:48.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"Java相关/volatile.md","filePath":"Java相关/volatile.md","lastUpdated":1711296414000}'),o={name:"Java相关/volatile.md"},p=l(`<h2 id="✅有了synchronized为什么还需要volatile" tabindex="-1">✅有了synchronized为什么还需要volatile? <a class="header-anchor" href="#✅有了synchronized为什么还需要volatile" aria-label="Permalink to &quot;✅有了synchronized为什么还需要volatile?&quot;">​</a></h2><p>双重检查锁（Double Checked Locking Pattern）是一种常用的单例实现方式，它的精髓就在于“轻则获取，重则同步”，这个模式的话，絮絮叨叨就有点破坏了节奏，让我们直接看代码吧：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Singleton</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Singleton instance;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Singleton </span><span style="color:#B392F0;">getInstance</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (instance </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">synchronized</span><span style="color:#E1E4E8;"> (Singleton.class) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (instance </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    instance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Singleton</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 其他代码...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Singleton</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Singleton instance;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Singleton </span><span style="color:#6F42C1;">getInstance</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (instance </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> (Singleton.class) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (instance </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    instance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Singleton</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> instance;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 其他代码...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这份代码中，<code>volatile</code>关键字起了一个非常重要的作用。当<code>instance = new Singleton()</code>这样的代码运行的时候，它实际上分为三个步骤：</p><ol><li>为<code>Singleton</code>对象分配内存；</li><li>在内存中初始化这个<code>Singleton</code>对象；</li><li>将<code>instance</code>变量指向分配的内存空间。</li></ol><p>然后问题就来了，由于 Java 有一种叫做<code>指令重排</code>的机制，上面三个步骤可能会变为 1→3→2 这样的顺序。这就意味着，一个线程可能在第三步的时候，刚好另一个线程在外面的<code>if</code>中检查到<code>instance</code>不为空，然后这个线程就会直接返回一个还没有被初始化的<code>instance</code>，就像是你的朋友把你新买的但是还没有装配的组装模型拿去展示，这肯定是万万不行的。</p><p>而加了<code>volatile</code>后，就可以禁止指令重排，确保<code>instance</code>每次都是在被初始化后才被写入，因此其他线程在读取到的<code>instance</code>只可能是一份完全初始化好的实例。</p><p>所以说，<code>volatile</code>就像是那个守夜人，在黑夜中为我们的<code>Singleton</code>守护安全，不被还没完全初始化就被别的线程拿去用。你看，是不是又有一丝英雄主义的浪漫呢，哈哈~</p><h2 id="重排序" tabindex="-1">重排序 <a class="header-anchor" href="#重排序" aria-label="Permalink to &quot;重排序&quot;">​</a></h2><p>比如一个 new 的操作,实际上会先1.分配内存空间,2.对象初始化,3.赋值给变量. 但是重排序导致 132，这种情况就可能第二个线程拿到了没初始化完成的一个变量。 因此，使用 volatile 就能禁止指令重排序</p>`,10),e=[p];function c(t,r,i,E,y,d){return n(),a("div",null,e)}const u=s(o,[["render",c]]);export{h as __pageData,u as default};
