import{_ as t,o as e,c as d,R as a}from"./chunks/framework.7FlijoJG.js";const S=JSON.parse('{"title":"死锁","description":"","frontmatter":{"title":"死锁","date":"2023-12-23T18:33:35.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"多线程/死锁.md","filePath":"多线程/死锁.md","lastUpdated":1711296414000}'),o={name:"多线程/死锁.md"},l=a('<h2 id="锁" tabindex="-1">锁 <a class="header-anchor" href="#锁" aria-label="Permalink to &quot;锁&quot;">​</a></h2><p>关于 InnoDB 所有的锁、SQL 案例、是否显式以及最佳实践的表格：</p><p>我们深度解析下这些锁：</p><ol><li>记录锁：它直接作用于一行记录。使用<code>SELECT ... FOR UPDATE</code>或<code>SELECT ... LOCK IN SHARE MODE</code>，或者直接进行 UPDATE，DELETE 操作时都会产生记录锁。</li><li>间隙锁：和记录锁不同，它锁定的是一个范围，而非具体的行。当执行类似<code>DELETE FROM table WHERE col between val1 and val2;</code>的操作时，所有 col 在 val1 ~ val2 范围内的行不仅会被记录锁锁住，且会对这个范围加上间隙锁，阻止其他事务插入新记录。</li><li>临键锁：这个大块头是记录锁和间隙锁的混合体。当我们进行范围查找并进行了某些类型的锁定操作时，比如<code>SELECT * FROM table WHERE col between val1 and val2 FOR UPDATE;</code>，InnoDB 就会使用临键锁来锁定符合条件的范围，既锁定找到的记录，又锁定间隙。</li><li>插入意向锁：这个小家伙是一个特别的间隙锁，它在插入记录前的预处理阶段就会起作用，告知其他事务有一个插入操作正在等待对间隙加锁，这样有利于多个事务并发插入，提升效率。</li></ol><table><thead><tr><th>锁类型</th><th>SQL 案例</th><th>是否显式</th><th>最佳实践</th></tr></thead><tbody><tr><td>行共享锁（S）</td><td>SELECT ... LOCK IN SHARE MODE</td><td>是</td><td>如果你需要读取一行数据并且希望别人不能修改这行数据，可以使用此锁</td></tr><tr><td>行排他锁（X）</td><td>SELECT ... FOR UPDATE</td><td>是</td><td>如果你需要修改一行数据并且希望别人不能访问这行数据，可以使用此锁</td></tr><tr><td>间隙锁</td><td>UPDATE ... WHERE ... (满足某些条件)</td><td>否</td><td>InnoDB 用于防止幻读，一般不需要人为干预</td></tr><tr><td>Next-key 锁</td><td>SELECT ... WHERE ... (扫描范围)，并用 FOR UPDATE 或 LOCK IN SHARE MODE</td><td>否</td><td>InnoDB 默认使用，结合了行锁和间隙锁的特性，一般无需人为干预</td></tr><tr><td>表锁（IS/IX）</td><td>ALTER TABLE ...</td><td>否</td><td>当更改表结构时，InnoDB 会自动使用，一般不需要人为干预</td></tr></tbody></table><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312232007127.png" alt="image.png"></p><ol><li><p>记录锁 (Record Lock)：</p><ul><li><code>UPDATE Staff SET position = &#39;Manager&#39; WHERE id = 101;</code>  这条语句会在 ID 为 101 的记录上设置记录锁。</li><li><code>DELETE FROM Staff WHERE id = 202;</code>  这条语句会在 ID 为 202 的记录上设置记录锁。</li><li><code>SELECT * FROM Staff WHERE id = 303 FOR UPDATE;</code>  这条语句会在 ID 为 303 的记录上设置记录锁。</li></ul></li><li><p>间隙锁 (Gap Lock)：</p><ul><li><code>SELECT * FROM Staff WHERE id BETWEEN 101 AND 200 LOCK IN SHARE MODE;</code>  这个语句会在 ID 从 101 到 200 之间的区间设置间隙锁。</li><li><code>DELETE FROM Staff WHERE id BETWEEN 201 AND 300;</code>  这个语句会在 ID 从 201 到 300 之间的区间设置间隙锁。</li><li><code>INSERT INTO Staff (id, name) VALUES (150, &#39;New Guy&#39;);</code>  如果 ID 值 150 之前没有记录，那么这个语句会在插入点和下一个存在的记录之间设置间隙锁。</li></ul></li><li><p>临键锁 (Next Key Lock)：</p><ul><li><code>SELECT * FROM Staff WHERE id BETWEEN 101 AND 200 FOR UPDATE;</code>  这个语句会在 ID 从 101 到 200 的记录和间隙设置临键锁。</li><li><code>UPDATE Staff SET position = &#39;Manager&#39; WHERE id BETWEEN 201 AND 300;</code>  这个语句会在 ID 从 201 到 300 的记录和间隙设置临键锁。</li><li><code>DELETE FROM Staff WHERE id BETWEEN 301 AND 400;</code>  这个语句会在 ID 从 301 到 400 的记录和间隙设置临键锁。</li></ul></li><li><p>插入意向锁 (Insert Intention Lock)：</p><ul><li><code>INSERT INTO Staff (id, name) VALUES (150, &#39;New Guy&#39;);</code>  如果有其他会话正在尝试插入 ID 值在 150 附近的记录，那么这个语句会在插入点设置插入意向锁。</li><li><code>INSERT INTO Staff (id, name) VALUES (250, &#39;Another Guy&#39;);</code>  如果有其他会话正在尝试插入 ID 值在 250 附近的记录，那么这个语句会在插入点设置插入意向锁。</li><li><code>INSERT INTO Staff (id, name) VALUES (350, &#39;Yet Another Guy&#39;);</code>  如果有其他会话正在尝试插入 ID 值在 350 附近的记录，那么这个语句会在插入点设置插入意向锁。</li></ul></li></ol><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h2><ul><li><strong>临键锁</strong>：不仅锁定了具体行，也锁定了下一个键值所代表的间隙，确保插入新数据或者修改间隙内数据的操作都被阻塞。</li><li><strong>间隙锁</strong>：针对范围内的数据，锁定了键值之间的间隙，阻止其他事务在该范围内插入新数据。</li></ul><p>我自己的理解：临键锁是两个事务在同一时刻执行，会锁住中间的间隙和下一行，确保新插入数据和修改间隙内的数据。 间隙锁是一个事务查询范围内的都将被锁住。</p><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h2><p>1.杜绝滥用事务，尽量避免使用事务</p><p>2.事务中更新必须使用 id 更新，批量更新必须按 id 正序排序更新；</p><p>3.事务中涉及多个表更新需按表名字母排序顺序更新(可参考数据库客户端中表名顺序）</p><p>4.拆分事务颗粒度避免大事务</p><p>5.禁止使用 insert or update 参考：[[insertOrUpdate导致的死锁]]</p><h2 id="实战" tabindex="-1">实战 <a class="header-anchor" href="#实战" aria-label="Permalink to &quot;实战&quot;">​</a></h2><p>[[线上死锁排查]]</p>',18),E=[l];function i(c,n,r,s,T,p){return e(),d("div",null,E)}const h=t(o,[["render",i]]);export{S as __pageData,h as default};
