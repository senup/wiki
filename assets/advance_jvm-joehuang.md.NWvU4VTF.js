import{_ as a,o as t,c as e,R as n}from"./chunks/framework.7FlijoJG.js";const d=JSON.parse('{"title":"jvm-joehuang","description":"","frontmatter":{"title":"jvm-joehuang","date":"2023-12-22T14:36:27.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"advance/jvm-joehuang.md","filePath":"advance/jvm-joehuang.md","lastUpdated":1703229339000}'),o={name:"advance/jvm-joehuang.md"},i=n('<h2 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;JVM&quot;">​</a></h2><p>JVM，也就是 Java 虚拟机，可以说是 Java 程序的执行引擎。它负责将 Java 源代码编译成能在特定平台上运行的字节码，这样就能在不同的设备上无缝运行。</p><p>JVM 也有自己的内存管理系统，负责内存的分配和回收，确保程序运行的高效性和稳定性。</p><p>简单来说，JVM 就像是 Java 程序和计算机硬件之间的桥梁，让 Java 代码能够在各种环境中运行。</p><h2 id="jvm、jre、jdk-分别是什么关系" tabindex="-1">JVM、JRE、JDK 分别是什么关系？ <a class="header-anchor" href="#jvm、jre、jdk-分别是什么关系" aria-label="Permalink to &quot;JVM、JRE、JDK 分别是什么关系？&quot;">​</a></h2><p>JVM 是 Java 虚拟机，是 Java 程序的执行引擎； JRE 是 Java 运行时环境，包含了 JVM 和 Java 程序运行所需的核心类库；而 JDK 则是 Java 开发工具包，里面集成了 JRE，也包含了开发 Java 程序所需的编译器、调试器等开发工具。</p><p>想象成房子吧，JVM 就是房子的框架，JRE 是房子的基础和结构，而 JDK 则是整个房子，包括了框架、基础和装修。</p><p>在开发 Java 程序时，需要 JDK 来编写代码、编译和运行程序； 而在运行 Java 程序时，只需要 JRE，因为它包含了程序运行所需的环境和库。</p><h2 id="jvm-的内存模型" tabindex="-1">JVM 的内存模型 <a class="header-anchor" href="#jvm-的内存模型" aria-label="Permalink to &quot;JVM 的内存模型&quot;">​</a></h2><p>JVM 的内存模型描述了在运行 Java 程序时，JVM 如何组织和管理内存。它包括了不同的内存区域，每个区域都有自己的作用和特点。</p><h3 id="_1-内存模型的内容和作用" tabindex="-1">1. 内存模型的内容和作用 <a class="header-anchor" href="#_1-内存模型的内容和作用" aria-label="Permalink to &quot;1. 内存模型的内容和作用&quot;">​</a></h3><ul><li><strong>方法区（Method Area）</strong>：用来存储类结构信息、常量、静态变量等。在 Java 8 之前，这里还有永久代（PermGen），但在 Java 8 后被元空间（Metaspace）所取代。</li><li><strong>堆（Heap）</strong>：存放对象实例，是被所有线程共享的内存区域。通过垃圾回收来管理，主要分为新生代（Young Generation）和老年代（Old Generation）等不同区域。</li><li><strong>栈（Stack）</strong>：每个线程都有自己的栈，存储局部变量、方法调用、部分结果等。栈分为<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。虚拟机栈用于存储方法调用和局部变量，而本地方法栈是针对 Native 方法服务的。</li><li><strong>程序计数器（Program Counter Register）</strong>：存储当前线程执行的字节码指令地址，也就是当前线程所执行的位置。</li></ul><h3 id="_2-两种栈" tabindex="-1">2. 两种栈 <a class="header-anchor" href="#_2-两种栈" aria-label="Permalink to &quot;2. 两种栈&quot;">​</a></h3><ul><li><strong>虚拟机栈（Java Virtual Machine Stack）</strong>：用于存储方法执行过程中的局部变量、操作数栈、动态链接、方法出口等信息。</li><li><strong>本地方法栈（Native Method Stack）</strong>：与虚拟机栈类似，但是服务于 Native 方法。</li></ul><h3 id="_3-堆和栈的区别" tabindex="-1">3. 堆和栈的区别 <a class="header-anchor" href="#_3-堆和栈的区别" aria-label="Permalink to &quot;3. 堆和栈的区别&quot;">​</a></h3><ul><li><strong>堆</strong>是用于存放对象实例的区域，通过垃圾回收机制进行管理，是所有线程共享的内存区域。</li><li><strong>栈</strong>是为每个线程分配的内存区域，用于存放线程私有的局部变量、方法调用等信息。</li></ul><h3 id="_4-1-6-到-1-8-的区域变化" tabindex="-1">4. 1.6 到 1.8 的区域变化 <a class="header-anchor" href="#_4-1-6-到-1-8-的区域变化" aria-label="Permalink to &quot;4. 1.6 到 1.8 的区域变化&quot;">​</a></h3><p>在 Java 1.6 到 1.8 中，最大的变化是元空间（Metaspace）取代了永久代（PermGen）。永久代存放类的元数据信息、字符串常量池等，在大量使用动态生成类的场景下容易出现 PermGen Space 内存溢出。元空间使用的是本地内存，解决了永久代的一些限制，但需要注意控制元空间的大小，以防止系统内存被耗尽。</p><h2 id="内存的两种分配方式-以及如何保证分配内存是线程安全" tabindex="-1">内存的两种分配方式，以及如何保证分配内存是线程安全 <a class="header-anchor" href="#内存的两种分配方式-以及如何保证分配内存是线程安全" aria-label="Permalink to &quot;内存的两种分配方式，以及如何保证分配内存是线程安全&quot;">​</a></h2><p>在内存管理中，有两种主要的分配方式：指针碰撞（Bump Pointer）和空闲列表（Free List）。</p><ol><li><strong>指针碰撞（Bump Pointer）</strong>：在内存中，堆空间被划分为已使用和未使用的部分。当使用指针碰撞方式时，内存中有一个指针（称为“分配指针”），用于标记未使用内存的起始位置。当需要分配内存时，JVM 通过移动这个分配指针来分配内存，把分配指针后移相应大小的空间，指向分配后的内存起始位置。这种方式要求堆内存空间的分配是连续的，因为分配指针需要持续移动。</li><li><strong>空闲列表（Free List）</strong>：与指针碰撞不同，空闲列表方式不要求内存空间必须是连续的。它将空闲的内存空间以链表的形式组织起来，记录每块内存的大小和是否可用。当需要分配内存时，JVM 会在空闲列表中寻找合适大小的空闲块，然后标记为已分配。当内存释放时，将被释放的内存块加入到空闲列表中，以便后续分配使用。</li></ol><p>为了保证内存分配的线程安全性，通常采取以下策略：</p><ul><li><strong>线程封闭（Thread Confinement）</strong>：每个线程分配独立的内存区域，避免多线程之间的竞争。</li><li><strong>加锁（Locking）</strong>：使用锁机制来保证在分配或释放内存时只有一个线程可以操作，保证操作的原子性和互斥性。</li><li><strong>CAS（Compare and Swap）</strong>：使用 CAS 操作确保对内存的原子性操作，避免并发冲突。</li><li><strong>空闲列表的并发处理</strong>：在多线程环境中，对空闲列表的操作需要考虑并发性，使用适当的同步机制来保证线程安全。</li></ul><p>这些方法可以帮助确保内存分配的线程安全性，以防止不同线程之间出现竞争条件或数据不一致的情况。</p><hr><p>当我们写程序时，计算机需要地方来存储数据。就像是一个房子要安置家具一样，计算机要存放程序需要的数据。有两种主要的方式来安排这个存储空间：</p><ol><li><strong>指针碰撞（Bump Pointer）</strong>：就像是有一块空地，我们用一个箭头指着可以放家具的地方。每当需要放一个新的东西，箭头就会指向下一个空地，这样就能一个一个地放进去。</li><li><strong>空闲列表（Free List）</strong>：这个方式像是一张列表，上面记录了哪些地方有空地可放家具。当需要放东西时，就找到列表上一个空地，然后把东西放进去，同时在列表上做标记说这个地方已经有东西了。</li></ol><p>为了确保多个人同时放东西不乱套，我们有几个办法：</p><ul><li><strong>每个人有自己的地盘</strong>：就像是每个人有自己的房间一样，不会和别人抢一个地方放东西。</li><li><strong>有人指挥大家放东西</strong>：就像有一个管理者，大家想放东西的时候得先问问他，这样不会乱成一团。</li><li><strong>大家轮流来放东西</strong>：每次只有一个人能放东西，其他人得等着，这样不会同时抢着放东西。</li></ul><p>这些方法保证了放置家具时不会出现混乱，每个家具都能被安排到合适的地方。就像是大家有规矩和秩序一样，保证了数据存储的顺利进行。</p><h2 id="类和对象加载" tabindex="-1">类和对象加载 <a class="header-anchor" href="#类和对象加载" aria-label="Permalink to &quot;类和对象加载&quot;">​</a></h2><h3 id="类加载和对象创建的关系" tabindex="-1">类加载和对象创建的关系 <a class="header-anchor" href="#类加载和对象创建的关系" aria-label="Permalink to &quot;类加载和对象创建的关系&quot;">​</a></h3><p>类加载和对象创建的关系，是个很奇妙的话题。我喜欢将类加载看作是建立蓝图，而创建对象就像使用这个蓝图建造房子。</p><p>首先，类加载器负责找到你的蓝图（也就是类的字节码文件），然后解析它，然后准备好相关的材料，最后生产出一份可以用来建造房子的蓝图。这个过程就是“加载”、“链接”和“初始化”。</p><p>然后，每当你实例化一个新对象（也就是 new 一个对象）时，Java 就会根据这个蓝图在内存中划出一块空间，再按照蓝图上的设计进行建造，也就是给这个对象的各个属性赋值，完成了你房子的建造，得到了一个新的对象。</p><h3 id="有几种类加载噐" tabindex="-1">有几种类加载噐 <a class="header-anchor" href="#有几种类加载噐" aria-label="Permalink to &quot;有几种类加载噐&quot;">​</a></h3><p>类加载器主要有以下几种：</p><ol><li>引导类加载器（Bootstrap）</li><li>扩展类加载器（Extension）</li><li>系统类加载器或应用类加载器（System或Application）</li><li>自定义类加载器（Custom）</li></ol><h3 id="类的加载过程" tabindex="-1">类的加载过程 <a class="header-anchor" href="#类的加载过程" aria-label="Permalink to &quot;类的加载过程&quot;">​</a></h3><h3 id="什么是双亲委派模式" tabindex="-1">什么是双亲委派模式 <a class="header-anchor" href="#什么是双亲委派模式" aria-label="Permalink to &quot;什么是双亲委派模式&quot;">​</a></h3><p>对象的创建方式</p><p>对象的构造过程</p><p>对象的内部构造</p><p>对象头里面有什么</p><p>对象的两种访问方式</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221436675.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221436666.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221437781.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221437842.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221438964.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221438235.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221439236.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221439851.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221440185.png" alt="image.png"></p><p>最后一节实战可以用</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221440926.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221441263.png" alt="image.png"></p>',57),s=[i];function r(l,g,p,h,c,u){return t(),e("div",null,s)}const J=a(o,[["render",r]]);export{d as __pageData,J as default};
