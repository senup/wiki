import{_ as a,o as t,c as e,R as o}from"./chunks/framework.7FlijoJG.js";const f=JSON.parse('{"title":"java内存模型","description":"","frontmatter":{"title":"java内存模型","date":"2023-12-25T16:13:33.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"多线程/java内存模型.md","filePath":"多线程/java内存模型.md","lastUpdated":1711296414000}'),l={name:"多线程/java内存模型.md"},s=o("<ol><li><strong>主内存与工作内存</strong>：Java 内存模型规定了所有的变量都存在主内存中（类似于物理内存），每个线程都有自己的工作内存（类似于 CPU 的缓存），线程的工作内存中保存了被这个线程使用到的变量的主内存副本访问拷贝。</li><li><strong>内存间交互操作</strong>：线程对共享变量的所有操作必须在其工作内存中进行，不可以直接从主内存中读写。工作内存和主内存间的交互操作有：read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）、lock（锁定）和 unlock（解锁）。</li><li><strong>对 volatile 字段的访问定序规则</strong>：Java 内存模型特别规定了对 volatile 变量的访问机制。当要写入 volatile 变量时，JMM 会在代码前加入“StoreStore 内存屏障”，确保所有的普通变量先被更新到主内存中。然后才会将 volatile 变量更新到主内存。在读 volatile 变量时，JMM 会在代码后加入“LoadLoad 内存屏障”，确保所有读 volatile 变量的操作都完成后，再去读取普通变量。</li><li><strong>happens-before 原则</strong>：这个原则是 Java 内存模型中的一个重要概念，是判断数据是否存在竞争、线程是否安全的主要依据。它包含了一些基本的规则，如程序顺序规则、volatile 变量规则、锁规则、传递性等。</li><li><strong>以原子性、有序性和可见性为目标</strong>：Java 内存模型的主要目标是要定义程序中各个变量的访问规则，尤其在多线程环境下，这些访问规则用来保证线程之间的通信。这就涉及到原子性、有序性和可见性这三个重要概念。</li></ol>",1),r=[s];function i(n,_,c,d,v,p){return t(),e("div",null,r)}const u=a(l,[["render",i]]);export{f as __pageData,u as default};
