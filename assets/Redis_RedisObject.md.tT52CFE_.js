import{_ as s,o as a,c as e,R as n}from"./chunks/framework.7FlijoJG.js";const g=JSON.parse('{"title":"RedisObject","description":"","frontmatter":{"title":"RedisObject","date":"2024-01-10T11:14:22.000Z","tags":["Tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"Redis/RedisObject.md","filePath":"Redis/RedisObject.md","lastUpdated":1711296414000}'),p={name:"Redis/RedisObject.md"},l=n(`<h1 id="_1-简介" tabindex="-1">1.简介 <a class="header-anchor" href="#_1-简介" aria-label="Permalink to &quot;1.简介&quot;">​</a></h1><p>Redis 中的每个 Key-Value 在内存中都会被划分成 DictEntry 以及代表 Key 和 Value 的对象。</p><p>DictEntry 包含分别指向 Key 和 Value 对象的指针以及指向下一个 DictEntry 的指针。</p><p>Redis 使用 RedisObject 来表示对象，由于 Key 固定是字符串类型，因此使用字符串对象来表示，Value 可以是字符串、列表、哈希、集合、有序集合对象中的一种。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131622.png" alt=""></p><p>Redis 使用 redisObject 结构来表示对象（存储对象的相关信息）</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">typedef struct redisObject {</span></span>
<span class="line"><span style="color:#e1e4e8;">unsigned type;</span></span>
<span class="line"><span style="color:#e1e4e8;">unsigned encoding;</span></span>
<span class="line"><span style="color:#e1e4e8;">unsigned lru;</span></span>
<span class="line"><span style="color:#e1e4e8;">int refcount;</span></span>
<span class="line"><span style="color:#e1e4e8;">void ptr;</span></span>
<span class="line"><span style="color:#e1e4e8;">}robj;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">typedef struct redisObject {</span></span>
<span class="line"><span style="color:#24292e;">unsigned type;</span></span>
<span class="line"><span style="color:#24292e;">unsigned encoding;</span></span>
<span class="line"><span style="color:#24292e;">unsigned lru;</span></span>
<span class="line"><span style="color:#24292e;">int refcount;</span></span>
<span class="line"><span style="color:#24292e;">void ptr;</span></span>
<span class="line"><span style="color:#24292e;">}robj;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">type 属性：存储对象的类型（String、List、Hash、Set、ZSet 中的一种）</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">encoding 属性：存储对象使用的编码方式，不同的编码方式使用不同的数据结构进行存储。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">lru 属性：存储对象最后一次被访问的时间。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">refcount 属性：存储对象被引用的次数。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">ptr 指针：指向对象的地址。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">type 属性：存储对象的类型（String、List、Hash、Set、ZSet 中的一种）</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">encoding 属性：存储对象使用的编码方式，不同的编码方式使用不同的数据结构进行存储。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">lru 属性：存储对象最后一次被访问的时间。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">refcount 属性：存储对象被引用的次数。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">ptr 指针：指向对象的地址。</span></span></code></pre></div><p>使用 type 命令可以查看对象的类型。</p><p>使用 object encoding 命令可以查看对象使用的编码方式。</p><p>使用 object idletime 命令可以查看对象的空闲时间（即多久没有被访问）</p><p>使用 object refcount 命令可以查看对象被引用的次数。</p><p>这些命令都是通过 Key 找到对应的 DictEntry，再从 DictEntry 的 value 指针所指的 RedisObject 中进行获取。</p><h1 id="_2-字符串" tabindex="-1">2.字符串 <a class="header-anchor" href="#_2-字符串" aria-label="Permalink to &quot;2.字符串&quot;">​</a></h1><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131624.png" alt=""></p><p>Redis 使用 sdshdr 结构来表示字符串对象，并没有直接使用 C 语言的字符串。</p><p>struct sdshdr { int len; int free; char buf[]; };</p><p>len 属性：存储字符串的长度。</p><p>free 属性：存储字节数组中未使用的字节数量。</p><p>buf[]属性：字节数组，用于存储字符。</p><p>字节数组中会有\\0 结束符，该结束符不会记录在 len 属性中。</p><h2 id="sds-相比-c-语言的字符串" tabindex="-1">SDS 相比 C 语言的字符串 <a class="header-anchor" href="#sds-相比-c-语言的字符串" aria-label="Permalink to &quot;SDS 相比 C 语言的字符串&quot;">​</a></h2><p>C 语言中存储字符串的字节数组其长度总是 N+1（最后一个是结束符），当对字符串进行增长和缩短操作时需要使用内存重分配来重新为对象分配内存。</p><p>为了减少内存重分配的次数，Redis 自定义了字符串对象（sdshdr），通过未使用的空间解除了字符串长度与底层数组长度之间的关系，在 SDS 中 buf 数组的长度不一定等于字符串的长度+1，数组里面还可以包含未使用的字节。</p><p>通过未使用的空间，SDS 实现了空间预分配和惰性空间释放两种策略，从而减少由于字符串的修改导致内存重分配的次数。</p><p>空间预分配：当需要对 SDS 保存的字符串进行增长操作时，程序除了会为 SDS 分配所必须的空间以外，还会为 SDS 分配额外的未使用的空间。</p><p>惰性空间释放：当需要对 SDS 保存的字符串进行缩短操作时，程序并不会立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些多出来的字节数量记录出来，等待将来使用。</p><h1 id="_3-字典" tabindex="-1">3.字典 <a class="header-anchor" href="#_3-字典" aria-label="Permalink to &quot;3.字典&quot;">​</a></h1><p>字典是 Redis 数据库以及 HashTable 编码方式的底层实现。</p><p>字典的底层使用散列，同时使用链地址法的方式解决散列冲突，那么最终就是指针数组的形式，数组中的每个元素都是一个指向 DictEntry 的指针。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131625.png" alt=""></p><p>Redis 使用 dictht 结构来表示散列表</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">typedef struct dictht {</span></span>
<span class="line"><span style="color:#e1e4e8;">dictEntry table;</span></span>
<span class="line"><span style="color:#e1e4e8;">unsigned long size;</span></span>
<span class="line"><span style="color:#e1e4e8;">unsigned long sizemask;</span></span>
<span class="line"><span style="color:#e1e4e8;">unsigned long used;</span></span>
<span class="line"><span style="color:#e1e4e8;">}dictht;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">typedef struct dictht {</span></span>
<span class="line"><span style="color:#24292e;">dictEntry table;</span></span>
<span class="line"><span style="color:#24292e;">unsigned long size;</span></span>
<span class="line"><span style="color:#24292e;">unsigned long sizemask;</span></span>
<span class="line"><span style="color:#24292e;">unsigned long used;</span></span>
<span class="line"><span style="color:#24292e;">}dictht;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">table 指针：指向散列表的地址。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">size 属性：存储散列表的大小。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">sizemask 属性：用于计算索引值。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">used 属性：散列表中节点的个数。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">table 指针：指向散列表的地址。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">size 属性：存储散列表的大小。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">sizemask 属性：用于计算索引值。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">used 属性：散列表中节点的个数。</span></span></code></pre></div><p>Redis 使用 dictEntry 结构来表示散列表中的节点</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">typedef struct dictEntry {</span></span>
<span class="line"><span style="color:#e1e4e8;">void key;</span></span>
<span class="line"><span style="color:#e1e4e8;">union{</span></span>
<span class="line"><span style="color:#e1e4e8;">void val;</span></span>
<span class="line"><span style="color:#e1e4e8;">uint_tu64;</span></span>
<span class="line"><span style="color:#e1e4e8;">int64_ts64;</span></span>
<span class="line"><span style="color:#e1e4e8;">}v</span></span>
<span class="line"><span style="color:#e1e4e8;">struct dictEntry next;</span></span>
<span class="line"><span style="color:#e1e4e8;">}dictEntry;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">typedef struct dictEntry {</span></span>
<span class="line"><span style="color:#24292e;">void key;</span></span>
<span class="line"><span style="color:#24292e;">union{</span></span>
<span class="line"><span style="color:#24292e;">void val;</span></span>
<span class="line"><span style="color:#24292e;">uint_tu64;</span></span>
<span class="line"><span style="color:#24292e;">int64_ts64;</span></span>
<span class="line"><span style="color:#24292e;">}v</span></span>
<span class="line"><span style="color:#24292e;">struct dictEntry next;</span></span>
<span class="line"><span style="color:#24292e;">}dictEntry;</span></span></code></pre></div><p>key 指针：指向 Key 对象。</p><p>value 属性：可以是指向 Value 对象(指针)、uint64_t 整数、int64_t 整数。</p><p>next 指针：指向下一个 DictEntry。</p><p>Redis 使用 dict 结构来表示字典，每个字典中包含两个 dictht。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">typedef struct dict{</span></span>
<span class="line"><span style="color:#e1e4e8;">dictType type;</span></span>
<span class="line"><span style="color:#e1e4e8;">void privatedata;</span></span>
<span class="line"><span style="color:#e1e4e8;">dictht ht\\[2\\];</span></span>
<span class="line"><span style="color:#e1e4e8;">int rehashidx;</span></span>
<span class="line"><span style="color:#e1e4e8;">}dict;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">typedef struct dict{</span></span>
<span class="line"><span style="color:#24292e;">dictType type;</span></span>
<span class="line"><span style="color:#24292e;">void privatedata;</span></span>
<span class="line"><span style="color:#24292e;">dictht ht\\[2\\];</span></span>
<span class="line"><span style="color:#24292e;">int rehashidx;</span></span>
<span class="line"><span style="color:#24292e;">}dict;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">type 指针：指向 DictType，DictType 定义了一系列函数。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">privatadata 属性：传给特定函数的可选参数。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">ht 数组：长度为 2 的 dictht 数组，一般情况下只会使用 ht\\[0\\]散列表，ht\\[1\\]散列表只会在对 ht\\[0\\]散列表进行 rehash 时使用。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">rehashidx 属性：记录 rehash 的进度，如果目前没有进行 rehash 那么值为-1。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">type 指针：指向 DictType，DictType 定义了一系列函数。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">privatadata 属性：传给特定函数的可选参数。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">ht 数组：长度为 2 的 dictht 数组，一般情况下只会使用 ht\\[0\\]散列表，ht\\[1\\]散列表只会在对 ht\\[0\\]散列表进行 rehash 时使用。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">rehashidx 属性：记录 rehash 的进度，如果目前没有进行 rehash 那么值为-1。</span></span></code></pre></div><p>dictType 的结构（定义了一系列函数）</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">typedef struct dictType{</span></span>
<span class="line"><span style="color:#e1e4e8;"> unsigned int (hashFunction)(const void key); // H(K)散列函数</span></span>
<span class="line"><span style="color:#e1e4e8;">void (keyDup)(void privatedata, const void key); // 复制 Key</span></span>
<span class="line"><span style="color:#e1e4e8;">void (valDup)(void privatedata, const void obj); // 复制 Value</span></span>
<span class="line"><span style="color:#e1e4e8;"> int (keyCompare)(void privatdata, const void key1 , const void key2); // 对比 Key</span></span>
<span class="line"><span style="color:#e1e4e8;"> void (keyDestructor)(void privatedata, void key); // 销毁 Key</span></span>
<span class="line"><span style="color:#e1e4e8;"> void (valDestructor)(void privatedata, void obj); // 销毁 Value</span></span>
<span class="line"><span style="color:#e1e4e8;">}dictType;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">typedef struct dictType{</span></span>
<span class="line"><span style="color:#24292e;"> unsigned int (hashFunction)(const void key); // H(K)散列函数</span></span>
<span class="line"><span style="color:#24292e;">void (keyDup)(void privatedata, const void key); // 复制 Key</span></span>
<span class="line"><span style="color:#24292e;">void (valDup)(void privatedata, const void obj); // 复制 Value</span></span>
<span class="line"><span style="color:#24292e;"> int (keyCompare)(void privatdata, const void key1 , const void key2); // 对比 Key</span></span>
<span class="line"><span style="color:#24292e;"> void (keyDestructor)(void privatedata, void key); // 销毁 Key</span></span>
<span class="line"><span style="color:#24292e;"> void (valDestructor)(void privatedata, void obj); // 销毁 Value</span></span>
<span class="line"><span style="color:#24292e;">}dictType;</span></span></code></pre></div><h2 id="_3-1-在字典中进行查找、添加、更新、删除操作" tabindex="-1">3.1 在字典中进行查找、添加、更新、删除操作 <a class="header-anchor" href="#_3-1-在字典中进行查找、添加、更新、删除操作" aria-label="Permalink to &quot;3.1 在字典中进行查找、添加、更新、删除操作&quot;">​</a></h2><h3 id="在字典中进行查找" tabindex="-1">在字典中进行查找 <a class="header-anchor" href="#在字典中进行查找" aria-label="Permalink to &quot;在字典中进行查找&quot;">​</a></h3><p>以客户端传递的 Key 作为关键字 K，通过 dict 中的 dictType 的 H(K)散列函数计算散列值，使用 dictht[0]的 sizemask 属性和散列值计算索引，然后遍历索引对应的链表，如果存在 Key 相同的 DictEntry 则直接返回，否则返回 NULL。</p><h3 id="在字典中进行添加和更新" tabindex="-1">在字典中进行添加和更新 <a class="header-anchor" href="#在字典中进行添加和更新" aria-label="Permalink to &quot;在字典中进行添加和更新&quot;">​</a></h3><p>以客户端传递的 Key 作为关键字 K，通过 dict 中的 dictType 的 H(K)散列函数计算散列值，使用 dictht[0]的 sizemask 属性和散列值计算索引，然后遍历索引对应的链表，如果存在 Key 相同的 DictEntry 则进行更新，否则创建代表 Key 和 Value 的对象，然后创建一个 DictEntry 并使其分别指向 Key 和 Value 的对象，最终将该 DictEntry 追加到链表的末尾。</p><h3 id="在字典中进行删除-查到后进行删除" tabindex="-1">在字典中进行删除(查到后进行删除) <a class="header-anchor" href="#在字典中进行删除-查到后进行删除" aria-label="Permalink to &quot;在字典中进行删除(查到后进行删除)&quot;">​</a></h3><p>以客户端传递的 Key 作为关键字 K，通过 dict 中的 dictType 的 H(K)散列函数计算散列值，使用 dictht[0]的 sizemask 属性和散列值计算索引，然后遍历索引对应的链表，如果存在 Key 相同的 DictEntry 则进行删除。</p><h2 id="_3-2-散列表的扩容和缩容" tabindex="-1">3.2 散列表的扩容和缩容 <a class="header-anchor" href="#_3-2-散列表的扩容和缩容" aria-label="Permalink to &quot;3.2 散列表的扩容和缩容&quot;">​</a></h2><p>由于散列表的负载因子需要维持在一个合理的范围内，因此当散列表中的元素过多时会进行扩容，过少时会进行缩容。</p><p>一旦散列表的长度发生改变，那么就要进行 rehash，即对原先散列表中的元素在新的散列表中重新进行 hash。</p><p>Redis 中的 rehash 是渐进式的，并不是一次性完成，因为出于性能的考虑，如果散列表中包含上百万个节点，如果一次性完成 rehash 的话，那么有可能导致 Redis 在一定时间内无法正常对外提供服务。</p><p>在 rehash 进行期间，每次对字典执行查找、添加、更新、删除操作时，除了会执行相应的操作以外，还会顺带的将 ht[0]散列表在 rehashidx 索引上的所有节点 rehash 到 ht[1]上，然后将 rehashidx 属性的值加 1。</p><h3 id="渐进式-rehash-的步骤" tabindex="-1">渐进式 Rehash 的步骤 <a class="header-anchor" href="#渐进式-rehash-的步骤" aria-label="Permalink to &quot;渐进式 Rehash 的步骤&quot;">​</a></h3><p>1.为字典的 ht[1]散列表分配空间。</p><p>若执行的是扩容操作，那么 ht[1]的长度为第一个大于等于 ht[0].used2 的 2ⁿ。</p><p>若执行的是缩容操作，那么 ht[1]的长度为第一个大于等于 ht[0].used 的 2ⁿ。</p><p>2.rehashidx 属性设置为 0，表示开始进行 rehash。</p><p>3.在 rehash 进行期间，每次对字典执行查找、添加、更新、删除操作时，除了会执行相应的操作以外，还会顺带将 ht[0]散列表在 rehashidx 索引上的所有节点 rehash 到 ht[1]上，然后将 rehashidx 属性的值加 1。</p><p>4.随着对字典的不断操作，最终在某个时刻，ht[0]散列表中的所有节点都会被 rehash 到 ht[1]上，此时将 rehashidx 属性设置为-1，表示 rehash 已结束。</p><p>在进行渐进式 rehash 的过程中，字典会同时使用 ht[0]和 ht[1]两个散列表，因此字典的查找、更新、删除操作会在两个散列表中进行，如果在 ht[0]计算得到的索引指向 NULL 则从 ht[1]中进行查找。</p><h1 id="_5-redis-中的对象" tabindex="-1">5.Redis 中的对象 <a class="header-anchor" href="#_5-redis-中的对象" aria-label="Permalink to &quot;5.Redis 中的对象&quot;">​</a></h1><p>Redis 中一共包含五种对象，分别是字符串对象、列表对象、哈希对象、集合对象、有序集合对象，每种对象都支持多种编码方式，不同的编码方式之间使用不同的数据结构进行存储。</p><h3 id="redis-各个对象支持的编码方式" tabindex="-1">Redis 各个对象支持的编码方式 <a class="header-anchor" href="#redis-各个对象支持的编码方式" aria-label="Permalink to &quot;Redis 各个对象支持的编码方式&quot;">​</a></h3><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131635.png" alt=""></p><h2 id="_1-字符串对象" tabindex="-1">1.字符串对象 <a class="header-anchor" href="#_1-字符串对象" aria-label="Permalink to &quot;1.字符串对象&quot;">​</a></h2><p>字符串对象支持 INT、EMBSTR、ROW 三种编码方式。</p><h3 id="int-编码方式" tabindex="-1">INT 编码方式 <a class="header-anchor" href="#int-编码方式" aria-label="Permalink to &quot;INT 编码方式&quot;">​</a></h3><p>如果字符串的值是整数，同时可以使用 long 来进行表示，那么 Redis 将会使用 INT 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131636.png" alt=""></p><p>INT 编码方式会将 RedisObject 中的 ptr 指针直接改写成 long ptr，ptr 属性直接存储字面量。</p><h3 id="embstr-编码方式" tabindex="-1">EMBSTR 编码方式 <a class="header-anchor" href="#embstr-编码方式" aria-label="Permalink to &quot;EMBSTR 编码方式&quot;">​</a></h3><p>如果字符串的值是字符，同时字符串的大小小于 32 个字节，那么 Redis 将会使用 EMBSTR 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131637.png" alt=""></p><h3 id="row-编码方式" tabindex="-1">ROW 编码方式 <a class="header-anchor" href="#row-编码方式" aria-label="Permalink to &quot;ROW 编码方式&quot;">​</a></h3><p>如果字符串的值是字符，同时字符串的大小大于 32 个字节，那么 Redis 将会使用 ROW 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131638.png" alt=""></p><p>EMBSTR 和 ROW 编码方式在内存中都会创建字符串对象(SDS)，区别在于 EMBSTR 编码方式中 RedisObject 和 SDS 共同使用同一块内存单元，Redis 内存分配器只需要分配一次内存，而 ROW 编码方式需要单独的为 RedisObject 和 SDS 分配内存单元。</p><p>编码转换</p><p>如果字符串的值不再是整数或者用 long 无法进行表示，那么 INT 编码方式将会转换成 ROW 编码方式。</p><p>如果字符串的值其大小大于 32 个字节，那么 EMBSTR 编码方式将会转换成 ROW 编码方式。</p><p>INT 编码方式不能转换成 EMBSTR 编码方式。</p><h3 id="字符串共享对象" tabindex="-1">字符串共享对象 <a class="header-anchor" href="#字符串共享对象" aria-label="Permalink to &quot;字符串共享对象&quot;">​</a></h3><p>Redis 在启动时会初始化值为 0~9999 的字符串对象作为共享对象，当 set 一个 Key 其 Value 是在 0~9999 范围时，会直接使用该共享对象，DictEntry 中的 value 指针直接指向该共享的字符串对象。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131639.png" alt=""></p><p>在集群模式中，Redis 的每个节点启动时都会初始化值为 0~9999 的字符串对象作为共享对象。</p><p>在 RedisV4.0 以上，使用 Object refcount 命令不再返回共享对象实际被引用的次数，而是直接返回 Integer.MAX_VALUE。</p><h2 id="_2-列表对象" tabindex="-1">2.列表对象 <a class="header-anchor" href="#_2-列表对象" aria-label="Permalink to &quot;2.列表对象&quot;">​</a></h2><p>列表对象支持 ZIPLIST、LINKEDLIST 两种编码方式。</p><h3 id="ziplist-编码方式" tabindex="-1">ZIPLIST 编码方式 <a class="header-anchor" href="#ziplist-编码方式" aria-label="Permalink to &quot;ZIPLIST 编码方式&quot;">​</a></h3><p>如果列表对象保存的元素的数量少于 512 个，同时每个元素的大小都小于 64 个字节，那么 Redis 将会使用 ZIPLIST 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131640.png" alt=""></p><h3 id="linkedlist-编码方式" tabindex="-1">LINKEDLIST 编码方式 <a class="header-anchor" href="#linkedlist-编码方式" aria-label="Permalink to &quot;LINKEDLIST 编码方式&quot;">​</a></h3><p>如果列表对象保存的元素的数量多于 512 个，或者元素的大小大于 64 个字节，那么 Redis 将会使用 LINKEDLIST 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131641.png" alt=""></p><h3 id="编码转换" tabindex="-1">编码转换 <a class="header-anchor" href="#编码转换" aria-label="Permalink to &quot;编码转换&quot;">​</a></h3><p>如果列表对象保存的元素的数量多于 512 个，或者元素的大小大于 64 个字节，那么 Redis 将会使用 LINKEDLIST 编码方式。</p><p>可以通过 list-max-ziplist-entries 和 list-max-ziplist-value 参数，调整列表对象 ZIPLIST 编码方式中最多可以保存元素的个数以及每个元素的最大大小。</p><h2 id="_3-哈希对象" tabindex="-1">3.哈希对象 <a class="header-anchor" href="#_3-哈希对象" aria-label="Permalink to &quot;3.哈希对象&quot;">​</a></h2><p>哈希对象支持 ZIPLIST 和 HASHTABLE 两种编码方式。</p><h3 id="ziplist-编码方式-1" tabindex="-1">ZIPLIST 编码方式 <a class="header-anchor" href="#ziplist-编码方式-1" aria-label="Permalink to &quot;ZIPLIST 编码方式&quot;">​</a></h3><p>如果哈希对象保存的键值对的数量少于 512 个，同时每个键值对中的键和值的大小都小于 64 个字节，那么 Redis 将会使用 ZIPLIST 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131642.png" alt=""></p><h3 id="hashtable-编码方式" tabindex="-1">HASHTABLE 编码方式 <a class="header-anchor" href="#hashtable-编码方式" aria-label="Permalink to &quot;HASHTABLE 编码方式&quot;">​</a></h3><p>如果哈希对象保存的键值对的数量多于 512 个，或者键值对中的键或值的大小大于 64 个字节，那么 Redis 将会使用 HASHTABLE 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131643.png" alt=""></p><h3 id="编码转换-1" tabindex="-1">编码转换 <a class="header-anchor" href="#编码转换-1" aria-label="Permalink to &quot;编码转换&quot;">​</a></h3><p>如果哈希对象保存的键值对的数量多于 512 个，或者键或值中的键和值的字符串的大小大于 64 个字节，那么 Redis 将会使用 HASHTABLE 编码方式。</p><p>可以通过 hash-max-ziplist-entries 和 hash-max-ziplist-value 参数，调整哈希对象 ZIPLIST 编码方式中最多可以保存元素的个数以及每个键值对中的键和值的字符串的最大大小。</p><h2 id="_4-集合对象" tabindex="-1">4.集合对象 <a class="header-anchor" href="#_4-集合对象" aria-label="Permalink to &quot;4.集合对象&quot;">​</a></h2><p>集合对象支持 INTSET 和 HASHTABLE 两种编码方式。</p><h3 id="intset-编码方式" tabindex="-1">INTSET 编码方式 <a class="header-anchor" href="#intset-编码方式" aria-label="Permalink to &quot;INTSET 编码方式&quot;">​</a></h3><p>如果集合对象保存的元素的数量少于 512 个，同时每个元素都是整数，那么 Redis 将会使用 INTSET 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131644.png" alt=""></p><h3 id="hashtable-编码方式-1" tabindex="-1">HASHTABLE 编码方式 <a class="header-anchor" href="#hashtable-编码方式-1" aria-label="Permalink to &quot;HASHTABLE 编码方式&quot;">​</a></h3><p>如果集合对象保存的元素的数量多于 512 个，或者元素不是整数，那么 Redis 将会使用 HASHTABLE 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131645.png" alt=""></p><h3 id="编码转换-2" tabindex="-1">编码转换 <a class="header-anchor" href="#编码转换-2" aria-label="Permalink to &quot;编码转换&quot;">​</a></h3><p>如果集合对象保存的元素的数量多于 512 个，或者元素不是整数，那么 Redis 将会使用 HASHTABLE 编码方式。</p><p>可以通过 set-max-intset-entries 参数，调整集合对象 INTSET 编码方式中最多可以保存元素的个数。</p><h2 id="_5-有序集合对象" tabindex="-1">5.有序集合对象 <a class="header-anchor" href="#_5-有序集合对象" aria-label="Permalink to &quot;5.有序集合对象&quot;">​</a></h2><p>有序集合对象支持 ZIPLIST 和 SKIPLIST 两种编码方式。</p><h3 id="ziplist-编码方式-2" tabindex="-1">ZIPLIST 编码方式 <a class="header-anchor" href="#ziplist-编码方式-2" aria-label="Permalink to &quot;ZIPLIST 编码方式&quot;">​</a></h3><p>如果有序集合对象保存的元素的数量少于 128 个，同时每个元素的大小都小于 64 个字节，那么 Redis 将会使用 ZIPLIST 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131646.png" alt=""></p><h3 id="skiplist-编码方式" tabindex="-1">SKIPLIST 编码方式 <a class="header-anchor" href="#skiplist-编码方式" aria-label="Permalink to &quot;SKIPLIST 编码方式&quot;">​</a></h3><p>如果有序集合对象保存的元素的数量多于 128 个，或者元素的大小大于 64 个字节，那么 Redis 将会使用 SKIPLIST 编码方式。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131647.png" alt=""></p><p>为了在有序集合中可以快速的进行查找以及范围操作，因此有序集合会同时使用 HashTable 和跳表两种结构来进行维护，HashTable 中的键存储的是元素本身，值存储的是分数，当需要进行查找时，可以以 O(1)的时间复杂度获取到元素的分数，当需要进行范围型操作时，从跳表进行操作。</p><h3 id="编码转换-3" tabindex="-1">编码转换 <a class="header-anchor" href="#编码转换-3" aria-label="Permalink to &quot;编码转换&quot;">​</a></h3><p>如果有序集合对象保存的元素的数量多于 128 个，或者元素的大小大于 64 个字节，那么 Redis 将会使用 SKIPLIST 编码方式。</p><p>可以通过 zset-max-ziplist-entries 和 zset-max-ziplist-value 参数，调整有序集合对象 ZIPLIST 编码方式中最多可以保存元素的个数以及每个元素的最大大小。</p><h1 id="_6-redis-内存分配器" tabindex="-1">6.Redis 内存分配器 <a class="header-anchor" href="#_6-redis-内存分配器" aria-label="Permalink to &quot;6.Redis 内存分配器&quot;">​</a></h1><p>Redis 提供了 jemalloc、libc、tcmalloc 内存分配器，默认使用 jemalloc，需要在编译时指定。</p><h2 id="jemalloc-内存分配器" tabindex="-1">Jemalloc 内存分配器 <a class="header-anchor" href="#jemalloc-内存分配器" aria-label="Permalink to &quot;Jemalloc 内存分配器&quot;">​</a></h2><p>jemalloc 内存分配器将内存划分为小、大、巨大三个范围，每个范围又包含多个大小不同的内存单元。</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131648.png" alt=""></p><p>DictEntry、RedisObject 以及对象在初始化时，Redis 内存分配器都会分配一个合适的内存大小。</p><p>如果频繁修改 value，且 value 的大小相差很大，那么有可能会导致已分配的内存空间不足，那么 redis 内存分配器需要重新为对象分配内存，然后释放掉对象之前所占用的内存（不是立即释放，此时属于内存碎片，等待 Redis 的内存清除策略）</p><h1 id="_7-redis-内存监控" tabindex="-1">7.Redis 内存监控 <a class="header-anchor" href="#_7-redis-内存监控" aria-label="Permalink to &quot;7.Redis 内存监控&quot;">​</a></h1><p>可以使用 info memory 命令查看 Redis 内存的使用情况</p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131649.png" alt=""></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">used_memory：redis 有效数据占用的内存大小(包括使用的虚拟内存)</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">uesd_memory_rss：redis 有效数据占用的内存大小(不包括使用的虚拟内存)、redis 进程所占用的内存大小、内存碎片(与 TOP 命令查看的内存一直)</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">mem_fragmentation_ratio(内存碎片率) = used_memory_rss / used_memory ，由于一般不会使用虚拟内存，同时 redis 进程所占用的内存相对使用的内存来说很少，因此这个比例可以认为是内存碎片率。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">mem_allocator：redis 内存分配器，可选 jemalloc(默认)、libc、tcmalloc</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">used_memory：redis 有效数据占用的内存大小(包括使用的虚拟内存)</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">uesd_memory_rss：redis 有效数据占用的内存大小(不包括使用的虚拟内存)、redis 进程所占用的内存大小、内存碎片(与 TOP 命令查看的内存一直)</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">mem_fragmentation_ratio(内存碎片率) = used_memory_rss / used_memory ，由于一般不会使用虚拟内存，同时 redis 进程所占用的内存相对使用的内存来说很少，因此这个比例可以认为是内存碎片率。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">mem_allocator：redis 内存分配器，可选 jemalloc(默认)、libc、tcmalloc</span></span></code></pre></div><p>max_memory 配置的是 Redis 有效数据最大可以使用的内存，由于存在内存碎片，因此 Redis 实际占用的内存大小最终一定会比 max_memory 要大。</p><h2 id="关于内存碎片率" tabindex="-1">关于内存碎片率 <a class="header-anchor" href="#关于内存碎片率" aria-label="Permalink to &quot;关于内存碎片率&quot;">​</a></h2><p>mem_fragmentation_ratio = used_memory_rss / used_memory ;</p><p>当内存碎片率 &lt; 1 时，表示 redis 正在使用虚拟内存，当内存碎片率严重 &gt; 1，表示 redis 存在大量的内存碎片。</p><p>内存碎片率在 1~1.1 之间是比较健康的状态。</p><h2 id="产生内存碎片的原因" tabindex="-1">产生内存碎片的原因 <a class="header-anchor" href="#产生内存碎片的原因" aria-label="Permalink to &quot;产生内存碎片的原因&quot;">​</a></h2><p>1.如果频繁修改 value，且 value 的大小相差很大，那么有可能导致已分配的内存大小不足，那么 redis 内存分配器需要重新为对象分配内存，之前的内存空间就属于内存碎片。</p><p>2.过期和被删除的 Key，先会被标记，此时属于内存碎片，然后等待 Redis 的内存清除策略回收（惰性或主动）</p><p>3.大 key。</p><h2 id="解决内存碎片的方法" tabindex="-1">解决内存碎片的方法 <a class="header-anchor" href="#解决内存碎片的方法" aria-label="Permalink to &quot;解决内存碎片的方法&quot;">​</a></h2><p>1.重启 Redis 服务，会自动读取 RDB 文件进行数据的恢复，重新为对象分配内存。</p><p>2.Redis4.0 提供了清除内存碎片的功能</p><p>#自动清除 activedefrag yes</p><p>#手动执行命令清除 memory purge</p><h1 id="_8-redis-监视器" tabindex="-1">8.Redis 监视器 <a class="header-anchor" href="#_8-redis-监视器" aria-label="Permalink to &quot;8.Redis 监视器&quot;">​</a></h1><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101131650.png" alt=""></p><p>客户端向服务器发送命令请求时，服务器除了会执行相应的命令以外，还会将关于这条命令的相关信息转发给各个监视器。</p><p>客户端可以通过执行 monitor 命令让自己变成一个监视器，实时接收服务器当前正在执行的命令的相关信息。</p><hr>`,165),t=[l];function i(o,c,r,d,h,y){return a(),e("div",null,t)}const m=s(p,[["render",i]]);export{g as __pageData,m as default};
