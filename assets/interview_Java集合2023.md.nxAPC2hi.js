import{_ as s,o as a,c as n,R as e}from"./chunks/framework.7FlijoJG.js";const _=JSON.parse('{"title":"Java 集合","description":"","frontmatter":{"title":"Java 集合","date":"2023-12-22T13:34:05.000Z","tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"interview/Java集合2023.md","filePath":"interview/Java集合2023.md","lastUpdated":1703558844000}'),p={name:"interview/Java集合2023.md"},l=e(`<p>我现在想要了解 LinkedList 的相关知识，请你列个表格给我，表格列：类、应用场景、底层数据结构、关键特性、是否线程安全、线程安全机制、扩容机制、有序性、初始化增删查改概述；下面是一个表格内容的举例，我希望你参考下面的列给我列个表格：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ArrayList</span></span>
<span class="line"><span style="color:#e1e4e8;">线程不安全，适合读多写少的场景</span></span>
<span class="line"><span style="color:#e1e4e8;">数组</span></span>
<span class="line"><span style="color:#e1e4e8;">构造传入一个合适的大小；随机查询、插入、修改，性能比较好；顺序插入，超过了数组的大小，就会进行扩容；</span></span>
<span class="line"><span style="color:#e1e4e8;">线程不安全</span></span>
<span class="line"><span style="color:#e1e4e8;">ArrayList 在设计上是没有实现线程同步的。这就意味着如果多个线程同时对 ArrayList 进行结构上的修改操作（比如添加、删除元素等），就会出现数据不一致的问题，甚至可能抛出 \`ConcurrentModificationException\` 异常。</span></span>
<span class="line"><span style="color:#e1e4e8;">扩容：超过数组大小，1.5 倍扩容，遍历 fail-first 特性</span></span>
<span class="line"><span style="color:#e1e4e8;">插入顺序</span></span>
<span class="line"><span style="color:#e1e4e8;">**初始化：**  当我们创建一个 ArrayList 的时候，ArrayList 会初始化一个空数组。如果我们指定了初始化容量，那么它就会创建一个指定大小的数组。如果我们没指定，那当我们第一次调用 add 方法时，它会创建一个 10 大小的数组。你看，这就好像明星在摄影棚中，选择器合适尺寸的布景，来拍摄美轮美奂的照片一样。**添加元素：**  当我们向 ArrayList 中添加元素时，它会在数组的末尾添加这个元素。如果数组已经满了，那么 ArrayList 就会创建一个新的数组，这个数组的大小是旧数组大小的 1.5 倍。然后，它会把旧数组的所有元素都复制到新数组中，同时旧数组会被垃圾回收。这个过程就像是热闹的派对人数越来越多，现在的会场已经容纳不下，于是换了一个更大的会场，然后把人们都引导到新会场里。**访问元素：**  因为 ArrayList 底层是用数组实现的，所以我们可以直接通过数组的索引快速访问元素。这就像是我们直接凭票根找到自己的座位一样。**删除元素：**  当我们在 ArrayList 中删除元素时，后面的元素将会向前移动，覆盖掉被删除元素的位置。这就像是派对中有人离开，大家都往前挤，盛情之下，空位完全看不出来。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ArrayList</span></span>
<span class="line"><span style="color:#24292e;">线程不安全，适合读多写少的场景</span></span>
<span class="line"><span style="color:#24292e;">数组</span></span>
<span class="line"><span style="color:#24292e;">构造传入一个合适的大小；随机查询、插入、修改，性能比较好；顺序插入，超过了数组的大小，就会进行扩容；</span></span>
<span class="line"><span style="color:#24292e;">线程不安全</span></span>
<span class="line"><span style="color:#24292e;">ArrayList 在设计上是没有实现线程同步的。这就意味着如果多个线程同时对 ArrayList 进行结构上的修改操作（比如添加、删除元素等），就会出现数据不一致的问题，甚至可能抛出 \`ConcurrentModificationException\` 异常。</span></span>
<span class="line"><span style="color:#24292e;">扩容：超过数组大小，1.5 倍扩容，遍历 fail-first 特性</span></span>
<span class="line"><span style="color:#24292e;">插入顺序</span></span>
<span class="line"><span style="color:#24292e;">**初始化：**  当我们创建一个 ArrayList 的时候，ArrayList 会初始化一个空数组。如果我们指定了初始化容量，那么它就会创建一个指定大小的数组。如果我们没指定，那当我们第一次调用 add 方法时，它会创建一个 10 大小的数组。你看，这就好像明星在摄影棚中，选择器合适尺寸的布景，来拍摄美轮美奂的照片一样。**添加元素：**  当我们向 ArrayList 中添加元素时，它会在数组的末尾添加这个元素。如果数组已经满了，那么 ArrayList 就会创建一个新的数组，这个数组的大小是旧数组大小的 1.5 倍。然后，它会把旧数组的所有元素都复制到新数组中，同时旧数组会被垃圾回收。这个过程就像是热闹的派对人数越来越多，现在的会场已经容纳不下，于是换了一个更大的会场，然后把人们都引导到新会场里。**访问元素：**  因为 ArrayList 底层是用数组实现的，所以我们可以直接通过数组的索引快速访问元素。这就像是我们直接凭票根找到自己的座位一样。**删除元素：**  当我们在 ArrayList 中删除元素时，后面的元素将会向前移动，覆盖掉被删除元素的位置。这就像是派对中有人离开，大家都往前挤，盛情之下，空位完全看不出来。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221334410.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221335532.png" alt="image.png"></p>`,4),r=[l];function t(i,c,o,d,y,u){return a(),n("div",null,r)}const b=s(p,[["render",t]]);export{_ as __pageData,b as default};
