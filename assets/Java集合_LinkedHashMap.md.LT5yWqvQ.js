import{_ as a,o as e,c as t,R as s}from"./chunks/framework.7FlijoJG.js";const y=JSON.parse('{"title":"LinkedHashMap","description":"","frontmatter":{"title":"LinkedHashMap","date":"2023-12-26T09:50:00.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"Java集合/LinkedHashMap.md","filePath":"Java集合/LinkedHashMap.md","lastUpdated":1711296414000}'),n={name:"Java集合/LinkedHashMap.md"},o=s(`<h2 id="linkedhashmap-的底层工作原理" tabindex="-1">LinkedHashMap 的底层工作原理 <a class="header-anchor" href="#linkedhashmap-的底层工作原理" aria-label="Permalink to &quot;LinkedHashMap 的底层工作原理&quot;">​</a></h2><p>首先，LinkedHashMap 是 HashMap 的一个子类。它在保持 HashMap 快速查找的哈希表（数组+链表）的基础上，添加了一套双向链表结构，这套双向链表链接了所有 entry，按照插入的顺序排序，这样就实现了访问顺序的有序性。</p><p>具体来说，LinkedHashMap 里面的每一个节点（entry），都有两个指针：before 和 after，它们分别指向前一个节点和后一个节点，有点像列车的车厢连接起来。</p><p>当我们向 LinkedHashMap 插入一个元素时，新节点将被添加到双向链表的尾部。这就是为什么当你迭代遍历一个 LinkedHashMap 时，元素的输出顺序就是插入顺序。</p><p>同时，LinkedHashMap 还可以通过设置参数 accessOrder 来决定迭代顺序。默认情况下，accessOrder 为 false，表示按照插入顺序迭代。如果设置 accessOrder 为 true，那么每次通过 get()或 put()访问到一个元素时，这个元素就会被移到双向链表的最后，从而实现了按照访问顺序进行迭代。</p><p>总的来说，LinkedHashMap 通过内部维护一个双向链表，使得元素在遍历时，能按照一定的顺序（插入顺序或访问顺序）进行，从而实现了元素的有序性。 <img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312260950917.png" alt="image.png"></p><h2 id="数据举例" tabindex="-1">数据举例 <a class="header-anchor" href="#数据举例" aria-label="Permalink to &quot;数据举例&quot;">​</a></h2><p>假设有一个 LinkedHashMap，里面存了三个键值对：(&quot;A&quot;, 1), (&quot;B&quot;, 2), (&quot;C&quot;, 3)。我们可以假设这个 LinkedHashMap 的哈希表（数组）大小为 5，它如下：(每条链表代表一个哈希桶)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">哈希表 (数组):</span></span>
<span class="line"><span style="color:#e1e4e8;">0：null</span></span>
<span class="line"><span style="color:#e1e4e8;">1：Entry[ hash=1, key=&quot;A&quot;, value=1, next=null, before=header, after=Entry[&quot;B&quot;,2] ]</span></span>
<span class="line"><span style="color:#e1e4e8;">2：Entry[ hash=2, key=&quot;B&quot;, value=2, next=null, before=Entry[&quot;A&quot;,1], after=Entry[&quot;C&quot;,3] ]</span></span>
<span class="line"><span style="color:#e1e4e8;">3：Entry[ hash=3, key=&quot;C&quot;, value=3, next=null, before=Entry[&quot;B&quot;,2], after=header ]</span></span>
<span class="line"><span style="color:#e1e4e8;">4：null</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">哈希表 (数组):</span></span>
<span class="line"><span style="color:#24292e;">0：null</span></span>
<span class="line"><span style="color:#24292e;">1：Entry[ hash=1, key=&quot;A&quot;, value=1, next=null, before=header, after=Entry[&quot;B&quot;,2] ]</span></span>
<span class="line"><span style="color:#24292e;">2：Entry[ hash=2, key=&quot;B&quot;, value=2, next=null, before=Entry[&quot;A&quot;,1], after=Entry[&quot;C&quot;,3] ]</span></span>
<span class="line"><span style="color:#24292e;">3：Entry[ hash=3, key=&quot;C&quot;, value=3, next=null, before=Entry[&quot;B&quot;,2], after=header ]</span></span>
<span class="line"><span style="color:#24292e;">4：null</span></span></code></pre></div><p>其中&quot;hash()&quot;函数返回 key 的哈希值，我们假设&quot;A&quot;, &quot;B&quot;, &quot;C&quot;的哈希值刚好分别映射到数组索引 1, 2, 3。在每个 Entry 里，除了 key 和 value 外，next 指向同一哈希桶内的下一个 Entry（本例中每个哈希桶只有一个 Entry，所以 next 为 null）。</p><p>现在，我们再来看 LinkedHashMap 特有的双向链表结构，如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">header &lt;--&gt; Entry[&quot;A&quot;,1] &lt;--&gt; Entry[&quot;B&quot;,2] &lt;--&gt; Entry[&quot;C&quot;,3] &lt;--&gt; header</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">header &lt;--&gt; Entry[&quot;A&quot;,1] &lt;--&gt; Entry[&quot;B&quot;,2] &lt;--&gt; Entry[&quot;C&quot;,3] &lt;--&gt; header</span></span></code></pre></div><p>header 是 LinkedHashMap 特有的一个头节点，所有插入的 Entry 都会在 header 和它的前一个节点（before）之间加入双向链表。这样，Entry 在双向链表中的顺序就表示了它们的插入顺序。</p><p>通过上面的例子，你可以看见 LinkedHashMap 其实是哈希表和双向链表的结合。哈希表给我们带来了快速的查找和插入，而双向链表帮我们记住了键值对的插入顺序。</p><h2 id="操作" tabindex="-1">操作 <a class="header-anchor" href="#操作" aria-label="Permalink to &quot;操作&quot;">​</a></h2><ol><li><strong>存数据（新增或修改）</strong></li></ol><p>LinkedHashMap 存数据主要是通过<code>put()</code>函数完成的，当我们调用<code>put()</code> 函数将键值对插入到 LinkedHashMap 中时，会首先调用父类 HashMap 的<code>put()</code>函数，利用哈希表（数组+链表）进行高效的插入。然后 LinkedHashMap 会将新插入的节点添加到维护的双向链表的尾部。</p><p>而如果是修改数据，那么就不需要改变双向链表的结构，只需要修改相应节点的值就可以了。</p><ol start="2"><li><strong>取数据</strong></li></ol><p>取数据是通过<code>get()</code>函数完成的。同样地，我们首先会调用 HashMap 的<code>get()</code>函数去哈希表中找到对应的元素。如果设置了 accessOrder 为 true，在每次获取元素值后，还需要将被访问的节点从双向链表中摘出来，然后再插入到双向链表的尾部，这样使得最近被访问过的元素总是最后被迭代访问。</p><ol start="3"><li><strong>删数据</strong></li></ol><p>删除数据就直接调用<code>remove()</code>函数就好了，这里也先通过 HashMap 的<code>remove()</code>函数从哈希表中将元素删除，然后再修改双向链表中相应节点的前后指针，就把链表中的节点也删除掉了。</p><p>总的来说，LinkedHashMap 利用了 HashMap 的快速查找特性，并通过内部维护一个双向链表，增强了对插入顺序或者访问顺序的记忆，使得我们在必要时可以按照一定的顺序高效地进行迭代。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://yikun.github.io/2015/04/02/Java-LinkedHashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noreferrer">Java LinkedHashMap工作原理及实现 | Yikun</a></p>`,25),p=[o];function l(r,i,u,d,c,h){return e(),t("div",null,p)}const k=a(n,[["render",l]]);export{y as __pageData,k as default};
