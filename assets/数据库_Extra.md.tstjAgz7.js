import{_ as s,o as e,c as a,R as t}from"./chunks/framework.7FlijoJG.js";const h=JSON.parse('{"title":"Extra","description":"","frontmatter":{"title":"Extra","date":"2023-12-28T13:02:19.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"数据库/Extra.md","filePath":"数据库/Extra.md","lastUpdated":1711296414000}'),n={name:"数据库/Extra.md"},l=t(`<p>探寻 MySQL 执行计划中的 EXTRA 涵义和相关的 SQL 例子吧：</p><ol><li>&#39;Using index&#39;：即只通过使用索引，就可以从表中获取所需的信息。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">   CREATE INDEX idx_name ON users(name);</span></span>
<span class="line"><span style="color:#e1e4e8;">   SELECT name FROM users WHERE name=&#39;Bob&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">   CREATE INDEX idx_name ON users(name);</span></span>
<span class="line"><span style="color:#24292e;">   SELECT name FROM users WHERE name=&#39;Bob&#39;;</span></span></code></pre></div><ol start="2"><li>&#39;Using where&#39;：表示 MySQL 服务器将在存储引擎检索行后再进行过滤。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">   SELECT * FROM users WHERE age &gt; 30;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">   SELECT * FROM users WHERE age &gt; 30;</span></span></code></pre></div><ol start="3"><li>&#39;Using temporary&#39;：表示 MySQL 需要使用临时表排序查询结果。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">    SELECT * FROM users ORDER BY age DESC;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">    SELECT * FROM users ORDER BY age DESC;</span></span></code></pre></div><ol start="4"><li>&#39;Using filesort&#39;：说明 MySQL 会对结果使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">    SELECT * FROM users ORDER BY birth_date;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">    SELECT * FROM users ORDER BY birth_date;</span></span></code></pre></div><ol start="5"><li>&#39;Using join buffer&#39;：表示在连接表时使用了进程连接缓存。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">   SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id WHERE users.age &gt; 25;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">   SELECT * FROM users INNER JOIN orders ON users.id = orders.user_id WHERE users.age &gt; 25;</span></span></code></pre></div><ol start="6"><li>&#39;Impossible WHERE&#39;：查询的 WHERE 子句值永远不会为真，所以没有结果。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">    SELECT * FROM users WHERE 1=0;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">    SELECT * FROM users WHERE 1=0;</span></span></code></pre></div><ol start="7"><li>&#39;Select tables optimized away&#39;：在无需访问表的情况下优化了 GROUP BY。例如，当仅根据索引查询 MIN()或者 MAX()值时。</li></ol><ol><li>&#39;Using index condition&#39;：表示使用了索引条件推送（Index Condition Pushdown，简称 ICP），和&quot;Using where&quot;工作类似，但效率更高。举个例子，假设有一个下列语句：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">   SELECT * FROM users WHERE status=&#39;active&#39; AND age BETWEEN 20 AND 30;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">   SELECT * FROM users WHERE status=&#39;active&#39; AND age BETWEEN 20 AND 30;</span></span></code></pre></div><p>如果字段<code>status</code>和<code>age</code>上有索引，ICP 会在读取索引时先检查<code>age BETWEEN 20 AND 30</code>这个条件，过滤掉不符合条件的记录，减少大量不必要的数据访问。</p><ol start="2"><li>&#39;Using index for group-by&#39;：意味着 MySQL 使用了索引进行 GROUP BY 操作，而不是创建一个临时表。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">   CREATE INDEX idx_user_status ON users(status);</span></span>
<span class="line"><span style="color:#e1e4e8;">   SELECT status, COUNT(*) FROM users GROUP BY status;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">   CREATE INDEX idx_user_status ON users(status);</span></span>
<span class="line"><span style="color:#24292e;">   SELECT status, COUNT(*) FROM users GROUP BY status;</span></span></code></pre></div><ol start="3"><li>&#39;Using sort_union&#39;、&#39;Using union&#39; 和 &#39;Using intersect&#39;：这些都代表 MySQL 在处理多个索引的时候所采用的策略。&#39;Using sort_union&#39; 表明使用了排序的并集（Sort Merge）来处理这些索引。&#39;Using union&#39; 表明使用了索引合并（Union）策略。&#39;Using intersect&#39; 表明使用了索引交集策略。举个例子，下面的查询可能会用到：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">   CREATE INDEX idx_user_name ON users(name);</span></span>
<span class="line"><span style="color:#e1e4e8;">   CREATE INDEX idx_user_status ON users(status);</span></span>
<span class="line"><span style="color:#e1e4e8;">   SELECT * FROM users WHERE name=&#39;Bob&#39; OR status=&#39;active&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">   CREATE INDEX idx_user_name ON users(name);</span></span>
<span class="line"><span style="color:#24292e;">   CREATE INDEX idx_user_status ON users(status);</span></span>
<span class="line"><span style="color:#24292e;">   SELECT * FROM users WHERE name=&#39;Bob&#39; OR status=&#39;active&#39;;</span></span></code></pre></div><ol start="4"><li>&#39;Range checked for each record (index map: N)&#39;：对于联表查询，MySQL 在查找的时候会对每一个从先导表中取出的值检查是否使用后续表的索引。例如：</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">   SELECT * FROM users, orders WHERE users.id = orders.user_id AND orders.total &gt; 100;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">   SELECT * FROM users, orders WHERE users.id = orders.user_id AND orders.total &gt; 100;</span></span></code></pre></div><p>注意，这里的内容并非全部的&quot;extra&quot;部分内容，MySQL 执行计划的 extra 信息可能会随着 MySQL 版本的更新增加一些新的内容。</p>`,24),o=[l];function p(i,c,r,d,u,E){return e(),a("div",null,o)}const v=s(n,[["render",p]]);export{h as __pageData,v as default};
