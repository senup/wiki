import{_ as s,o as a,c as n,R as e}from"./chunks/framework.7FlijoJG.js";const m=JSON.parse('{"title":"Java多线程关键字","description":"","frontmatter":{"title":"Java多线程关键字","date":"2023-12-22T13:41:29.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"advance/Java多线程关键字-joehuang.md","filePath":"advance/Java多线程关键字-joehuang.md","lastUpdated":1703238997000}'),l={name:"advance/Java多线程关键字-joehuang.md"},p=e(`<h2 id="线程创建的方法" tabindex="-1">线程创建的方法 <a class="header-anchor" href="#线程创建的方法" aria-label="Permalink to &quot;线程创建的方法&quot;">​</a></h2><h3 id="线程创建的方法有几种" tabindex="-1">线程创建的方法有几种： <a class="header-anchor" href="#线程创建的方法有几种" aria-label="Permalink to &quot;线程创建的方法有几种：&quot;">​</a></h3><ol><li><code>通过继承Thread类</code>: 这种方式需要重写 Thread 类中的 run 方法，run 方法的方法体就是对应线程需要执行的任务。创建的线程并不会立即执行，需调用 start 方法才会执行。</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">new Thread(){</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void run(){</span></span>
<span class="line"><span style="color:#e1e4e8;">        // 执行代码</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">}.start();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">new Thread(){</span></span>
<span class="line"><span style="color:#24292e;">    public void run(){</span></span>
<span class="line"><span style="color:#24292e;">        // 执行代码</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">}.start();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li><code>通过实现Runnable接口</code>: 创建一个新的类实现 Runnable 接口，然后实现它的 run 方法，将 Runnable 实例传给 Thread 类的构造方法，就可以启动新线程并执行 run 方法。</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Runnable runnable = new Runnable(){</span></span>
<span class="line"><span style="color:#e1e4e8;">    @Override</span></span>
<span class="line"><span style="color:#e1e4e8;">    public void run(){</span></span>
<span class="line"><span style="color:#e1e4e8;">        // 执行代码</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;">new Thread(runnable).start();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Runnable runnable = new Runnable(){</span></span>
<span class="line"><span style="color:#24292e;">    @Override</span></span>
<span class="line"><span style="color:#24292e;">    public void run(){</span></span>
<span class="line"><span style="color:#24292e;">        // 执行代码</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">};</span></span>
<span class="line"><span style="color:#24292e;">new Thread(runnable).start();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="3"><li><code>通过实现Callable和Future创建线程</code>: 这种方式的优势就在于可以有返回值。Future 就像一个凭证，在将来的某个时间点获取结果。</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() {</span></span>
<span class="line"><span style="color:#e1e4e8;">    public Integer call() throws Exception {</span></span>
<span class="line"><span style="color:#e1e4e8;">        // 执行代码并返回结果</span></span>
<span class="line"><span style="color:#e1e4e8;">        return 0;</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">FutureTask&lt;Integer&gt; future = new FutureTask&lt;&gt;(callable);</span></span>
<span class="line"><span style="color:#e1e4e8;">new Thread(future).start();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() {</span></span>
<span class="line"><span style="color:#24292e;">    public Integer call() throws Exception {</span></span>
<span class="line"><span style="color:#24292e;">        // 执行代码并返回结果</span></span>
<span class="line"><span style="color:#24292e;">        return 0;</span></span>
<span class="line"><span style="color:#24292e;">    }</span></span>
<span class="line"><span style="color:#24292e;">};</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">FutureTask&lt;Integer&gt; future = new FutureTask&lt;&gt;(callable);</span></span>
<span class="line"><span style="color:#24292e;">new Thread(future).start();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>接下来是线程池：<br> Java 提供了一个线程池框架，通常我们会使用 ExecutorService 的实现类创建线程池。比如 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor。你可以通过以下方式创建：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">ExecutorService executor = Executors.newFixedThreadPool(10);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">ExecutorService executor = Executors.newFixedThreadPool(10);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>线程池提交任务主要有两种方式：<code>execute()</code>和<code>submit()</code>。</p><ol><li><code>execute(Runnable command)</code>: 用于提交一些一次性的任务，执行完成后就丢弃。</li><li><code>submit()</code>: 提交有返回值的任务，有三种形式：submit(Runnable task)、submit(Runnable task, T result)、submit(Callable task)。submit 方法返回一个 Future，我们可以通过 Future 获取线程执行后的返回结果。</li></ol><h3 id="线程创建的流程" tabindex="-1">线程创建的流程： <a class="header-anchor" href="#线程创建的流程" aria-label="Permalink to &quot;线程创建的流程：&quot;">​</a></h3><ol><li>新建线程</li><li>初始化线程，包含线程组，名称，优先级，是否是守护线程，目标对象等</li><li>调用线程的 start 方法，JVM 会调用该线程的 run 方法</li><li>线程进入 RUNNABLE 状态，等待 JVM 线程调度器调度</li><li>当线程执行完毕，或者出现未处理异常，则线程终止</li></ol><hr><h3 id="线程执行的流程" tabindex="-1">线程执行的流程： <a class="header-anchor" href="#线程执行的流程" aria-label="Permalink to &quot;线程执行的流程：&quot;">​</a></h3><ol><li>新线程被提交到线程池后，首先检查线程池状态，然后执行 addWorker 方法添加工作线程并执行任务</li><li>在 addWorker 中，首先会检查线程池状态和队列情况，然后创建工作线程，并放入到线程队列中，然后启动线程</li><li>线程启动后，会调用线程的 run 方法，执行任务</li><li>任务执行完毕后，线程不会立即销毁，而是等待新的任务</li><li>如果在 keepAliveTime 时间内没有新的任务，则线程将结束运行，进入 TERMINATED 状态</li></ol><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221342188.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221343708.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221343729.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221344828.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221344976.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221345323.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221345261.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221346059.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221346073.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221347716.png" alt="image.png"><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221347808.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221347143.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221348793.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221348631.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221349027.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221349212.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221350802.png" alt="image.png"></p>`,33),t=[p];function c(i,o,r,u,g,d){return a(),n("div",null,t)}const h=s(l,[["render",c]]);export{m as __pageData,h as default};
