import{_ as a,o,c as t,R as l}from"./chunks/framework.7FlijoJG.js";const d=JSON.parse('{"title":"rabbitmq-joehuang","description":"","frontmatter":{"title":"rabbitmq-joehuang","date":"2023-12-22T12:57:14.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"advance/rabbitmq-joehuang.md","filePath":"advance/rabbitmq-joehuang.md","lastUpdated":1703238046000}'),n={name:"advance/rabbitmq-joehuang.md"},s=l(`<h1 id="rabbitmq-的关键要素" tabindex="-1">rabbitmq 的关键要素 <a class="header-anchor" href="#rabbitmq-的关键要素" aria-label="Permalink to &quot;rabbitmq 的关键要素&quot;">​</a></h1><h2 id="建立连接" tabindex="-1">建立连接 <a class="header-anchor" href="#建立连接" aria-label="Permalink to &quot;建立连接&quot;">​</a></h2><ul><li>工厂、连接、通道：就像快乐大本营里的游戏一样，在 RabbitMQ 世界中，先要有一个工厂（ConnectionFactory）来生成连接（Connection），然后再由这些连接创建通道（Channel）。有了这些，才能开始我们的游戏大冒险，执行各种操作。</li><li>Spring 管理：试图把建立连接这件事交给 Spring，就像请管家照看你的豪宅。可以说这是一种“富贵病”，但是它让你可以更专注于业务实现而不被底层细节所困扰。</li></ul><h2 id="生产者" tabindex="-1">生产者 <a class="header-anchor" href="#生产者" aria-label="Permalink to &quot;生产者&quot;">​</a></h2><p>生产者（Producer）：这就像是一台“魔法饲料机”，它生产出一条又一条消息，然后喂给 RabbitMQ。</p><h2 id="交换机" tabindex="-1">交换机 <a class="header-anchor" href="#交换机" aria-label="Permalink to &quot;交换机&quot;">​</a></h2><h3 id="交换机的功能" tabindex="-1">交换机的功能 <a class="header-anchor" href="#交换机的功能" aria-label="Permalink to &quot;交换机的功能&quot;">​</a></h3><p>交换机（Exchange）：</p><ul><li>交换机连接生产者和队列，就像在大型舞台上，把明星（生产者）和粉丝（队列）连接起来。没有交换机，RabbitMQ 就会变得非常&quot;无聊&quot;。</li><li>它具有路由功能，决定生产的消息，应该如何转发到哪一个队列里面去。就像邮政员一样，根据地址把信送到各个不同的邮箱中。</li></ul><hr><h3 id="交换机的类型" tabindex="-1">交换机的类型 <a class="header-anchor" href="#交换机的类型" aria-label="Permalink to &quot;交换机的类型&quot;">​</a></h3><p>交换机的类型有四种：直接交换机（Direct）、主题交换机（Topic）、头交换机（Headers）和扇形交换机（Fanout）。每种类型的交换机都有其独特的“解码能力”。</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">直接交换机：直接交换机就像一个严谨的检查员，只有当消息的路由键（Routing</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">key）和绑定键一样时，才会将消息发送到对应的队列。也就是说，直接交换机是根据消息的“身份证”——路由键去找到它的“家”——队列。</span></span>
<span class="line"><span style="color:#B392F0;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">主题交换机：主题交换机的处理方式更像一个精妙的填词游戏，它把消息通过模糊匹配的方式发送到队列。路由键可以是多个词，这些词之间用&quot;.&quot;分隔，&quot;_&quot;%%</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">匹配一个词</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">%%，“#”匹配多个词（可以是零个）。比如，&quot;log.error&quot;的路由键能匹配到&quot;_.error&quot;和&quot;log.#&quot;的绑定键。</span></span>
<span class="line"><span style="color:#B392F0;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">头交换机：头交换机是一个颇有洁癖的角色，不走寻常路。它根据消息内容中的</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">headers</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">属性进行匹配。在这种类型中，路由键实际上并没有被用到。</span></span>
<span class="line"><span style="color:#B392F0;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">扇形交换机：</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">扇形交换机就像一个滔滔不绝的大嘴巴</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">，它会把所有发送到该交换机的消息路由到所有与它绑定的队列。在这种类型下，如果设置了路由键，也会被忽略。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">直接交换机：直接交换机就像一个严谨的检查员，只有当消息的路由键（Routing</span><span style="color:#24292E;"> </span><span style="color:#032F62;">key）和绑定键一样时，才会将消息发送到对应的队列。也就是说，直接交换机是根据消息的“身份证”——路由键去找到它的“家”——队列。</span></span>
<span class="line"><span style="color:#6F42C1;">-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">主题交换机：主题交换机的处理方式更像一个精妙的填词游戏，它把消息通过模糊匹配的方式发送到队列。路由键可以是多个词，这些词之间用&quot;.&quot;分隔，&quot;_&quot;%%</span><span style="color:#24292E;"> </span><span style="color:#032F62;">匹配一个词</span><span style="color:#24292E;"> </span><span style="color:#032F62;">%%，“#”匹配多个词（可以是零个）。比如，&quot;log.error&quot;的路由键能匹配到&quot;_.error&quot;和&quot;log.#&quot;的绑定键。</span></span>
<span class="line"><span style="color:#6F42C1;">-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">头交换机：头交换机是一个颇有洁癖的角色，不走寻常路。它根据消息内容中的</span><span style="color:#24292E;"> </span><span style="color:#032F62;">headers</span><span style="color:#24292E;"> </span><span style="color:#032F62;">属性进行匹配。在这种类型中，路由键实际上并没有被用到。</span></span>
<span class="line"><span style="color:#6F42C1;">-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">扇形交换机：</span><span style="color:#24292E;">  </span><span style="color:#032F62;">扇形交换机就像一个滔滔不绝的大嘴巴</span><span style="color:#24292E;">  </span><span style="color:#032F62;">，它会把所有发送到该交换机的消息路由到所有与它绑定的队列。在这种类型下，如果设置了路由键，也会被忽略。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>所以在这个“解码战舰”上，消息会被高效准确地分配去它们正确的“家”，即队列。对于 RabbitMQ 来说，找到一个适合你需求的交换机类型就像是找到了一个高效的邮政员，能把你的消息准确地送到它们应到达的地方。</p><hr><p>假设你是一位艺术家，想要向粉丝发送你的新录音——这就是我们的消息。你的粉丝们如果要接收你的新录音，他们需要订阅你的“交换机”。</p><ol><li><strong>Direct Exchange</strong>：向你的粉丝们公告，只有在‘rock’类型中订阅的粉丝会收到你的新录音。在这种情况下，只有那些订阅了为‘rock’的队列会收到消息。就像你把乐团通告放在一个专门的‘rock music’的公告栏上，喜欢‘rock music’的人就可以看到。</li><li><strong>Fanout Exchange</strong>：无论你的粉丝喜欢什么类型的音乐，他们都将收到你的新录音。这就是一种“广播”，所有订阅你的“交换机”的队列都会收到消息。就像你在一个巨大的广播站向全世界广播你的通告。</li><li><strong>Topic Exchange</strong>：这时候，你可以允许你的粉丝在更详细的级别上订阅，比如‘<em>.rock.</em>’。例如，那些订阅‘heavy.rock.guitars’的队列会接收到所有与‘heavy.rock.guitars’的消息，但那些只订阅‘rock’的则不会。就像你向所有热爱‘heavy rock guitars’的人进行发送，更具针对性。</li><li><strong>Headers Exchange</strong>：这是一种更高级的场景，你可以根据消息内容中的‘headers’的属性来匹配和发送消息。比如你发送一段&quot;Unplugged&quot;系列的录音，标头可以设置为&quot;{&#39;style&#39;: &#39;unplugged&#39;}&quot;，那么所有队列的标头也设置为&quot;{&#39;style&#39;: &#39;unplugged&#39;}&quot;的，就能接收到录音。</li></ol><p>以上就是四种交换机类型的象征性例子，每一种都有它的应用场景。就像学会乐器，掌握得越高，你可以创造的音乐就更丰富。即使在复杂的系统下，不忘初心，向音乐出发！</p><h2 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to &quot;队列&quot;">​</a></h2><p>队列（Queue）：这是消息的队伍，要尽职尽责地等待消费者来领取。</p><h2 id="消费者" tabindex="-1">消费者 <a class="header-anchor" href="#消费者" aria-label="Permalink to &quot;消费者&quot;">​</a></h2><p>消费者（Consumer）：最终的主角，他们就像是领奖的幸运儿，从队列中领取信息，然后进行处理。</p><h2 id="如何建立生产过程" tabindex="-1">如何建立生产过程 <a class="header-anchor" href="#如何建立生产过程" aria-label="Permalink to &quot;如何建立生产过程&quot;">​</a></h2><blockquote><p>建立连接，得到一个 channel 声明交换机（简单模式，工作模式，可以不声明交换机；；；发布订阅，direct, topic） 声明一个队列 进行一个交换机和队列绑定 路由规则，决定交换机的消息什么情况到队列 生产消息，发给交换机和路由规则</p></blockquote><p>创建一个生产过程有点像厨师做一个美味菜肴的步骤。就像要准备好原料、洗净、剁碎、炒煮一样，我们也有一些固定的步骤来制作一个“美味”的消息生产者。</p><ol><li><strong>建立连接，得到一个 channel</strong>：<br> 这就是收集所有原料的步骤。我们需要创建 ConnectionFactory（连接工厂），然后通过它创建一个新的 Connection（连接），接着我们再从这个连接中获取 Channel（通道）。这个过程就像切洋葱一样，你得一层一层剥开才能获取到核心部分。</li><li><strong>声明交换机</strong>：<br> 现在是“洗菜”的步骤了。决定了你要使用的交换机类型（direct, topic, fanout 等），你现在可以声明你的交换机了，这就像预热烤箱一样，做好准备工作。</li><li><strong>声明一个队列</strong>：<br> 这就像准备一个碗来放你做好的菜。你需要告诉 RabbitMQ 你的消息要放在哪个队列里。</li><li><strong>交换机和队列的绑定</strong>：<br> 好了现在你可以开始做菜了。你需要告诉 RabbitMQ 你的交换机（你的锅虽然热乎乎的，但你需要添加你的原料）和队列的绑定关系，这样 RabbitMQ 就知道这个交换机的消息会被发送到哪个队列。</li><li><strong>制定路由规则</strong>：<br> 这个环节就好像你在调试你的菜一样，你根据你的口味添加更多的香料或者原料到菜里。这里的路由规则就是你的口味，他决定了你的交换机会在什么情况下把消息送到你的队列（碗）里。</li><li><strong>生产消息，发送给交换机和路由规则</strong>：<br> 所有事情都准备就绪，你可以开始享用你的美食了。这个步骤就是把你的消息（菜肴）通过 channel（你的勺子）发送到交换机，然后交换机根据你设置的路由规则决定如何把消息路由到正确的队列。</li></ol><p>所以，创建一个生产者过程就像我们在厨房做一个美味的菜肴。不断地试验和修正，直到我们得到我们想要的结果。而最开心的是，我们做的菜肴通常不会太糟糕，因为我们始终有 RabbitMQ 这个料理师教程在旁边不断指导我们。</p><h2 id="如何建立消费过程" tabindex="-1">如何建立消费过程 <a class="header-anchor" href="#如何建立消费过程" aria-label="Permalink to &quot;如何建立消费过程&quot;">​</a></h2><blockquote><p>建立连接，得到 channel 声明到哪个交换机 声明一个队列（可以消费端单独实现） 绑定 消费消息</p></blockquote><p>感觉像这次我们是要做如何去品尝美食的指南！那很好，我们可以按照以下步骤行动：</p><ol><li><strong>建立连接，得到 channel</strong>：<br> 就像去餐厅前要确保你们的预订一样，我们需要建立一个连接并从中获取 channel，这是你进入 RabbitMQ 的大门的钥匙，没有它就不能继续下去。</li><li><strong>声明交换机</strong>：<br> 这个环节就像你在餐桌上坐好并开始读菜单。你需要指定从哪个交换机接收消息，就想选择好你要品尝的美食。</li><li><strong>声明一个队列</strong>：<br> 好了，拿出手机打开外卖 App，选择想要的食物吧。这个步骤就是你告诉 RabbitMQ 你要从哪个队列（商家）消费消息（食物）。注意，如果你选择的队列还未被创建，那么 RabbitMQ 会自动为你创建一个。</li><li><strong>绑定</strong>：<br> 这一步就像你选择好食物后，按下“下单”按钮一样，你需要将你的队列和交换机绑定在一起，这样 RabbitMQ 才能知道它应该为你分发什么。</li><li><strong>消费消息</strong>：<br> 等待一段时间后，你的食物终于到了，你可以开始享用啦！通过 channel 和 queue 进行消费操作，就真的像在品尝美食一样了！注意，你需要告诉 RabbitMQ 你是否已经成功消费了消息。如果成功，你就返回一个 ack（应答），RabbitMQ 就会从队列中删除该消息。如果消费过程中发生错误，你就发送一个 nack 或者不发送 ack，那么 RabbitMQ 会尝试再次分发给你或者直接放弃。</li></ol><p>这个消费者创建过程的例子感觉也很美味对吧？好比在享用美味大餐！</p><h2 id="消费模式" tabindex="-1">消费模式 <a class="header-anchor" href="#消费模式" aria-label="Permalink to &quot;消费模式&quot;">​</a></h2><blockquote><p>简述几种消费模式，画图</p></blockquote><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202312221259765.png" alt="image.png"></p><p>消费模式有点像你选择在什么场合用餐。快餐？家庭晚餐？还是烛光晚餐？让我来给你介绍一下几种不同的 RabbitMQ 消费模式。</p><ol><li><strong>简单模式</strong>：<br> 就像享用快速便捷的快餐，一个生产者发送消息给一个消费者，这就是最简单的模型。不过，人生不可能只有一种味道，对吧？</li><li><strong>工作模式</strong>：<br> 这是家庭晚餐的场景，一份食物，大家轮流品尝。在这个模式下，一个生产者，多个消费者，每个消费者获取到的消息是唯一的。RabbitMQ 默认使用轮询调度（Round-Robin Scheduling）方式来分发消息。</li><li><strong>发布订阅模式</strong>：<br> 这有点像举办一场大型晚宴，大家分享同样的食物。一条消息会被投递给所有的队列，消费者从自己的队列中获取消息，每个队列都有一个消费者来消费。这就是说，每个消费者都会接收到同样的消息。</li><li><strong>路由模式</strong>：<br> 这像是在自助餐厅，你可以根据自己的口味选择想要的食物。这个模式相比发布订阅模式，增加了路由功能。生产者在发送的时候定性 Routing key，消费者在绑定的时候也定性 Routing key，消息最后会投放到 Routing key 完全相同的队列里去。</li><li><strong>Topic 模式</strong>：<br> 最后，这像是去酒吧，不仅有食物，还有各种各样的鸡尾酒。Topic 模式就更加灵活，它让路由变得更加动态。队列和交换机之间的绑定会定义一种模式，然后 RabbitMQ 会将满足模式的所有消息路由给队列。</li></ol><p>正如你在晚餐时可以根据您的心情和需求选择不同的餐饮模式一样，RabbitMQ 为你提供了各种模式来满足你的需求。</p><h1 id="消息的消费" tabindex="-1">消息的消费 <a class="header-anchor" href="#消息的消费" aria-label="Permalink to &quot;消息的消费&quot;">​</a></h1><h2 id="消费者缓冲区的设置" tabindex="-1">消费者缓冲区的设置 <a class="header-anchor" href="#消费者缓冲区的设置" aria-label="Permalink to &quot;消费者缓冲区的设置&quot;">​</a></h2><blockquote><p>Rabbitmq 推送，队列不断给消费者推送，push Kafka 就是 pull 默认情况，不断推送，消费者积压未处理消息，占用大量内存设置缓冲区，100~300，测试验证最大未确认消息数量阈值设置</p></blockquote><p>消费者的缓冲区设置，这就像你在自助餐厅里为自己挑选食物的那个托盘。</p><p>RabbitMQ 默认是采用推送模式（push），意味着它会持续不断地推送消息到消费者，而不关注消费者的处理速度和能力。这就好比自助餐的厨师不断地将食物放进你的托盘，而不管你有没有空间装下。如果消费者处理消息的速度跟不上消息到来的速度，那么未处理的消息就会积累起来，占用大量内存。</p><p>为了避免这种情况，RabbitMQ 引入了流量控制机制，也就是我们可以设置消费者的缓冲区大小，或者说是“预取数”（prefetch count）。预取数可以限制 RabbitMQ 给消费者推送的未确认消息的数量。</p><p>例如，如果我们设置预取数为 100，那就意味着 RabbitMQ 在接收到消费者对一个消息的确认信号之前，最多只会向它推送 100 条消息。这就好像你的托盘只能装 100 个食物，不论厨师是否还有更多的食物，都必须在你的托盘有空间的时候再给你端上新的食物。</p><p>通过这种方式，RabbitMQ 可以确保消费者的缓冲区中消息的数量不会无限增长，避免了消费者因内存溢出而崩溃。</p><p>如何设置预取数呢？只需在 Consumer 对象上调用 basicQos 方法，传入你想设置的预取数即可，比如你的例子中是 100~300。但具体的预取数值应该根据实际的应用场景和消费者的处理能力进行测试和调整。</p><p>就这样，不论是在自助餐还是使用 RabbitMQ，我们都需要找到合适自己的那个“托盘大小”，以确保最佳的体验。</p><h2 id="消息应答" tabindex="-1">消息应答 <a class="header-anchor" href="#消息应答" aria-label="Permalink to &quot;消息应答&quot;">​</a></h2><p>消息的应答机制就像你在商店购买物品后，付款并拿到收据的过程。这就是 rabbitmq 的消息确认机制，主要分为以下几点：</p><ol><li><strong>应答（Acknowledgment）</strong>：<br> 当 RabbitMQ 投递消息给消费者之后，它需要知道消息是否成功到达。消费者会发送一个应答（ACK）告诉 RabbitMQ 已经成功接收并处理了这些消息。这就像你告诉店员：“好的，我已经拿到货物了。”</li><li><strong>消息删除</strong>：<br> 当 RabbitMQ 收到 ACK 后，它会删除队列中的对应消息，就像销母我们在售货员手中的货物记录一样。</li><li><strong>自动应答</strong>：<br> 这种方式是 RabbitMQ 默认的应答模式，也叫做自动确认。当消息一旦被投递，消费者会立刻回送 ACK，无需等待消费者实际处理完消息。这就好像你一拿到货就告诉售货员我已经确认，但实际上你还没检查货物。</li><li><strong>消费者异常</strong>：<br> 但是在自动应答模式下，如果消费者在处理消息的过程中发生故障宕机了该怎么办？MQ 无从得知，已发出的消息就会丢失。这就像当你拿到货走到门口时撞到门槛摔倒，还没来得及确认货物的情况，结果货物就丢了。</li><li><strong>手动应答</strong>：<br> 因此，在生产环境中，推荐使用手动应答。消费者处理完消息后，再发送确认信息。如果消费者在处理消息过程中宕机，未发送确认信号的消息则会被 RabbitMQ 重新投递。这就像你认真检查货物后才确认并告诉售货员：“我已经确认，货物没问题。”</li><li><strong>实现确认机制</strong>：<br> 在 Spring 中，我们可以在消费者（Listener）代码里面调用 Channel 的 basicAck 方法来发送 ACK。如果我们需要在业务处理成功后确认，那么我们可以保证消息一定被正确处理。</li></ol><p>所以总体来说，消息的应答机制就是一个有保障的处理流程，确保了消息一定会被正确处理，不会丢失。这不仅可以让我们更加安心，也保证了我们的消息通信的稳定可靠！</p><h2 id="幂等性" tabindex="-1">幂等性 <a class="header-anchor" href="#幂等性" aria-label="Permalink to &quot;幂等性&quot;">​</a></h2><ol><li><p><strong>何为幂等性</strong>:<br> 幂等性在计算中主要指的是一次和多次请求某一个资源应该具有同样的副作用。简单点说，就像你多次点击电梯按钮，无论你点击一次或者狂点 1000 次，电梯都只会来一次。这就是幂等性，它确保了重复执行操作，结果都是一致的。</p></li><li><p><strong>消息重复发送，也是成功消费 1 条</strong>:<br> 在 RabbitMQ 中，可能会因为网络问题，消费者处理速度，甚至是 RabbitMQ 的内部错误，可能导致消息被重复发送。但如果我们实现了幂等性，就能保证即便消息被重复消费，应用的状态也不会改变，就像你不断按电梯按钮，电梯也只会来一次。</p></li><li><p><strong>如何解决</strong>:<br> 如何保证幂等性呢？其实有很多方法。例如，我们可以使用 Redis 的 SETNX 命令来做，SETNX 会先检查这个 key 是否存在，如果不存在，那么设置值，如果存在，那么不会进行设置。这样我们就只会处理一个消息。</p><p>另外，也可以在消费端维护一个计数器。每当消费一个消息，就将消息的 id 和消费状态存入一个数据表中，只有当消费状态为未处理时，我们才真正去消费该消息。</p><p>这两种方法都是为了确保我们的程序在处理消息时，能够保证消费操作的幂等性。</p></li></ol><h2 id="如何保证生产消息高可用" tabindex="-1">如何保证生产消息高可用 <a class="header-anchor" href="#如何保证生产消息高可用" aria-label="Permalink to &quot;如何保证生产消息高可用&quot;">​</a></h2><p>提高消息的高可用性，像是你在备好不同的道具来做一道丰富可口的料理。那好，让我们开始这个旅程吧！</p><ol><li><strong>生产 ACK 的流程（发布确认流程）</strong>：<br> 在发布消息前，我们需要先建立一个连接。就像你首先要回到你的厨房一样，这个步骤就是创建一个连接到 RabbitMQ 的信道（Channel）。然后生产者开始生成消息，这时候信道会帮每条消息创建一个唯一的 id，然后 RabbitMQ 收到消息后会返回一个 ACK 或 NACK，并带上这个 id。这就像你做好了每道菜，然后餐厅的服务员会告诉你，这道菜是否成功送达每一个顾客。</li><li><strong>同步方式 (单个确认，批量确认)</strong>：<br> 生产者可以选择单个确认还是批量确认。单个确认意味着每发送一条消息就收到确认，批量确认则是指定一个数量，只有当这个数量的消息都发送出去后才收到确认。这就像煮饭，你可以选择每完成一道菜就试一下味道，或者一口气做完几道菜再试。</li><li><strong>异步方式的实现</strong>：<br> 对于高并发的环境，异步确认更加有优势。因为它在确认消息的过程中不会阻塞其他操作，也就是说，生产者在等待确认的同时，还可以继续发送其他消息。这就像你在等待一道菜炖的时候，可以处理另一道菜一样，效率更高。</li><li><strong>备份交换机</strong>：<br> 这是一个进阶的方案。如果你的主交换机因为某种原因无法正常工作，RabbitMQ 可以自动将消息路由到备份交换机。这样即使出现问题，消息也不会丢失。这就像是餐馆里有源源不断的食材供应，即使你手上的一部分食材出了问题，你也能从其他地方拿到新的食材来继续做菜。</li></ol><p>通过以上步骤，我们可以实现消息的高可用性，这就像用不同的工具和方法来烹饪一道好菜一样，只要我们精心准备，掌握每一个环节，就可以做出我们自己的杰作。</p><h2 id="延迟队列" tabindex="-1">延迟队列 <a class="header-anchor" href="#延迟队列" aria-label="Permalink to &quot;延迟队列&quot;">​</a></h2><p>延迟队列就像是一个警钟，你无需盯着它，但当时间到了，它会提醒你关注那些重要的事情。</p><ol><li><p><strong>延迟队列是什么</strong>：<br> 延迟队列就是消息在被消费前，会在队列中等待一定时长。这个时长是在消息被发送时设定的。简单说，它就像是你为烤箱设置了倒计时，当时间到了，烤箱会发出提示音，告诉你食物已经烤好了。</p></li><li><p><strong>延迟队列的应用场景</strong>：<br> 延迟队列在很多业务中都有应用。比如你提到的网购支付，支付系统可以镜像订单的最终付款时间，如果用户在这个时间内没有支付，那么系统就会自动取消订单。还有会议室预订系统，系统可以在会议即将开始的前一段时间，向所有与会人员发出提醒。此外，优惠券系统也会在优惠券即将过期前，向用户发送提醒。</p></li><li><p><strong>RabbitMQ 实现延迟队列</strong>：<br> RabbitMQ 可以通过插件或 TTL 和死信队列功能来实现延迟队列。插件方式的话，你可以安装 rabbitmq_delayed_message_exchange 插件。而通过 TTL 和死信队列实现稍微复杂些，首先为队列设置消息过期时间（TTL），当队列中的消息过期后，RabbitMQ 会把它发送到另一个你预设的死信队列，这样消费者就可以从死信队列里拿到这个“延迟”消息了。</p><p>使用延迟队列，不再需要持续性地轮询并比较时间，大大降低了系统的复杂性和负担，提高效率。这就像一个自动的烤箱，只需设定时间，就可以放心做自己的事情，等到食物烤好了，烤箱会自动提醒你。</p></li></ol><h2 id="死信队列" tabindex="-1">死信队列 <a class="header-anchor" href="#死信队列" aria-label="Permalink to &quot;死信队列&quot;">​</a></h2><p>死信队列就像是邮局的遗失物品箱，那些无人认领或者无法送达的包裹，都会被放进这个箱子里，等待后续处理。那么让我们详细了解一下这个“遗失物品箱”吧。</p><ol><li><p><strong>什么是死信队列</strong>：<br> 在 RabbitMQ 中，死信队列用于处理无法正常消费的消息。任何由于如下原因从队列中移除的消息，都会被送到该队列所绑定的死信队列中。</p></li><li><p><strong>什么情况进入死信队列</strong>：<br> 一条消息会因为以下三种情况进入死信队列：</p><ul><li>消息被消费者拒绝（Basic.Reject/Basic.Nack），并且是不可重入队列的（requeue=false）。</li><li>消息在队列的存活时间到了（TTL 过期）。</li><li>队列长度限制了，队列已满。</li></ul></li><li><p><strong>死信队列如何设置</strong>：<br> 我们可以在声明队列的时候进行设置。在参数中添加&quot;x-dead-letter-exchange&quot;，对应的值是任意的 exchange 的名字。当这个队列中的消息变成死信后，就会被发布到这个 exchange 中。你还可以设置&quot;x-dead-letter-routing-key&quot;，这样的话，死信在发布到该参数指定的 exchange 时，会被设定一个新的 routing-key，如果不设置则保持原来的 routing-key 不变。</p></li></ol><p>设置后，原队列的异常消息就会到你设置的死信队列去了，这就像是邮局将所有的遗失物品都放在了一处专门处理这些物品的地方，方便进行集中管理。</p><p>在这个死信队列中，你可以对这些消息进行重新消费，或者进行日志记录等操作。这样就能确保每一条消息都不会丢失，每一份“遗失的快递”都可以找回它该去的地方。</p><p>哈哈，希望你已经理解了这个“邮局”的运作！</p><h2 id="关于-ttl-普通队列的两种实现方式" tabindex="-1">关于 ttl 普通队列的两种实现方式 <a class="header-anchor" href="#关于-ttl-普通队列的两种实现方式" aria-label="Permalink to &quot;关于 ttl 普通队列的两种实现方式&quot;">​</a></h2><p>在 RabbitMQ 中，设置消息的过期时间 TTL(&quot;Time to Live&quot;)比你设置煮饭的计时器还要简单呢。让我们一起了解一下：</p><ol><li><strong>固定 TTL 队列</strong>：<br> 就像你设置烤箱的定时器，当时间到了，所有的食物都要出炉。你可以在声明队列的时候为整个队列设置 TTL，这样所有进入到这个队列的消息都将具有相同的过期时间。如果消息在这个 TTL 时间内没有被消费，那么这条消息就会从队列中移除。</li><li><strong>消息带 TTL 队列</strong>：<br> 当然，每个食物的烹饪时间可能都不同，这时候你可能需要单独为每个食物设置一个定时器。在 RabbitMQ 中，你也可以在发布消息的时候，给每条消息单独设置一个 TTL。这样，每条消息的过期时间都各不相同。就像你把每道菜放进烤箱的时间都不一样，每道菜烤好的时间自然也会不一样。</li><li><strong>先来后到的问题</strong>：<br> 如果是在队列里设置了 TTL，那么消息过期的顺序为先入先出。但是如果是在消息上设置了 TTL，就会产生一个问题。当一个先到的消息设置的 TTL 较长，后面到的消息 TTL 较短，那么可能出现后到的消息已经过期，但是因为前面的消息还没过期，这个消息就类围在队列中出不来，这就好像咱们烧烤，前面的肉串烤得慢，后面的却烤糊了，但因为串子的顺序，你没法取出已经烤糊的串子。</li></ol><p>所以我们在设定消息的过期时间时，应该充分考虑队列的实际需求和可能出现的问题。记得充分利用厨房（RabbitMQ）的功能，烹饪出各种美味的菜肴（处理各种复杂的消息场景）哦！</p><h2 id="固定-ttl-队列和消息带-ttl-队列有什么区别" tabindex="-1">固定 TTL 队列和消息带 TTL 队列有什么区别？ <a class="header-anchor" href="#固定-ttl-队列和消息带-ttl-队列有什么区别" aria-label="Permalink to &quot;固定 TTL 队列和消息带 TTL 队列有什么区别？&quot;">​</a></h2><p>为了更好地理解固定 TTL 队列和消息带 TTL 队列的区别，我们来想象一个烹饪场景：</p><p>假如固定 TTL 队列是一个烤箱，你为这个烤箱设置了一个统一的定时器。就像你要烘焙一批面包，你把烤箱预设在 200 度，定时 30 分钟。这就是固定 TTL 队列，每个面包（也就是消息）都会在相同的时间条件下烘焙（被处理）。如果没有在规定的时间内被取出（也就是被消费），那么面包就会糊掉（被 RabbitMQ 移出队列）。</p><p>而消息带 TTL 队列呢，就像你在烤箱里同时烤了鸡肉和蔬菜。因为鸡肉和蔬菜需要的烹饪时间不同，所以你必须分别为他们设置时间。鸡肉可能需要 60 分钟，而蔬菜可能只需要 20 分钟。这就像你为每条消息单独设置了 TTL，它们都有各自的过期时间。</p><p>然而，这里存在一个问题。因为 RabbitMQ 是先入先出的，如果鸡肉（较长的 TTL）在蔬菜（较短的 TTL）之前进入队列，即使蔬菜已经“熟”了（消息过期了），它也不能被“取出”（被消费），直到鸡肉“熟”了（它前面的消息都被消费了）。这可能会导致一些效率问题，所以在设置消息的 TTL 时，我们需要充分考虑这些因素。</p><p>总的来说，固定 TTL 队列的优点在于简单、容易控制，但缺点是 lacks flexibility，面对复杂场景可能力不从心。消息带 TTL 队列对每条消息进行单独设置，可以应对更多变的场景，但需要更多的考虑和控制。</p><h2 id="如何解决消息单独延迟问题" tabindex="-1">如何解决消息单独延迟问题 <a class="header-anchor" href="#如何解决消息单独延迟问题" aria-label="Permalink to &quot;如何解决消息单独延迟问题&quot;">​</a></h2><p>解决这个问题，就像是你找到了烘焙面包的完美温度和时间，让每个面包都能恰到好处。</p><p>要解决消息单独延迟问题，我们可以使用 RabbitMQ 的一个插件——延迟消息插件，这个插件可以给每个消息单独设置 TTL。所以，当你给每条消息设置不同的延迟时间时，这个插件就能独挡一面！</p><ol><li><p><strong>RabbitMQ 的延迟消息插件</strong>：<br> 这个插件可以声明一个延迟交换器，任何被路由到该交换器的消息都可以被延迟。延迟时间不是在队列或者消息上设置，而是在消息的 header 中添加一个&quot;expiration&quot;参数来设置，这本质上是在 Exchange 上做了一个指定的延迟时间。</p><p>你应该在发送消息时，设置&#39;x-delayed-message&#39;插件类型和&#39;routedelay&#39;头，&#39;routedelay&#39;头即为消息的延迟时间。消息无论如何都会被插件接收，但只有当延迟时间达到时，消息才会被发送到相应的队列。</p></li></ol><p>使用这个插件就像拥有了一个会做魔法的烤箱，任何放进去的面包都可以在预定的时间烘焙好，即使每个面包需要的时间都不同。这就给了我们更多的灵活性来处理不同的业务场景，同时还保证了高效的处理效率。</p><p>好了，这就是我们解决每条消息单独延迟问题的方法，你已经掌握了这个新的“烹饪技巧”，是不是感觉非常棒！</p>`,83),e=[s];function r(i,p,b,c,h,u){return o(),t("div",null,e)}const q=a(n,[["render",r]]);export{d as __pageData,q as default};
