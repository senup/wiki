import{_ as t,o as e,c as a,R as o}from"./chunks/framework.7FlijoJG.js";const U=JSON.parse('{"title":"insertOrUpdate导致的死锁","description":"","frontmatter":{"title":"insertOrUpdate导致的死锁","date":"2023-12-23T19:52:12.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"数据库/insertOrUpdate导致的死锁.md","filePath":"数据库/insertOrUpdate导致的死锁.md","lastUpdated":1711296414000}'),p={name:"数据库/insertOrUpdate导致的死锁.md"},r=o("<p>在许多情况下，&quot;Insert on Duplicate Key Update&quot;可以工作的很好，但是如果在具有竞争条件的高并发环境下，它可能会导致死锁。</p><p>发生的死锁主要取决于事务的锁顺序和锁粒度。在多事务并发执行时，如果两个事务试图以不同的顺序获取相同的锁，就会发生死锁。</p><p>例如，在事务 A 中：</p><ol><li>事务 A 尝试对记录 1 进行&quot;Insert on Duplicate Key Update&quot;操作</li><li>在此同时，事务 B 也尝试对记录 2 进行&quot;Insert on Duplicate Key Update&quot;操作</li></ol><p>现在，事务 A 想要对记录 2 进行&quot;Insert on Duplicate Key Update&quot;操作，而事务 B 同时也想要对记录 1 进行此操作。</p><ol><li>事务 A 已经锁定了记录 1，现在需要锁定记录 2 以进行更新。但记录 2 已经被事务 B 锁定。</li><li>事务 B 已经锁定了记录 2，现在需要锁定记录 1 以进行更新。但记录 1 已经被事务 A 锁定。</li></ol><p>这就导致了一个死锁。事务 A 和事务 B 现在都在等待对方释放锁，但这永远不会发生，因为每个事务都在等待对方首先行动。</p><p>要解决这个问题，一种有效的方法是强制事务总是以相同的顺序获取锁。这样，死锁的可能性就会大大降低。或者，您有时可以通过减小锁的粒度（例如，使用行级锁代替表级锁）来减少死锁的可能性。然而，这可能会影响性能，所以湖衡这些改变的影响需要具体分析。</p>",8),s=[r];function i(n,_,l,d,c,u){return e(),a("div",null,s)}const m=t(p,[["render",i]]);export{U as __pageData,m as default};
