import{_ as a,o as e,c as s,R as l}from"./chunks/framework.7FlijoJG.js";const b=JSON.parse('{"title":"joe的Redis","description":"","frontmatter":{"title":"joe的Redis","date":"2024-01-10T09:14:41.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"Redis/joe的Redis.md","filePath":"Redis/joe的Redis.md","lastUpdated":1711296414000}'),i={name:"Redis/joe的Redis.md"},o=l(`<h1 id="redis-持久化-rdb-和-aof" tabindex="-1">Redis 持久化 - RDB 和 AOF <a class="header-anchor" href="#redis-持久化-rdb-和-aof" aria-label="Permalink to &quot;Redis 持久化 - RDB 和 AOF&quot;">​</a></h1><h2 id="rdb-全量备份" tabindex="-1">RDB 全量备份 <a class="header-anchor" href="#rdb-全量备份" aria-label="Permalink to &quot;RDB 全量备份&quot;">​</a></h2><h3 id="rdb-基本介绍" tabindex="-1">RDB 基本介绍 <a class="header-anchor" href="#rdb-基本介绍" aria-label="Permalink to &quot;RDB 基本介绍&quot;">​</a></h3><p>RDB 全称 Redis Database Backup file,是 Redis 的一种持久化方式。</p><p>它对 Redis 中的数据库状态进行周期性的快照保存,这种快照称为 RDB 文件。RDB 文件包含了一个时间点的所有数据库中的键值对。</p><p>RDB 的优点是:</p><ul><li>RDB 是一个紧凑的单一文件,非常适合用于备份和镜像。</li><li>RDB 读取速度快,可以最大限度地减少启动时间。</li></ul><h3 id="rdb-的保存" tabindex="-1">RDB 的保存 <a class="header-anchor" href="#rdb-的保存" aria-label="Permalink to &quot;RDB 的保存&quot;">​</a></h3><p>RDB 保存可以通过两种方式触发:</p><ul><li>使用 SAVE 命令手动触发。这是阻塞 Redis 主线程的,会停止其他服务,等待 RDB 进程完成。</li><li>使用 BGSAVE 命令,由后台线程进行 RDB 保存。这是非阻塞方式。</li></ul><p>除此之外,还可以通过配置自动触发:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">save 900 1 #900秒内如果有1个key发生变化,则自动触发bgsave,使用后台线程持久化</span></span>
<span class="line"><span style="color:#e1e4e8;">save 300 10 #300秒内如果有10个key发生变化,则自动触发bgsave,使用后台线程持久化</span></span>
<span class="line"><span style="color:#e1e4e8;">save 60 10000 #60秒内如果有10000个key发生变化,则自动触发bgsave,使用后台线程持久化</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">save 900 1 #900秒内如果有1个key发生变化,则自动触发bgsave,使用后台线程持久化</span></span>
<span class="line"><span style="color:#24292e;">save 300 10 #300秒内如果有10个key发生变化,则自动触发bgsave,使用后台线程持久化</span></span>
<span class="line"><span style="color:#24292e;">save 60 10000 #60秒内如果有10000个key发生变化,则自动触发bgsave,使用后台线程持久化</span></span></code></pre></div><h3 id="rdb-文件" tabindex="-1">RDB 文件 <a class="header-anchor" href="#rdb-文件" aria-label="Permalink to &quot;RDB 文件&quot;">​</a></h3><p>每次 RDB 保存会生成一个新的 RDB 文件。RDB 文件是一个紧凑的单一文件,里面包含了给定时间点的所有数据库的数据。</p><p>一个 RDB 文件中提供了 Redis 版本号、数据库全部数据快照、数据校验和等信息。文件内容是经过压缩的,非常适合做备份和异地数据传输。</p><h2 id="aof-增量备份" tabindex="-1">AOF 增量备份 <a class="header-anchor" href="#aof-增量备份" aria-label="Permalink to &quot;AOF 增量备份&quot;">​</a></h2><h3 id="aof-基本介绍" tabindex="-1">AOF 基本介绍 <a class="header-anchor" href="#aof-基本介绍" aria-label="Permalink to &quot;AOF 基本介绍&quot;">​</a></h3><p>AOF(Append Only File)是另一种持久化方式,它会追加写每一个写命令到一个 AOF 文件中,所以是增量持久化。</p><p>与 RDB 在持久化完之后是一个完整的文件不同,AOF 持久化依赖命令日志,可以部分恢复数据。</p><p>AOF 的优点是可以最大程度地保证数据不丢失,缺点是文件会变得越来越大。</p><h3 id="aof-的保存" tabindex="-1">AOF 的保存 <a class="header-anchor" href="#aof-的保存" aria-label="Permalink to &quot;AOF 的保存&quot;">​</a></h3><p>Redis 提供了三种策略进行 AOF 的刷盘控制:</p><ul><li><p><strong>always</strong>: 每个写命令都立即强制写入硬盘,效率最低,数据完整性最好。</p></li><li><p><strong>everysec</strong>: 每秒钟刷盘一次,或当输出缓冲区满时刷盘,是默认策略。</p></li><li><p><strong>no</strong>: 不根据时间频率刷盘,只有系统调用强制刷盘时才刷盘,效率最高,数据完整性最差。</p></li></ul><h3 id="aof-重写" tabindex="-1">AOF 重写 <a class="header-anchor" href="#aof-重写" aria-label="Permalink to &quot;AOF 重写&quot;">​</a></h3><p>为了减小 AOF 文件大小,Redis 提供了 AOF 重写(rewrite)機制,即重新生成一个新 AOF 来替代现有的 AOF。</p><p>AOF 重写可以手动触发,也可以通过配置自动触发:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span style="color:#e1e4e8;">auto-aof-rewrite-min-size 64mb</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">auto-aof-rewrite-percentage 100</span></span>
<span class="line"><span style="color:#24292e;">auto-aof-rewrite-min-size 64mb</span></span></code></pre></div><p>上面配置表示 AOF 文件大小是上次重写之后大小的两倍并且文件大小超过 64M 时会自动触发。</p><h2 id="rdb-和-aof-的选择" tabindex="-1">RDB 和 AOF 的选择 <a class="header-anchor" href="#rdb-和-aof-的选择" aria-label="Permalink to &quot;RDB 和 AOF 的选择&quot;">​</a></h2><ul><li><p>如果对数据完整性要求较高,则应该使用 AOF。</p></li><li><p>如果对性能要求较高,则应该使用 RDB。</p></li><li><p>Redis 4.0 开始支持 RDB 和 AOF 的混合使用。可以在一天当中定时生成 RDB 文件,而在 RDB 之间的时间使用 AOF 进行增量保存,这样既保证了完整性,也部分保证了性能。</p></li><li><p>对于内存数据集较大时,建议不要太频繁的生成 RDB 全量备份,否则会消耗很大系统性能。32G 内存时增量备份就比较合适。</p></li><li><p>建议使用后台线程生成 RDB,而 AOF 的刷盘策略则使用每秒或关闭策略。</p></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ol><li><p>RDB 适合备份和恢复大数据集。AOF 适合故障和极端情况下的数据恢复。</p></li><li><p>在性能要求较高的场景下,可以关闭 RDB 和 AOF,直接使用内存。或仅使用 RDB。在数据要求完整的场景下,可以开启 AOF。</p></li><li><p>通过配置 RDB 和 AOF 的自动触发策略,可以实现在保证性能的同时兼顾数据可靠性。</p></li><li><p>合理配置刷盘策略,不要让 RDB 和 AOF 的生成过于频繁影响性能。</p></li></ol><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101039849.png" alt="image.png"><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101045658.png" alt="image.png"></p><p><img src="https://bestkxt.oss-cn-guangzhou.aliyuncs.com/img/202401101049111.png" alt="image.png"></p>`,34),t=[o];function n(p,r,d,c,h,u){return e(),s("div",null,t)}const g=a(i,[["render",n]]);export{b as __pageData,g as default};
