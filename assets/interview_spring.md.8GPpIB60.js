import{_ as a,o as e,c as n,R as s}from"./chunks/framework.7FlijoJG.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/spring.md","filePath":"interview/spring.md","lastUpdated":1701248274000}'),r={name:"interview/spring.md"},l=s(`<h3 id="spring中的模块" tabindex="-1">Spring中的模块 <a class="header-anchor" href="#spring中的模块" aria-label="Permalink to &quot;Spring中的模块&quot;">​</a></h3><h3 id="spring中bean的作用域" tabindex="-1">Spring中bean的作用域 <a class="header-anchor" href="#spring中bean的作用域" aria-label="Permalink to &quot;Spring中bean的作用域&quot;">​</a></h3><h3 id="ioc原理" tabindex="-1">IoC原理 <a class="header-anchor" href="#ioc原理" aria-label="Permalink to &quot;IoC原理&quot;">​</a></h3><h3 id="aop原理" tabindex="-1">AOP原理 <a class="header-anchor" href="#aop原理" aria-label="Permalink to &quot;AOP原理&quot;">​</a></h3><h3 id="spring事务" tabindex="-1">Spring事务 <a class="header-anchor" href="#spring事务" aria-label="Permalink to &quot;Spring事务&quot;">​</a></h3><h3 id="spring中用到的设计模式" tabindex="-1">Spring中用到的设计模式 <a class="header-anchor" href="#spring中用到的设计模式" aria-label="Permalink to &quot;Spring中用到的设计模式&quot;">​</a></h3><h3 id="springmvc-运行流程" tabindex="-1">SpringMVC 运行流程 <a class="header-anchor" href="#springmvc-运行流程" aria-label="Permalink to &quot;SpringMVC 运行流程&quot;">​</a></h3><h3 id="spring-中的-controller-和-service-是线程安全的吗" tabindex="-1">Spring 中的 Controller 和 Service 是线程安全的吗？ <a class="header-anchor" href="#spring-中的-controller-和-service-是线程安全的吗" aria-label="Permalink to &quot;Spring 中的 Controller 和 Service 是线程安全的吗？&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">在 Spring 中，Controller 和 Service 默认情况下是单例的，也就是说它们在应用程序的整个生命周期内只会被实例化一次。因此，如果它们没有状态（即不包含可变的实例变量），它们是线程安全的。但是，如果它们包含可变状态，你需要确保状态的同步以确保线程安全。通常推荐避免在 Controller 和 Service 中使用实例变量来保存状态，而是尽可能使用方法内的局部变量，或者使用线程安全的数据结构来管理状态。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">在 Spring 中，Controller 和 Service 默认情况下是单例的，也就是说它们在应用程序的整个生命周期内只会被实例化一次。因此，如果它们没有状态（即不包含可变的实例变量），它们是线程安全的。但是，如果它们包含可变状态，你需要确保状态的同步以确保线程安全。通常推荐避免在 Controller 和 Service 中使用实例变量来保存状态，而是尽可能使用方法内的局部变量，或者使用线程安全的数据结构来管理状态。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="包含可变状态是怎么样呢" tabindex="-1">包含可变状态是怎么样呢？ <a class="header-anchor" href="#包含可变状态是怎么样呢" aria-label="Permalink to &quot;包含可变状态是怎么样呢？&quot;">​</a></h3><p>假设类里面有一个计数器的变量，同时有查询计数值的方法，那么多个线程同时访问这个方法的时候，会有竞争的问题，导致数值不准确。可以使用 <code>AtomicInteger</code> 类来管理计数器，它提供了原子性的操作，避免了多线程访问时的竞态条件问题。</p><h3 id="说下你对原子类的理解" tabindex="-1">说下你对原子类的理解？ <a class="header-anchor" href="#说下你对原子类的理解" aria-label="Permalink to &quot;说下你对原子类的理解？&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">原子类是 Java 中提供的一组特殊数据类型，它们能够在多线程环境下进行原子操作，保证了特定操作的原子性。原子性指的是一个操作是不可中断的，要么全部执行成功，要么完全不执行，不会出现部分执行的情况。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">Java 中的 \`java.util.concurrent.atomic\` 包提供了多种原子类，比如 \`AtomicInteger\`、\`AtomicLong\`、\`AtomicBoolean\` 等。这些类提供了一些常见的原子操作，比如增加值、减少值、设置值等，这些操作是线程安全的，不需要额外的同步手段就可以保证多线程环境下的正确性。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">原子类的主要特点包括：</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">1. **原子操作：** 原子类的操作是原子的，不会被线程调度机制打断。</span></span>
<span class="line"><span style="color:#e1e4e8;">2. **线程安全：** 在多线程环境下，原子类提供了线程安全的操作，无需额外的同步措施。</span></span>
<span class="line"><span style="color:#e1e4e8;">3. **底层实现：** 这些类使用了底层的 CAS（Compare and Swap）操作来实现原子性，即比较并交换操作，保证了并发情况下的线程安全性。</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">原子类通常用于需要在多线程环境下进行操作的场景，比如计数器、标志位的更新等。它们能够提供高效且线程安全的解决方案，避免了使用锁所带来的开销和复杂性。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">原子类是 Java 中提供的一组特殊数据类型，它们能够在多线程环境下进行原子操作，保证了特定操作的原子性。原子性指的是一个操作是不可中断的，要么全部执行成功，要么完全不执行，不会出现部分执行的情况。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">Java 中的 \`java.util.concurrent.atomic\` 包提供了多种原子类，比如 \`AtomicInteger\`、\`AtomicLong\`、\`AtomicBoolean\` 等。这些类提供了一些常见的原子操作，比如增加值、减少值、设置值等，这些操作是线程安全的，不需要额外的同步手段就可以保证多线程环境下的正确性。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">原子类的主要特点包括：</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">1. **原子操作：** 原子类的操作是原子的，不会被线程调度机制打断。</span></span>
<span class="line"><span style="color:#24292e;">2. **线程安全：** 在多线程环境下，原子类提供了线程安全的操作，无需额外的同步措施。</span></span>
<span class="line"><span style="color:#24292e;">3. **底层实现：** 这些类使用了底层的 CAS（Compare and Swap）操作来实现原子性，即比较并交换操作，保证了并发情况下的线程安全性。</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">原子类通常用于需要在多线程环境下进行操作的场景，比如计数器、标志位的更新等。它们能够提供高效且线程安全的解决方案，避免了使用锁所带来的开销和复杂性。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h3><ul><li><a href="https://spring.io/" target="_blank" rel="noreferrer">Spring</a></li><li><a href="https://github.com/DespairYoke/java-advance" target="_blank" rel="noreferrer">SpringAdvance</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/" target="_blank" rel="noreferrer">Spring 框架的设计理念与设计模式分析</a></li><li><a href="https://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="noreferrer">Spring：源码解读Spring IOC原理</a></li></ul>`,15),p=[l];function i(o,t,c,d,h,b){return e(),n("div",null,p)}const m=a(r,[["render",i]]);export{u as __pageData,m as default};
