import{_ as e,o as t,c as o,R as a}from"./chunks/framework.7FlijoJG.js";const u=JSON.parse('{"title":"java","description":"","frontmatter":{"title":"java","date":"2023-11-29T22:48:07.000Z","Tags":["tech"],"Draft":true,"HideInList":false,"Feature":null,"IsTop":false},"headers":[],"relativePath":"interview/java.md","filePath":"interview/java.md","lastUpdated":1703254130000}'),r={name:"interview/java.md"},n=a('<h3 id="锁" tabindex="-1">锁 <a class="header-anchor" href="#锁" aria-label="Permalink to &quot;锁&quot;">​</a></h3><p>在 Java 中，锁是用来控制对共享资源的访问的机制，它可以帮助确保在多线程环境下数据的安全性和一致性。Java 提供了多种锁的实现，常见的包括：</p><ol><li><p><strong>synchronized关键字</strong>：Java最基本的锁机制之一。通过<code>synchronized</code>关键字可以创建同步块或同步方法，使得在同一时间只有一个线程可以访问被同步的代码块或方法，确保线程安全性。</p></li><li><p><strong>ReentrantLock</strong>：Java.util.concurrent包提供的一个可重入锁实现。与<code>synchronized</code>相比，<code>ReentrantLock</code>提供了更多的灵活性，例如可中断锁、尝试获取锁和定时获取锁等功能。</p></li><li><p><strong>ReadWriteLock</strong>：读写锁，包含了读锁和写锁。读写锁可以允许多个线程同时读取共享资源，但在写操作时必须互斥。<code>ReentrantReadWriteLock</code>是其常见的实现。</p></li><li><p><strong>StampedLock</strong>：Java 8新增的一种乐观锁机制。<code>StampedLock</code>提供了三种模式：写锁、悲观读锁和乐观读。乐观读不阻塞写操作，但在实际修改前需要确认数据是否被其他线程修改过。</p></li><li><p><strong>Condition</strong>：通常与<code>ReentrantLock</code>一起使用，可以通过<code>Condition</code>对象实现更灵活的线程通信。</p></li></ol><p>这些锁机制都有各自的特点和适用场景。在项目中使用锁时，需要根据具体情况和需求选择合适的锁，并遵循良好的多线程编程实践，以确保线程安全性和性能。同时，需要避免死锁和性能瓶颈等问题。</p><h3 id="拦截器" tabindex="-1">拦截器 <a class="header-anchor" href="#拦截器" aria-label="Permalink to &quot;拦截器&quot;">​</a></h3><p>Spring 拦截器是基于 AOP 的，由 Spring 管理。拦截器是针对 Spring MVC 框架的，可以拦截处理器的执行，并在执行处理器方法前后做一些额外的操作。在 Spring MVC 中，拦截器的执行顺序由配置决定，通过<code>InterceptorRegistry</code>中的<code>addInterceptor()</code>方法添加的顺序决定了执行顺序。</p><h3 id="过滤器" tabindex="-1">过滤器 <a class="header-anchor" href="#过滤器" aria-label="Permalink to &quot;过滤器&quot;">​</a></h3><p>过滤器是基于 Servlet 规范的一部分，用于对请求进行预处理或后处理。过滤器在 Servlet 容器中管理，不是由 Spring 管理的。在 Spring Web 应用中，过滤器的执行顺序由 Servlet 容器决定，一般是按照配置的顺序依次执行。</p><h3 id="乐观锁和悲观锁的区别" tabindex="-1">乐观锁和悲观锁的区别 <a class="header-anchor" href="#乐观锁和悲观锁的区别" aria-label="Permalink to &quot;乐观锁和悲观锁的区别&quot;">​</a></h3><p>乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是两种处理并发访问数据的不同策略。</p><ol><li><p><strong>乐观锁</strong>：</p><ul><li><strong>思想</strong>：乐观锁的思想是假设并发访问的情况下不会发生数据修改冲突，直到提交更新时才检查是否有冲突。在这种情况下，不会对数据进行实际的锁定，而是在更新前检查是否有其他对数据做了修改。</li><li><strong>实现方式</strong>：通过版本控制或者时间戳机制来实现。在更新时，先获取数据的版本信息，然后比较更新前后的版本信息是否一致，如果一致则更新成功，否则认为数据已被其他事务修改过，更新失败需要进行回滚或重新尝试。</li><li><strong>适用场景</strong>：适用于读取操作较多、更新冲突较少的场景，可以提高并发性能。</li></ul></li><li><p><strong>悲观锁</strong>：</p><ul><li><strong>思想</strong>：悲观锁则是假设并发访问的情况下会发生数据修改冲突，在操作数据时先对数据进行锁定，防止其他事务对其进行修改，直到当前事务完成操作。</li><li><strong>实现方式</strong>：通过数据库的行级锁、表级锁或者Java中的synchronized关键字等方式来实现。</li><li><strong>适用场景</strong>：适用于更新操作较多、更新冲突较频繁的场景，保证数据的一致性。</li></ul></li></ol><p>在实际应用中，选择乐观锁还是悲观锁需要根据业务需求、数据访问情况以及性能要求进行权衡选择。乐观锁适用于并发冲突较少的情况，可以提高系统的并发性能；悲观锁则更适合对数据一致性要求较高的场景，但可能降低系统的并发性能。</p>',12),i=[n];function s(l,c,d,p,g,h){return t(),o("div",null,i)}const v=e(r,[["render",s]]);export{u as __pageData,v as default};
