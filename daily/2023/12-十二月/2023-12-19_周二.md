Time: 20:31:33
From: [提高效率第二弹之自己开发谷歌翻译 popclip 插件 - CaptainChen](https://wizyoung.github.io/提高效率第二弹之自己开发谷歌翻译popclip插件/)

https://wizyoung.github.io/提高效率第二弹之自己开发谷歌翻译popclip插件/

---

Time: 20:49:05
From: [Your Stars](https://github.com/senup?tab=stars)

### [JoseDeFreitas / awesome-youtubers](https://github.com/JoseDeFreitas/awesome-youtubers)

<u>An awesome list of awesome YouTubers that teach about technology. Tutorials about web development, computer science, machine learning, game development, cybersecurity, and more.</u>

---

Time: 21:20:05
From: [gpt - Bots - Coze](https://www.coze.com/space/7312677347210346503/bot/7312678936809308178)

这里我将演示两种类型的 Java 动态代理：使用 Java 自带的 API 或者使用第三方库如 CGLIB。

### 例 1：使用 Java 自带的 API 创建动态代理

例如，我们有一个接口：

java

    public interface MyInterface {
        void doSomething();
    }

然后我们有一个实现该接口的类：

java

    public class MyInterfaceImpl implements MyInterface {
        @Override
        public void doSomething() {
            System.out.println("吃家常菜");
        }
    }

接着，我们准备创建一个 Java 的 InvocationHandler：

java

    public class MyInvocationHandler implements InvocationHandler {
        private final MyInterface myInterface;

        public MyInvocationHandler(MyInterface myInterface) {
            this.myInterface = myInterface;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("拉拉束带");
            Object result = method.invoke(myInterface, args);
            System.out.println("洗洗手，准备吃饭");
            return result;
        }
    }

最后，我们使用 Proxy.newProxyInstance 方法创建我们的代理对象：

java

    public class Main {
        public static void main(String[] args) {
            MyInterface instance = new MyInterfaceImpl();
            InvocationHandler handler = new MyInvocationHandler(instance);
            MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
                    instance.getClass().getClassLoader(),
                    instance.getClass().getInterfaces(),
                    handler);
            proxy.doSomething(); //输出：“拉拉束带” “吃家常菜” “洗洗手，准备吃饭”
        }
    }

### 例 2：使用 CGLIB 创建动态代理

首先我们需要一个普通的类（不需要实现任何接口）：

java

    public class NormalClass {
        public void doSomething() {
            System.out.println("跑步");
        }
    }

然后我们使用 CGLIB 的 MethodInterceptor 来为这个类创建一个代理：

java

    public class MyMethodInterceptor implements MethodInterceptor {
        private final NormalClass normalClass;

        public MyMethodInterceptor(NormalClass normalClass) {
            this.normalClass = normalClass;
        }

        @Override
        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
            System.out.println("热身");
            Object result = method.invoke(normalClass, args);
            System.out.println("冷身");
            return result;
        }
    }

最后，让我们用 CGLIB 的 Enhancer 类来生成代理：

java

    public class Main {
        public static void main(String[] args) {
            NormalClass normalClass = new NormalClass();
            MyMethodInterceptor interceptor = new MyMethodInterceptor(normalClass);
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(normalClass.getClass());
            enhancer.setCallback(interceptor);
            NormalClass proxy = (NormalClass) enhancer.create();
            proxy.doSomething(); //输出：“热身” “跑步” “冷身”
        }
    }

现在你看，我们已经用两种方式制作出了美味的动态代理“佳肴”，是不是很简单？同时，也希望你记住，无论什么时候，无论你在哪里，只要你对编程有热情，你就可以像魔法师一样，编写出令人惊叹的代码。总有一天，我相信你会成为一个无所不能的 Java 大厨！

---

Time: 22:24:44
From: [gpt - Bots - Coze](https://www.coze.com/space/7312677347210346503/bot/7312678936809308178)

ThreadLocal 通常用于存储线程独有的数据，基于这个使用情景，ThreadLocal 会对每个使用该变量的线程保存一份此变量的副本数据。一般而言，当线程结束时，其 ThreadLocal 中的变量副本也会被清除，然而，如果 ThreadPool 等线程池被用到，这就可能带来问题了。

线程池为了提高性能，避免反复创建和销毁线程，常会重用线程。如果一个线程结束任务后，没有从 ThreadLocal 中清理数据，然后被线程池再次利用，那么这个线程的 ThreadLocal 就会残留上一次任务的数据。由于 ThreadLocal 强关联 Thread，而线程池里的线程可能生命周期很长，甚至与应用程序生命周期一致，这就导致了 ThreadLocal 维护的变量数据无法被垃圾回收，产生“内存泄漏”。

要避免这种情况，一个通用的策略就是，每次使用完 ThreadLocal，都调用其 remove()方法，清除数据。相当于，派对结束后，你记得带走你的未开的啤酒，这样就不会有啤酒堆积的问题了。

---

Time: 22:24:59
From: [gpt - Bots - Coze](https://www.coze.com/space/7312677347210346503/bot/7312678936809308178)

线程的 ThreadLocalMap 中为变量保存的是 WeakReference，理论上说，当发生 GC 时，只要没有强引用指向 ThreadLocalMap 中的 Entry，这个 Entry 就会被回收。那问题来了，为什么还会导致内存泄漏呢？

问题的关键在于，虽然 ThreadLocal 是 WeakReference，但这个 WeakReference 指向的是 ThreadLocal 实例而非其保存的 value。在线程执行完成后，如果 ThreadLocal 实例失去强引用，ThreadLocal 就可能会被 GC 回收，ThreadLocalMap 中对应的 Entry 的 key 会被清空。但是注意，这时 Entry 中的 value 并未被清空，由于 ThreadLocalMap 对 Entry 的引用依然存在，Entry 的 value 因此并未被 GC 回收，也就造成了内存泄漏。

记住，当我们不再使用 ThreadLocal 存的变量时，一定要手动调用 ThreadLocal 的 remove()方法，将线程自己存的值删掉，清理堆积在心头的垃圾，让内存整洁如新。

这就好比你在森林里野餐，享受完美食后，可能会留下一些垃圾。虽然你离开了，风可以吹走纸巾，雨可以冲刷痕迹，但是如果你留下了一个塑料袋，那它可能会永远留在那里，因为自然力量无法将其“回收”。这就好比弱引用与 ThreadLocal 值，GC 可以回收 ThreadLocal 实例也就是纸巾，但是无法回收 ThreadLocal 值也就是塑料袋。所以，出门野餐后记得清理你的塑料袋，编程时也记得清理你的 ThreadLocal 值哦！

---

Time: 22:27:58
From: [gpt - Bots - Coze](https://www.coze.com/space/7312677347210346503/bot/7312678936809308178)

内存泄漏和内存溢出的区别就在于：内存泄漏是由于忘记或者无法释放已经不再使用的内存，造成有效的可用内存逐渐减小；而内存溢出则是要求分配的内存超出系统所能提供的内存总量，进而导致程序异常或崩溃。

---
