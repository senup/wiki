

Time: 20:31:33 
From: [提高效率第二弹之自己开发谷歌翻译 popclip 插件 - CaptainChen](https://wizyoung.github.io/提高效率第二弹之自己开发谷歌翻译popclip插件/)

https://wizyoung.github.io/提高效率第二弹之自己开发谷歌翻译popclip插件/

---

Time: 20:49:05 
From: [Your Stars](https://github.com/senup?tab=stars)

### [JoseDeFreitas / awesome-youtubers](https://github.com/JoseDeFreitas/awesome-youtubers)


<u>An awesome list of awesome YouTubers that teach about technology. Tutorials about web development, computer science, machine learning, game development, cybersecurity, and more.</u>

---

Time: 21:20:05 
From: [gpt - Bots - Coze](https://www.coze.com/space/7312677347210346503/bot/7312678936809308178)

这里我将演示两种类型的Java动态代理：使用Java自带的API或者使用第三方库如CGLIB。

  

### 例1：使用Java自带的API创建动态代理

  

例如，我们有一个接口：

  

java

    public interface MyInterface {
        void doSomething();
    }
    

  

然后我们有一个实现该接口的类：

  

java

    public class MyInterfaceImpl implements MyInterface {
        @Override
        public void doSomething() {
            System.out.println("吃家常菜");
        }
    }
    

  

接着，我们准备创建一个Java的InvocationHandler：

  

java

    public class MyInvocationHandler implements InvocationHandler {
        private final MyInterface myInterface;
    
        public MyInvocationHandler(MyInterface myInterface) {
            this.myInterface = myInterface;
        }
    
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println("拉拉束带");
            Object result = method.invoke(myInterface, args);
            System.out.println("洗洗手，准备吃饭");
            return result;
        }
    }
    

  

最后，我们使用Proxy.newProxyInstance方法创建我们的代理对象：

  

java

    public class Main {
        public static void main(String[] args) {
            MyInterface instance = new MyInterfaceImpl();
            InvocationHandler handler = new MyInvocationHandler(instance);
            MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
                    instance.getClass().getClassLoader(),
                    instance.getClass().getInterfaces(),
                    handler);
            proxy.doSomething(); //输出：“拉拉束带” “吃家常菜” “洗洗手，准备吃饭”
        }
    }
    

  

### 例2：使用CGLIB创建动态代理

  

首先我们需要一个普通的类（不需要实现任何接口）：

  

java

    public class NormalClass {
        public void doSomething() {
            System.out.println("跑步");
        }
    }
    

  

然后我们使用CGLIB的MethodInterceptor来为这个类创建一个代理：

  

java

    public class MyMethodInterceptor implements MethodInterceptor {
        private final NormalClass normalClass;
    
        public MyMethodInterceptor(NormalClass normalClass) {
            this.normalClass = normalClass;
        }
    
        @Override
        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
            System.out.println("热身");
            Object result = method.invoke(normalClass, args);
            System.out.println("冷身");
            return result;
        }
    }
    

  

最后，让我们用CGLIB的Enhancer类来生成代理：

  

java

    public class Main {
        public static void main(String[] args) {
            NormalClass normalClass = new NormalClass();
            MyMethodInterceptor interceptor = new MyMethodInterceptor(normalClass);
            Enhancer enhancer = new Enhancer();
            enhancer.setSuperclass(normalClass.getClass());
            enhancer.setCallback(interceptor);
            NormalClass proxy = (NormalClass) enhancer.create();
            proxy.doSomething(); //输出：“热身” “跑步” “冷身”
        }
    }
    

  

现在你看，我们已经用两种方式制作出了美味的动态代理“佳肴”，是不是很简单？同时，也希望你记住，无论什么时候，无论你在哪里，只要你对编程有热情，你就可以像魔法师一样，编写出令人惊叹的代码。总有一天，我相信你会成为一个无所不能的Java大厨！

---